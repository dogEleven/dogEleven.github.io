<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Planet Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Space Background: Black to Deep Galaxy Blue */
            background: linear-gradient(to top, #000000 0%, #191970 100%);
            /* Space Background: Black to Deep Galaxy Blue */
            background: linear-gradient(to top, #000000 0%, #191970 100%);
        }


        /* Mobile Controls */
        .control-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-family: sans-serif;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        .d-pad-left {
            left: 40px;
            bottom: 40px;
            width: 160px;
            height: 160px;
            pointer-events: none;
            position: absolute;
        }

        .d-pad-right {
            right: 40px;
            bottom: 40px;
            width: 120px;
            height: 180px;
            pointer-events: none;
            position: absolute;
        }

        #btn-left {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 70px;
            height: 70px;
            pointer-events: auto;
        }

        #btn-right {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 70px;
            height: 70px;
            pointer-events: auto;
        }

        #btn-fwd {
            position: absolute;
            top: 0;
            right: 0;
            width: 80px;
            height: 80px;
            pointer-events: auto;
        }

        #btn-back {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 80px;
            height: 80px;
            pointer-events: auto;
        }

        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: lime;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: 3000;
        }

        /* --- Chat UI --- */
        #chat-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        #chat-input {
            width: 100%;
            padding: 10px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-family: sans-serif;
            outline: none;
            backdrop-filter: blur(5px);
        }

        #chat-status {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            font-family: sans-serif;
            text-shadow: 0 1px 2px black;
        }

        /* 3D Chat Bubble */
        .chat-bubble {
            position: absolute;
            background: white;
            color: black;
            padding: 5px 10px;
            border-radius: 10px;
            font-family: sans-serif;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            /* Triangle handle */
        }

        .chat-bubble::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid white;
        }
    </style>
    <!-- Load Three.js from CDN (UMD version for file:// compatibility) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Post-Processing Dependencies (r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/shaders/BokehShader.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/BokehPass.js"></script>
</head>

<body>
    <!-- Mobile Controls Containers -->
    <div class="d-pad-left">
        <div id="btn-left" class="control-btn">←</div>
        <div id="btn-right" class="control-btn">→</div>
    </div>
    <div class="d-pad-right">
        <div id="btn-fwd" class="control-btn">↑</div>
        <div id="btn-back" class="control-btn">↓</div>
    </div>

    <div id="debug-panel">
        <div>ID: <span id="dbg-id">...</span></div>
        <div>Role: <span id="dbg-role">Init...</span></div>
        <div>Peers: <span id="dbg-peers">0</span></div>
        <div>In: <span id="dbg-in">0</span> | Out: <span id="dbg-out">0</span></div>
        <div>Err: <span id="dbg-err">-</span></div>
    </div>

    <div id="chat-overlay">
        <div id="chat-status">Connecting to Multiplayer...</div>
        <input type="text" id="chat-input" placeholder="Press Enter to Chat..." maxlength="50">
    </div>

    <script>
        // --- 1. Noise Implementation ---
        const p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168,
            68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
            102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
            223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224,
            232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
            49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
            141, 128, 195, 78, 66, 215, 61, 156, 180];
        const perm = new Uint8Array(512);
        for (let i = 0; i < 512; i++) perm[i] = p[i & 255];

        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        function lerp(t, a, b) {
            return a + t * (b - a);
        }

        function grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        function noise(x, y, z) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            const u = fade(x);
            const v = fade(y);
            const w = fade(z);
            const A = perm[X] + Y, AA = perm[A] + Z, AB = perm[A + 1] + Z,
                B = perm[X + 1] + Y, BA = perm[B] + Z, BB = perm[B + 1] + Z;
            return lerp(w, lerp(v, lerp(u, grad(perm[AA], x, y, z),
                grad(perm[BA], x - 1, y, z)),
                lerp(u, grad(perm[AB], x, y - 1, z),
                    grad(perm[BB], x - 1, y - 1, z))),
                lerp(v, lerp(u, grad(perm[AA + 1], x, y, z - 1),
                    grad(perm[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(perm[AB + 1], x, y - 1, z - 1),
                        grad(perm[BB + 1], x - 1, y - 1, z - 1))));
        }

        // --- 2. Scene Setup ---
        const scene = new THREE.Scene();
        // scene.background = new THREE.Color(0x87CEEB); // Removed for CSS Gradient
        // Match Fog to the bottom color of the gradient (#000000 - Space)
        scene.fog = new THREE.Fog(0x000000, 20, 150);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Enable alpha to let CSS background show through
        const renderer = new THREE.WebGLRenderer({
            antialias: true, alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 3. Planet Generation ---
        const planetRadius = 40;
        const geometry = new THREE.SphereGeometry(planetRadius, 200, 200);

        const count = geometry.attributes.position.count;
        const positions = geometry.attributes.position;
        const v3 = new THREE.Vector3();

        // Deform Geometry on CPU (so physics raycaster matches visual)
        for (let i = 0; i < count; i++) {
            v3.fromBufferAttribute(positions, i);
            const dir = v3.clone().normalize();

            // 1. Structure Noise (Large features)
            // Smoother terrain: base freq 1.0
            let n = noise(dir.x * 1.0, dir.y * 1.0, dir.z * 1.0);

            // Reduced detail noise amplitude (0.25) and frequency (3.0)
            n += 0.25 * noise(dir.x * 3.0, dir.y * 3.0, dir.z * 3.0);

            // Terrain Logic
            // Apply Power Curve for "Flat Plains, High Peaks"
            // Use Math.pow(abs(n), 2.5) * sign(n)
            const power = 3.0;
            const sign = n < 0 ? -1 : 1;
            let shapedN = sign * Math.pow(Math.abs(n), power);

            // Scale up significantly because pow(x, 3) makes values much smaller
            const heightScale = 30.0;
            let h = shapedN * heightScale;

            // --- ROAD GENERATION START ---
            // Normalized Y is roughly dir.y
            // Road Width definition
            const roadHalfWidth = 2.0; // Half width in world units approx

            // Distance from equator on surface ~= planetRadius * abs(dir.y) (approx)
            // Arc length = R * angle. angle = asin(y). linear approx y works for small y.
            const distFromEquator = planetRadius * Math.abs(dir.y);

            const roadBandWidth = 3.0; // The flat area width (Narrowed to match)
            const roadTransition = 3.0; // The blend area

            // If within road band, flatten to constant height
            if (distFromEquator < (roadBandWidth + roadTransition)) {
                // Road Height: slightly above sea level (0.0) 
                // Sea Level is -1.0. Let's make it 0.5 for a nice causeway.
                const roadHeight = 0.5;

                let t = 0.0;

                if (distFromEquator < roadBandWidth) {
                    t = 1.0;
                }

                else {
                    // Linear transition? Or smoothstep.
                    // normalized edge distance: 0 (at band) to 1 (at band+trans)
                    let edgeDist = (distFromEquator - roadBandWidth) / roadTransition;
                    t = 1.0 - (edgeDist * edgeDist * (3.0 - 2.0 * edgeDist)); // smoothstep logic manually
                }

                // Blend h towards roadHeight
                // h = h + (roadHeight - h) * t;
                h = h * (1.0 - t) + roadHeight * t;
            }

            // --- ROAD GENERATION END ---

            // Flatten Water removed, just natural terrain
            let finalRadius = planetRadius + h;

            dir.multiplyScalar(finalRadius);
            positions.setXYZ(i, dir.x, dir.y, dir.z);
        }

        geometry.computeVertexNormals();
        geometry.attributes.position.needsUpdate = true;

        // Procedural Shader for sharp details
        const material = new THREE.ShaderMaterial({
            vertexShader: ` varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                vPosition=position; // Local position (includes CPU deformation)
                vNormal=normal;
                gl_Position=projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }

            `,
            fragmentShader: ` varying vec3 vPosition;
            varying vec3 vNormal;
            uniform float time;


            // Simple pseudo-random for noise
            float noise(vec3 p) {
                return fract(sin(dot(p, vec3(12.9898, 78.233, 128.85))) * 43758.5453);
            }

            // Smooth mixing function
            vec3 softMix(vec3 a, vec3 b, float val, float edge0, float edge1) {
                float t=smoothstep(edge0, edge1, val);
                return mix(a, b, t);
            }

            void main() {
                // Calculate height relative to base radius
                float r=length(vPosition);
                float baseRadius=40.0;
                float h=r - baseRadius;

                // Bolder, Saturated Colors
                vec3 cDeepWater=vec3(0.1, 0.4, 0.8); // Lighter Deep Blue (was 0.0, 0.1, 0.8)
                vec3 cWater=vec3(0.2, 0.7, 0.95); // Lighter Cyan (was 0.0, 0.8, 1.0)
                vec3 cWetSand=vec3(0.8, 0.6, 0.3); // Darker/Wet Sand
                vec3 cSand=vec3(1.0, 0.85, 0.5); // Bright Sand
                vec3 cGrass=vec3(0.4, 0.8, 0.2); // Vibrant Light Green
                vec3 cForest=vec3(0.1, 0.5, 0.15); // Rich Green (not black)
                vec3 cRock=vec3(0.5, 0.5, 0.55); // Neutral Grey
                vec3 cSnow=vec3(0.9, 0.95, 1.0); // White with hint of blue

                // Noise grain for texture
                float grain=noise(vPosition * 8.0) * 0.08;
                float sh=h + grain; // Noisy height for terrain transitions

                // Adjust Sea Level for new scale
                float seaLevel=-1.0;

                // 2. Land Layer (Restored)
                vec3 landCol=cSand;

                // Wet Sand -> Dry Sand
                // Below seaLevel it is wet, dries as it goes up
                // User Request: Lower it so gradient matches water line.
                // Water Level is -1.0. 
                // Let's transition from -2.0 (Deep Wet) to 0.0 (Dry).
                // Midpoint is -1.0 (Water Line).
                landCol=softMix(cWetSand, cSand, sh, seaLevel - 1.0, seaLevel + 1.0);

                // Sand -> Grass 
                // EXPANDED GREEN ZONE: Start very close to water
                landCol=softMix(landCol, cGrass, sh, seaLevel + 0.2, seaLevel + 0.8);
                // Grass -> Forest 
                // Smoother/Wider Transition: 0.0 to 12.0 (was -1.5 to 4.0)
                // Eliminates "dead green" block by mixing earlier and longer
                landCol=softMix(landCol, cForest, sh, 0.0, 12.0);
                // Forest -> Rock 
                // Overlap with Forest: 8.0 to 25.0 (was 15.0 to 22.0)
                // Starts fading to rock while still in forest zone
                landCol=softMix(landCol, cRock, sh, 8.0, 25.0);
                // Rock -> Snow 
                // Higher peaks: 20.0 to 32.0 (was 24.0 to 32.0)
                landCol=softMix(landCol, cSnow, sh, 20.0, 32.0);

                // --- ROAD RENDERING ---
                // vPosition.y is distance from equator plane.
                // Flattened area is where abs(vPosition.y) < roadBandWidth approx.
                // Because we deformed the mesh, vPosition reflects that.
                // However, 'vPosition' in FS is interpolated. 
                float distFromEq=abs(vPosition.y);
                const float roadBandW=3.0; // Narrowed by 40% (was 5.0)


                if (distFromEq < roadBandW) {
                    // Soft edge for texture
                    float edgeDist=roadBandW - distFromEq;
                    // Sharpened Road Edge: 0.0 to 0.2 (was 1.0)
                    float roadMix=smoothstep(0.0, 0.2, edgeDist);

                    vec3 cRoad=vec3(0.3, 0.3, 0.3); // Lighter Asphalt (was 0.15)

                    // White Dashed Lines
                    float roadWidth=roadBandW * 2.0;
                    // Center line:
                    // angle = atan(z, x)
                    float angle=atan(vPosition.z, vPosition.x);
                    float dash=sin(angle * 40.0); // Frequency lowered (was 80) -> Larger Gaps

                    // Line thickened by 40% (0.2 -> 0.28)
                    // THEN Narrowed by 30% (0.28 -> 0.2)
                    if (distFromEq < 0.2 && dash > 0.0) {
                        cRoad=vec3(0.9, 0.9, 0.9); // White
                    }

                    landCol=mix(landCol, cRoad, roadMix);
                }

                // --- ROAD END ---



                // --- ROAD END ---


                // --- FOAM REMOVED (User Request) ---


                // 3. Final Color (No Water Mix)
                vec3 finalColor=landCol;

                gl_FragColor=vec4(finalColor, 1.0);
            }

            `,
            uniforms: {
                time: { value: 0.0 }
            }
        });

        const planet = new THREE.Mesh(geometry, material);
        scene.add(planet);

        // --- 3.5 Water Sphere ---
        const seaLevelRef = -0.5; // Slightly deeper
        const waterGeo = new THREE.SphereGeometry(planetRadius + seaLevelRef, 96, 96);

        const waterMat = new THREE.MeshBasicMaterial({
            color: 0x00ccff, // Cyan-Blue (User Request)
            transparent: true,
            opacity: 0.85,
            side: THREE.FrontSide
        });
        const waterSphere = new THREE.Mesh(waterGeo, waterMat);
        scene.add(waterSphere);

        // Add a directional light so the water shines
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(50, 50, 50);
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);

        // --- 3.6 Star Field ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 3000;
        const starPos = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
            // Spherical distribution to keep away from planet
            // User Request: Much further away to reduce parallax/movement speed
            const r = 1000 + Math.random() * 1500; // Min radius 1000, Max 2500
            const theta = Math.random() * Math.PI * 2; // Azimuth
            const phi = Math.acos(2 * Math.random() - 1); // Polar

            starPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            starPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            starPos[i * 3 + 2] = r * Math.cos(phi);
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));

        const starMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 5.0
        });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- 3.8 Interactive Grass ---
        // --- 3.8 Interactive Grass ---
        const grassCount = 80000;
        // Reduced Size: Wide Base (0.3), tapered by shader
        // Height 1.2 (was 0.8), Translate 0.2 (was 0.3)
        // Original: Base -0.1, Top 0.7
        // New: 1.2 height -> [-0.6, 0.6]. +0.2Y -> [-0.4, 0.8].
        // Result: Deeper underground (-0.4) and taller (+0.8).
        const grassGeo = new THREE.PlaneGeometry(0.3, 1.2);
        grassGeo.translate(0, 0.2, 0); // Pivot logic

        const grassMat = new THREE.ShaderMaterial({
            uniforms: {
                time: {
                    value: 0
                }

                ,
                carPos: {
                    value: new THREE.Vector3()
                }

                ,
                cameraPos: {
                    value: new THREE.Vector3()
                }
            }

            ,
            vertexShader: ` uniform float time;
            uniform vec3 carPos;
            attribute vec3 offset;
            attribute vec3 instanceNormal;
            attribute float scale;
            attribute float rot;

            varying vec2 vUv;
            varying float vAltitude; // Pass height to fragment
            varying vec3 vPos; // World position for noise

            // Quaternion rotation utility
            vec3 rotateVector(vec4 q, vec3 v) {
                return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
            }

            vec4 axisAngleToQuaternion(vec3 axis, float angle) {
                float halfAngle=angle * 0.5;
                float s=sin(halfAngle);
                return vec4(axis * s, cos(halfAngle));
            }

            void main() {
                vUv=uv;

                // Calculate Altitude for coloring
                // Planet Radius is 40.0
                vAltitude=length(offset) - 40.0;
                vPos=offset;

                // 1. Base Geometry
                vec3 pos=position;
                pos.y *=scale;
                // Width Logic: CONSTANT WIDTH (for rounded top via Fragment Shader)
                // User Request: Round top (not pointy)
                // We remove the taper here and handle the shape in Fragment Shader.
                pos.x *=(scale * 0.5 + 0.5);

                // Capture length to restore later
                float originalLen=length(pos);

                // --- Wind Sway ---
                // Combine sine waves for random-ish motion
                // Phase depends on world position (offset) so they don't sway together
                float wind=sin(time * 3.0 + offset.x * 0.5) + sin(time * 1.5 + offset.z * 0.5) * 0.5;
                // Apply to top only (uv.y), scaled STRONGER (was 0.05)
                // User Request: Stronger wind feel.
                pos.x +=wind * 0.15 * uv.y;

                // 2. Random Rotation (Y-axis)
                vec4 qRand=axisAngleToQuaternion(vec3(0, 1, 0), rot);
                pos=rotateVector(qRand, pos);

                // 3. Align to Surface Normal
                vec3 up=vec3(0, 1, 0); // Grass local up
                vec3 normal=normalize(instanceNormal);

                // Rotation from Up to Normal
                vec3 axis=cross(up, normal);
                float cosA=dot(up, normal);

                // Simple alignment
                vec4 qAlign=vec4(0, 0, 0, 1);

                if (cosA > -0.99) {
                    qAlign=normalize(vec4(axis, 1.0 + cosA));
                }

                else {
                    qAlign=vec4(1, 0, 0, 0); // Flip
                }

                pos=rotateVector(qAlign, pos);

                // --- 4. Car Interaction ---
                // Push grass away from car
                float dist=distance(offset, carPos);
                float radius=3.5; // Interaction radius

                if (dist < radius) {
                    float strength=(1.0 - dist / radius); // 0 to 1
                    strength=pow(strength, 2.0); // Non-linear falloff

                    vec3 pushDir=normalize(offset - carPos);

                    // Push away from car, mostly affecting the top (uv.y)
                    // flattened y slightly to simulate being crushed
                    pos +=pushDir * strength * 2.5 * uv.y;
                }

                // --- Fix Stretching ---
                // Force the bent grass to maintain its original length (relative to its pivot)
                // This naturally lowers the Y as it bends X/Z, preventing the "rubber" look.
                if (originalLen > 0.001) {
                    pos=normalize(pos) * originalLen;
                }

                // 5. Translate
                vec3 worldPos=pos + offset;

                gl_Position=projectionMatrix * viewMatrix * vec4(worldPos, 1.0);
            }

            `,
            fragmentShader: ` varying vec2 vUv;
            varying float vAltitude;
            varying vec3 vPos;

            // Simple pseudo-random for noise (Same as Planet Shader)
            float noise(vec3 p) {
                return fract(sin(dot(p, vec3(12.9898, 78.233, 128.85))) * 43758.5453);
            }

            // Smooth mixing function
            vec3 softMix(vec3 a, vec3 b, float val, float edge0, float edge1) {
                float t=smoothstep(edge0, edge1, val);
                return mix(a, b, t);
            }

            void main() {
                // Simple Alpha Cutoff (Side Margins)
                if (vUv.x < 0.1 || vUv.x > 0.9) discard;
                if (vUv.y < 0.0) discard;

                // ROUNDED TOP LOGIC
                // Aspect ratio correction: Geo is 0.3 x 1.2 (Ratio ~0.25)
                // Effective width in UV is 0.8 (0.1 to 0.9).
                // To get a circle, RadiusY should vary.
                // Let's assume a semi-circle cap at the top 10% (0.9 to 1.0)
                if (vUv.y > 0.9) {
                    float nx=(vUv.x - 0.5) / 0.4; // Map 0.1..0.9 to -1..1
                    float ny=(vUv.y - 0.9) / 0.1; // Map 0.9..1.0 to 0..1
                    if (nx*nx + ny*ny > 1.0) discard;
                }

                // Exact Color Match with Planet Shader
                vec3 cGrass=vec3(0.4, 0.8, 0.2); // Vibrant Light Green
                vec3 cForest=vec3(0.1, 0.5, 0.15); // Rich Green
                vec3 cRock=vec3(0.5, 0.5, 0.55); // Neutral Grey

                // Add noise to altitude just like planet shader
                float grain=noise(vPos * 8.0) * 0.08;
                float sh=vAltitude + grain;

                // Base Color: Grass
                // Gradient: Darker base to Lighter tip
                vec3 cGrassTop=vec3(0.42, 0.82, 0.22); // Very subtle gradient vs base (0.4, 0.8, 0.2)
                // Use pow(vUv.y) to control gradient curve if needed, linear for now
                vec3 col=mix(cGrass, cGrassTop, vUv.y);

                // Transition: Grass -> Forest (Match Planet 0.0 -> 12.0)
                // Start mixing forest at 0.0 (near sea level)
                // Widen range to eliminate "dead green"
                col=softMix(col, cForest, sh, 0.0, 12.0);

                // Transition: Forest -> Rock (Match Planet 8.0 -> 25.0)
                // High altitude grass will blend into the rock color
                col=softMix(col, cRock, sh, 8.0, 25.0);

                gl_FragColor=vec4(col, 1.0);
            }

            `,
            side: THREE.DoubleSide
        });

        const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, grassCount);

        // Populate Grass Instances
        const dummy = new THREE.Object3D();
        const _v3 = new THREE.Vector3();
        const _normal = new THREE.Vector3();

        // Arrays for attributes
        const offsets = new Float32Array(grassCount * 3);
        const normals = new Float32Array(grassCount * 3);
        const scales = new Float32Array(grassCount);
        const rots = new Float32Array(grassCount);

        let grassIdx = 0;

        // Try up to X times to find valid spots
        for (let i = 0; i < grassCount * 3 && grassIdx < grassCount; i++) {
            // Random point on sphere surface
            _v3.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();

            // Re-calculate noise height for this point
            // Re-calculate noise height for this point
            // Copy logic from planet generation loop EXACTLY
            // 1. Structure Noise (Large features)
            // Smoother terrain: base freq 1.0
            let n = noise(_v3.x * 1.0, _v3.y * 1.0, _v3.z * 1.0);
            // Reduced detail noise amplitude (0.25) and frequency (3.0)
            n += 0.25 * noise(_v3.x * 3.0, _v3.y * 3.0, _v3.z * 3.0);

            // Terrain Logic
            // Apply Power Curve for "Flat Plains, High Peaks"
            const power = 3.0;
            const sign = n < 0 ? -1 : 1;
            let shapedN = sign * Math.pow(Math.abs(n), power);

            const heightScale = 30.0;
            let h = shapedN * heightScale;

            // Green Zone Criteria
            const seaLevel = -0.5;

            // Define Road Zone (Must match Planet Generation)
            const distFromEquator = planetRadius * Math.abs(_v3.y);
            // Road Band (3.0)
            // User Request: Grow closer to road.
            // Buffer 0.5 -> Limit 3.5
            const roadZoneLimit = 3.5;
            const isRoad = distFromEquator < roadZoneLimit;

            // --- SYNC HEIGHT WITH ROAD SHADER ---
            // The shader flattens the geometry near the road, but 'h' here is the raw noisy height.
            // We must replicate the shader's height modification so grass sits ON the flattened ground.

            const roadBandWidth = 3.0; // Matches Shader
            const roadTransition = 3.0; // Matches Shader (assumed default)

            if (distFromEquator < (roadBandWidth + roadTransition)) {
                const roadHeight = 0.5; // Matches Shader
                let t = 0.0;

                if (distFromEquator < roadBandWidth) {
                    t = 1.0;
                } else {
                    // Smoothstep logic from shader
                    let edgeDist = (distFromEquator - roadBandWidth) / roadTransition;
                    t = 1.0 - (edgeDist * edgeDist * (3.0 - 2.0 * edgeDist));
                }

                // Blend height towards roadHeight
                h = h * (1.0 - t) + roadHeight * t;
            }
            // --- END SYNC ---


            // Green Height Range: 
            // -1.0 is water line. 
            // EXPANDED: Spawn closer to water (was 0.5, now -0.2) because green starts earlier
            // 8.0 is start of rock. -> Raised to 24.0 (start of snow/rock transition)
            const isGreenHeight = (h > -0.2) && (h < 24.0);

            // Density Noise REMOVED for Uniform Distribution
            // User Request: Uniformly dense grass (no clumps)
            // let density = noise(_v3.x * 8.0, _v3.y * 8.0, _v3.z * 8.0);

            // Allow if satisfies criteria (removed density check)
            if (!isRoad && isGreenHeight) {
                // Determine Position
                const r = planetRadius + h;
                const pos = _v3.clone().multiplyScalar(r);

                offsets[grassIdx * 3 + 0] = pos.x;
                offsets[grassIdx * 3 + 1] = pos.y;
                offsets[grassIdx * 3 + 2] = pos.z;

                // Normal is direction from center
                normals[grassIdx * 3 + 0] = _v3.x;
                normals[grassIdx * 3 + 1] = _v3.y;
                normals[grassIdx * 3 + 2] = _v3.z;

                // Reverted Size Logic
                scales[grassIdx] = 0.5 + Math.random() * 0.5;
                rots[grassIdx] = Math.random() * Math.PI * 2;

                grassIdx++;
            }
        }

        // --- Bind Attributes (Outside Loop) ---
        grassMesh.geometry.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets, 3));
        grassMesh.geometry.setAttribute('instanceNormal', new THREE.InstancedBufferAttribute(normals, 3));
        grassMesh.geometry.setAttribute('scale', new THREE.InstancedBufferAttribute(scales, 1));
        grassMesh.geometry.setAttribute('rot', new THREE.InstancedBufferAttribute(rots, 1));

        // Fix: User reported invisible grass.
        // InstancedMesh bounding sphere might not be computed correctly for all instances automatically.
        // Disabling frustum culling to ensure it's always rendered.
        grassMesh.frustumCulled = false;

        scene.add(grassMesh);

        // --- 4. Car Object ---
        const carGroup = new THREE.Group();
        carGroup.position.set(0, planetRadius + 10, 0);

        // -- Chassis --
        // Reverted width to 1.2 (User request: "Too wide")
        const chassisGeo = new THREE.BoxGeometry(1.2, 0.4, 2.4);

        const chassisMat = new THREE.MeshBasicMaterial({
            color: 0xFF6600 // Orange
        });
        const chassis = new THREE.Mesh(chassisGeo, chassisMat);
        // Raised body height (0.4 -> 0.6)
        chassis.position.y = 0.6;
        carGroup.add(chassis);

        // Helper to create gradient texture
        function createGradientTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Bottom to Top Gradient
            // Map vertically: (0, 64) is bottom, (0, 0) is top
            const gradient = ctx.createLinearGradient(0, 64, 0, 0);
            gradient.addColorStop(0, '#FF6600'); // Orange at bottom
            gradient.addColorStop(1, '#CC3300'); // Deep Orange at top

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // -- Cabin --
        const cabinGeo = new THREE.BoxGeometry(1.0, 0.6, 1.4);

        // Updated material: Multi-material to fix top face
        // Order: Right, Left, Top, Bottom, Front, Back
        const gradTexture = createGradientTexture();
        const gradMat = new THREE.MeshBasicMaterial({ map: gradTexture });
        const whiteMat = new THREE.MeshBasicMaterial({ color: 0xCC3300 }); // Deep Orange for Top
        const orangeMat = new THREE.MeshBasicMaterial({ color: 0xFF6600 });

        const cabinMats = [
            gradMat,   // Right
            gradMat,   // Left
            whiteMat,  // Top (Solid White)
            orangeMat, // Bottom
            gradMat,   // Front
            gradMat    // Back
        ];

        const cabin = new THREE.Mesh(cabinGeo, cabinMats);
        // Raised to 1.0, Moved BACK to -0.5 (User request)
        cabin.position.set(0, 1.0, -0.5);
        carGroup.add(cabin);

        // -- License Plate --
        const plateGeo = new THREE.BoxGeometry(0.4, 0.15, 0.05);
        const plateMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const plate = new THREE.Mesh(plateGeo, plateMat);
        // Back of chassis (Z=-1.2), slightly offset (-1.21)
        // Chassis Y=0.6.
        plate.position.set(0, 0.6, -1.21);
        carGroup.add(plate);

        // -- Windows (Black Glass) --
        const windGeo = new THREE.BoxGeometry(0.9, 0.25, 0.8);

        const windMat = new THREE.MeshBasicMaterial({
            color: 0x111111
        });
        const windowMesh = new THREE.Mesh(windGeo, windMat);
        // Raised to 1.1, Moved BACK to match cabin (-0.55)
        windowMesh.position.set(0, 1.1, -0.55);
        carGroup.add(windowMesh);

        // -- Headlights --
        const lightGeo = new THREE.BoxGeometry(0.2, 0.1, 0.1);

        const lightMat = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF
        });
        const lightL = new THREE.Mesh(lightGeo, lightMat);
        lightL.position.set(-0.4, 0.5, 1.2);
        carGroup.add(lightL);
        const lightR = new THREE.Mesh(lightGeo, lightMat);
        // -- Headlight Beams REMOVED (User request) --

        // -- Wheels --
        const createWheel = () => {
            const g = new THREE.Group();
            const tireGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 16);
            tireGeo.rotateZ(Math.PI / 2);

            const tireMat = new THREE.MeshBasicMaterial({
                color: 0x111111
            });
            const tire = new THREE.Mesh(tireGeo, tireMat);
            g.add(tire);
            const hubGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.32, 8);
            hubGeo.rotateZ(Math.PI / 2);

            const hubMat = new THREE.MeshBasicMaterial({
                color: 0x888888
            });
            const hub = new THREE.Mesh(hubGeo, hubMat);
            g.add(hub);
            return g;
        }

            ;

        const wFL = createWheel(); wFL.position.set(-0.7, 0.35, 0.9); carGroup.add(wFL);
        const wFR = createWheel(); wFR.position.set(0.7, 0.35, 0.9); carGroup.add(wFR);
        const wBL = createWheel(); wBL.position.set(-0.7, 0.35, -0.9); carGroup.add(wBL);
        const wBR = createWheel(); wBR.position.set(0.7, 0.35, -0.9); carGroup.add(wBR);

        scene.add(carGroup);





        const carPhysics = {
            pos: new THREE.Vector3(0, planetRadius + 10, 0),
            quat: new THREE.Quaternion(),
            speed: 0,
            up: new THREE.Vector3(0, 1, 0),
            smoothedUp: new THREE.Vector3(0, 1, 0)
        }

            ;

        const keys = {
            w: false, a: false, s: false, d: false
        }

            ;

        const handleKeyDown = (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
        }

            ;

        const handleKeyUp = (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
        }

            ;
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);

        // --- Mobile Controls Logic ---
        const addTouchHandler = (id, key) => {
            const btn = document.getElementById(id);
            if (!btn) return;

            const setKey = (val) => {
                if (keys.hasOwnProperty(key)) keys[key] = val;
            };

            // Touch Events
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); setKey(true); }, { passive: false });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); setKey(false); }, { passive: false });
            // Mouse Events for testing on desktop
            btn.addEventListener('mousedown', (e) => { setKey(true); });
            btn.addEventListener('mouseup', (e) => { setKey(false); });
            btn.addEventListener('mouseleave', (e) => { setKey(false); });
        };

        addTouchHandler('btn-left', 'a');
        addTouchHandler('btn-right', 'd');
        addTouchHandler('btn-fwd', 'w');
        addTouchHandler('btn-back', 's');


        // --- MULTIPLAYER LOGIC START ---
        const ROOM_ID_VERSION = 'v1';
        const HOST_ID = `dog-eleven-planet-host-${ROOM_ID_VERSION}`;
        let myId = null;
        let isHost = false;
        let peer = null;
        let hostConnection = null;
        const clientConnections = new Set();
        const remoteCars = {}; // { id: { mesh: Object3D, targetPos: Vector3, targetRot: Quaternion } }
        const chatBubbles = []; // { element: DOM, position: Vector3, life: number }

        const statusLabel = document.getElementById('chat-status');

        // Debug Elements
        const dbgId = document.getElementById('dbg-id');
        const dbgRole = document.getElementById('dbg-role');
        const dbgPeers = document.getElementById('dbg-peers');
        const dbgIn = document.getElementById('dbg-in');
        const dbgOut = document.getElementById('dbg-out');
        const dbgErr = document.getElementById('dbg-err');
        let pkgIn = 0, pkgOut = 0;

        function initMultiplayer() {
            // Random Delay to prevent race conditions (0-2s)
            setTimeout(() => {
                const hostCandidate = new Peer(HOST_ID, { debug: 1 });

                hostCandidate.on('open', (id) => {
                    // Critical Check: Did PeerJS give us the exact ID we asked for?
                    if (id === HOST_ID) {
                        isHost = true;
                        myId = id;
                        peer = hostCandidate;
                        dbgRole.textContent = "HOST";
                        dbgId.textContent = id;
                        setupHost();
                    } else {
                        // PeerJS auto-assigned a different ID (Collision) -> Downgrade to Client
                        console.log("Wanted Host ID but got:", id, ". Downgrading to Client.");
                        hostCandidate.destroy();
                        initClient();
                    }
                });

                hostCandidate.on('error', (err) => {
                    if (err.type === 'unavailable-id') {
                        // ID Taken -> We are Client
                        initClient();
                    } else {
                        dbgErr.textContent = err.type;
                    }
                });
            }, Math.random() * 2000);
        }

        function initClient() {
            myId = 'User-' + Math.floor(Math.random() * 10000);
            peer = new Peer(myId, { debug: 1 });
            peer.on('open', (id) => {
                dbgId.textContent = id;
                dbgRole.textContent = "CLIENT";
                connectToHost();
            });
        }

        function setupHost() {
            statusLabel.textContent = "Host (Room Open)";
            peer.on('connection', (conn) => {
                clientConnections.add(conn);
                dbgPeers.textContent = clientConnections.size;

                conn.on('data', (data) => handleData(data, conn.peer));
                conn.on('close', () => {
                    clientConnections.delete(conn);
                    dbgPeers.textContent = clientConnections.size;
                    removeRemoteCar(conn.peer);
                });
            });
        }

        function connectToHost() {
            statusLabel.textContent = "Connecting...";
            hostConnection = peer.connect(HOST_ID);
            hostConnection.on('open', () => {
                statusLabel.textContent = "Connected to Room";
                dbgPeers.textContent = "1 (Host)";
            });
            hostConnection.on('data', (data) => handleData(data, 'Host'));
            hostConnection.on('close', () => {
                statusLabel.textContent = "Disconnected";
                dbgPeers.textContent = "0";
            });
        }

        function handleData(data, senderId) {
            pkgIn++;
            dbgIn.textContent = pkgIn;

            // Data types: 'move', 'chat'
            if (data.type === 'move') {
                updateRemoteCar(data.id, data.pos, data.quat);
                if (isHost) broadcast(data, senderId);
            } else if (data.type === 'chat') {
                createChatBubble(data.text, data.id);
                if (isHost) broadcast(data, senderId);
            }
        }

        function broadcast(data, excludeId) {
            pkgOut++;
            dbgOut.textContent = pkgOut;
            for (let client of clientConnections) {
                if (client.peer !== excludeId && client.open) {
                    client.send(data);
                }
            }
        }

        function updateRemoteCar(id, pos, quat) {
            if (id === myId) return; // Ignore self

            if (!remoteCars[id]) {
                // Create Ghost Car
                const ghost = carGroup.clone();

                // Make it look different (Ghostly)
                ghost.traverse((child) => {
                    if (child.isMesh) {
                        if (Array.isArray(child.material)) {
                            // Handle Multi-Material (Cabin)
                            child.material = child.material.map(m => {
                                const mc = m.clone();
                                mc.transparent = true;
                                mc.opacity = 0.5;
                                if (mc.color) mc.color.setHex(0x00FFFF); // Cyan tint
                                return mc;
                            });
                        } else {
                            // Handle Single Material
                            child.material = child.material.clone();
                            child.material.transparent = true;
                            child.material.opacity = 0.5;
                            if (child.material.color) child.material.color.setHex(0x00FFFF);
                        }
                    }
                });

                scene.add(ghost);
                remoteCars[id] = { mesh: ghost, targetPos: new THREE.Vector3(), targetQuat: new THREE.Quaternion() };
            }

            const car = remoteCars[id];
            if (pos && quat) {
                car.targetPos.set(pos.x, pos.y, pos.z);
                car.targetQuat.set(quat.x, quat.y, quat.z, quat.w);
            }
        }

        function removeRemoteCar(id) {
            if (remoteCars[id]) {
                scene.remove(remoteCars[id].mesh);
                delete remoteCars[id];
            }
        }

        function createChatBubble(text, senderId) {
            const div = document.createElement('div');
            div.className = 'chat-bubble';
            div.textContent = text;
            document.body.appendChild(div);

            // Find target object to attach to
            let targetObj = carGroup; // Default to self logic (if from self loopback)
            if (senderId !== myId && remoteCars[senderId]) {
                targetObj = remoteCars[senderId].mesh;
            } else if (senderId === myId) {
                targetObj = carGroup;
            }

            chatBubbles.push({
                element: div,
                target: targetObj,
                life: 300 // Frames (~5s)
            });
        }

        // Chat Input Logic
        const chatInput = document.getElementById('chat-input');
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const text = chatInput.value.trim();
                if (!text) return;

                const data = { type: 'chat', text: text, id: myId };

                // Show local
                createChatBubble(text, myId);

                // Send
                if (isHost) broadcast(data, myId);
                else if (hostConnection) hostConnection.send(data);

                chatInput.value = '';
                chatInput.blur(); // Unfocus to return control to driving
            }
        });

        // Prevent driving while typing
        chatInput.addEventListener('focus', () => {
            // Clear keys so car doesn't get stuck moving
            keys.w = false; keys.a = false; keys.s = false; keys.d = false;
        });

        // Start Multiplayer
        initMultiplayer();
        // --- MULTIPLAYER LOGIC END ---

        const raycaster = new THREE.Raycaster();
        const cameraLookAtCurrent = new THREE.Vector3(0, 0, 0);
        const clock = new THREE.Clock();

        const animate = () => {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            // --- Logic ---
            // Physics Tuning (2025-12-11)
            // MaxSpeed increased 50% (24 -> 36)
            // Acc increased 30% (8.5 -> 11.0)
            const maxSpeed = 36;
            const acc = 11.0;
            const brakePower = 30.0; // Stronger than acceleration for snappy braking
            const friction = 8;

            // Forward / Backward / Brake Logic
            if (keys.w) {
                if (carPhysics.speed < -0.1) {
                    // Moving backward, apply BRAKE
                    carPhysics.speed += brakePower * dt;
                } else {
                    // Moving forward or stopped, Accelerate
                    carPhysics.speed += acc * dt;
                }
            } else if (keys.s) {
                if (carPhysics.speed > 0.1) {
                    // Moving forward, apply BRAKE
                    carPhysics.speed -= brakePower * dt;
                } else {
                    // Moving backward or stopped, Accelerate (Reverse)
                    carPhysics.speed -= acc * dt;
                }
            } else {
                // Friction (Idle slowdown)
                if (carPhysics.speed > 0.1) carPhysics.speed -= friction * dt;
                else if (carPhysics.speed < -0.1) carPhysics.speed += friction * dt;
                else carPhysics.speed = 0;
            }

            carPhysics.speed = Math.max(Math.min(carPhysics.speed, maxSpeed), -maxSpeed);

            // Velocity
            const velocity = new THREE.Vector3(0, 0, carPhysics.speed * dt);
            velocity.applyQuaternion(carGroup.quaternion);

            // Resistance / Drag when in water
            const distCenter = carPhysics.pos.length();
            const waterLevel = planetRadius + seaLevelRef;

            if (distCenter < waterLevel) {
                // Underwater Drag (Preserved setting: 1.4)
                const dragFactor = 1.4;
                carPhysics.speed -= carPhysics.speed * dragFactor * dt;
            }

            carPhysics.pos.add(velocity);

            const skyPos = carPhysics.pos.clone().normalize().multiplyScalar(planetRadius + 50);
            const rayDir = new THREE.Vector3(0, 0, 0).sub(skyPos).normalize();

            raycaster.set(skyPos, rayDir);
            const intersects = raycaster.intersectObject(planet);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const targetPos = hit.point.clone();
                carPhysics.pos.copy(targetPos);

                const sphereNormal = targetPos.clone().normalize();
                const floorNormal = hit.face ? hit.face.normal.clone().transformDirection(planet.matrixWorld) : sphereNormal;
                // Raw target up based on terrain geometry (faceted)
                // PREVIOUS: 0.5 floor, 0.5 sphere (too stable/flat)
                // NEW: 0.85 floor, 0.15 sphere (follows terrain, slight sphere bias for safety)
                const rawTargetUp = new THREE.Vector3().addVectors(floorNormal.multiplyScalar(0.85), sphereNormal.multiplyScalar(0.15)).normalize();

                // Smooth the Up vector over time to prevent jitter from face boundaries
                // Increased lerp speed (5.0 -> 8.0) to react faster to steep slopes
                carPhysics.smoothedUp.lerp(rawTargetUp, 8.0 * dt);
                carPhysics.smoothedUp.normalize();

                const targetUp = carPhysics.smoothedUp;

                // Steering Logic:
                // 1. Only turn if moving (speed > 0.1)
                // 2. Invert turning when reversing
                if (Math.abs(carPhysics.speed) > 0.1) {
                    const dir = carPhysics.speed > 0 ? 1 : -1;
                    const turnSpeed = 1.2 * dt * dir;

                    if (keys.a) {
                        const rotQ = new THREE.Quaternion().setFromAxisAngle(targetUp, turnSpeed);
                        carGroup.quaternion.premultiply(rotQ);
                    }

                    if (keys.d) {
                        const rotQ = new THREE.Quaternion().setFromAxisAngle(targetUp, -turnSpeed);
                        carGroup.quaternion.premultiply(rotQ);
                    }
                }

                // Visual Steering (Front Wheels)
                // Smoothly rotate wheels towards target angle (+0.5 for Left, -0.5 for Right)
                let targetSteer = 0;
                if (keys.a) targetSteer = 0.5;
                else if (keys.d) targetSteer = -0.5;

                // Track current visual steering in a property attached to the carGroup (or just use a global/closure var)
                if (!carGroup.userData.currentSteer) carGroup.userData.currentSteer = 0;

                // Lerp towards target
                const steerLerpSpeed = 5.0;
                carGroup.userData.currentSteer += (targetSteer - carGroup.userData.currentSteer) * steerLerpSpeed * dt;

                // Apply to Front Left (wFL) and Front Right (wFR)
                // Note: Wheels are rotated Z=90 originally. We need to apply Y rotation locally.
                // Since they are in a group, we can just set rotation.y if the group is aligned correctly.
                // The wheels were created with: cylinder rotated Z, added to group 'g'.
                // So rotating 'g.rotation.y' should steer them.
                wFL.rotation.y = carGroup.userData.currentSteer;
                wFR.rotation.y = carGroup.userData.currentSteer;

                const currentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(carGroup.quaternion);
                const qAlign = new THREE.Quaternion().setFromUnitVectors(currentUp, targetUp);

                // Slerp the alignment for extra smoothness instead of hard premultiply
                const targetQ = carGroup.quaternion.clone().premultiply(qAlign);
                carGroup.quaternion.slerp(targetQ, 10.0 * dt);

                const lerpFactor = 0.2;

                if (carGroup.position.distanceTo(targetPos) > 10) {
                    carGroup.position.copy(targetPos);
                }

                else {
                    carGroup.position.lerp(targetPos, lerpFactor);
                }
            }














            // Update Grass Uniforms
            grassMat.uniforms.carPos.value.copy(carGroup.position);
            grassMat.uniforms.time.value = clock.getElapsedTime();

            // Update Planet Uniforms (Foam Animation)
            if (planet.material.uniforms && planet.material.uniforms.time) {
                planet.material.uniforms.time.value = clock.getElapsedTime();
            }

            // Updated Camera Offset: Closer (User Request)
            // Previous: (0, 28, -13)
            // New: (0, 22, -10) -> Closer and lower
            const idealOffset = new THREE.Vector3(0, 22, -10);
            idealOffset.applyQuaternion(carGroup.quaternion);
            idealOffset.add(carGroup.position);

            const lookTargetOffset = new THREE.Vector3(0, 2, 8);
            lookTargetOffset.applyQuaternion(carGroup.quaternion);
            const idealLookAt = carGroup.position.clone().add(lookTargetOffset);

            // Heavy buffer: 0.02 very smooth/slow
            const camPosLerp = 0.02;

            // Fix: Camera Init Bug
            if (camera.position.distanceTo(idealOffset) > 100) {
                camera.position.copy(idealOffset);
                cameraLookAtCurrent.copy(idealLookAt);
            }

            else {
                camera.position.lerp(idealOffset, camPosLerp);
                cameraLookAtCurrent.lerp(idealLookAt, 0.02);
            }

            // Constrain camera to be level with ground
            const targetCamUp = carGroup.position.clone().normalize();
            camera.up.lerp(targetCamUp, 1.0 * dt);
            camera.lookAt(cameraLookAtCurrent);

            // --- Camera Ground Collision ---
            // Calculate terrain height below camera to prevent clipping
            const camDir = camera.position.clone().normalize();
            let cn = noise(camDir.x * 1.5, camDir.y * 1.5, camDir.z * 1.5);
            cn += 0.5 * noise(camDir.x * 5, camDir.y * 5, camDir.z * 5);
            const cheight = cn * 10.0; // Must match heightScale
            const groundRad = planetRadius + cheight;
            const minCamDist = groundRad + 2.0; // Keep at least 2.0 units above ground

            if (camera.position.length() < minCamDist) {
                camera.position.normalize().multiplyScalar(minCamDist);
            }

            // Update Water
            // (Shader uniforms removed, standard material static)
            // waterMat.uniforms.time.value = clock.getElapsedTime();
            // waterMat.uniforms.carPos.value.copy(carPhysics.pos);

            // Underwater Fog Effect
            const camDist = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
            const waterRadius = planetRadius + seaLevelRef;

            if (camDist < waterRadius) {
                // Underwater
                scene.fog.color.setHex(0x006677); // Dark Cyan
                scene.fog.near = 1;
                scene.fog.far = 30; // Dense fog
            }

            else {
                // Above water - SPACE
                scene.fog.color.setHex(0x000000); // Black Fog for Space
                scene.fog.near = 20;
                scene.fog.far = 150;
            }

            // Animate Stars
            if (stars) stars.rotation.y += 0.0003; // Slow rotation

            // --- MULTIPLAYER UPDATE ---
            // 1. Broadcast My Position (Throttled)
            if (peer && myId) {
                // Broadcast every 5 frames is enough (~12fps update)
                if (clock.getElapsedTime() % 0.1 < 0.02) {
                    const data = {
                        type: 'move',
                        id: myId,
                        pos: { x: carGroup.position.x, y: carGroup.position.y, z: carGroup.position.z },
                        quat: { x: carGroup.quaternion.x, y: carGroup.quaternion.y, z: carGroup.quaternion.z, w: carGroup.quaternion.w }
                    };
                    if (isHost) broadcast(data, myId);
                    else if (hostConnection && hostConnection.open) {
                        pkgOut++;
                        dbgOut.textContent = pkgOut;
                        hostConnection.send(data);
                    }
                }
            }

            // 2. Update Remote Cars (Lerp)
            for (let id in remoteCars) {
                const rCar = remoteCars[id];
                rCar.mesh.position.lerp(rCar.targetPos, 0.2); // Smooth lerp
                rCar.mesh.quaternion.slerp(rCar.targetQuat, 0.2);
            }

            // 3. Update Chat Bubbles (Project to 2D)
            const tempV = new THREE.Vector3();
            for (let i = chatBubbles.length - 1; i >= 0; i--) {
                const b = chatBubbles[i];
                b.life--;
                if (b.life <= 0) {
                    b.element.parentNode.removeChild(b.element);
                    chatBubbles.splice(i, 1);
                    continue;
                }

                // Project 3D position to 2D screen
                b.target.getWorldPosition(tempV);
                tempV.y += 3.0; // Above car
                tempV.project(camera);

                const x = (tempV.x * .5 + .5) * window.innerWidth;
                const y = (-(tempV.y * .5) + .5) * window.innerHeight;

                // Hide if behind camera
                if (tempV.z > 1) {
                    b.element.style.display = 'none';
                } else {
                    b.element.style.display = 'block';
                    b.element.style.left = x + 'px';
                    b.element.style.top = y + 'px';
                    // Fade out
                    b.element.style.opacity = Math.min(1, b.life / 50);
                }
            }

            renderer.render(scene, camera);
            // Use Composer for Post-Processing (DoF) - DISABLED
            // composer.render(0.1);
        }

            ;

        // --- Post-Processing Setup (DISABLED) ---
        /*
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bokehPass = new THREE.BokehPass(scene, camera, {
            focus: 35.0,      
            aperture: 0.0001, 
            maxblur: 0.01,    
            width: window.innerWidth,
            height: window.innerHeight
        });
        composer.addPass(bokehPass);
        */


        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>