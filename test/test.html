<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TofuTodo</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TofuTodo">
    <link rel="apple-touch-icon" href="https://github.com/dogEleven.png">
    <link rel="icon" type="image/png" href="https://github.com/dogEleven.png">

    <!-- Use jsDelivr for better stability -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.0/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        :root { 
            --primary: #4a90e2; 
            --bg: #f5f5f7; 
            --card-bg: #ffffff; 
            --text: #1c1c1e; 
            --subtext: #8e8e93; 
            --input-bg: #f9f9f9;
            --border: rgba(0,0,0,0.05);
        }
        [data-theme='dark'] {
            --bg: #1c1c1e;
            --card-bg: #2c2c2e;
            --text: #f2f2f7;
            --subtext: #8e8e93;
            --input-bg: #3a3a3c;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif; background: var(--bg); padding: 12px; max-width: 600px; margin: 0 auto; color: var(--text); -webkit-font-smoothing: antialiased; transition: background 0.3s, color 0.3s; }
        .login-box { background: var(--card-bg); padding: 30px; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); text-align: center; margin-top: 50px; }
        input, textarea { width: 100%; box-sizing: border-box; padding: 12px 16px; border: 1px solid #d1d1d6; border-radius: 10px; font-size: 16px; background: var(--input-bg); color: var(--text); transition: all 0.2s; font-family: inherit; }
        [data-theme='dark'] input, [data-theme='dark'] textarea { border-color: #3a3a3c; }
        input:focus, textarea:focus { border-color: var(--primary); outline: none; background: var(--card-bg); }
        button { padding: 12px 24px; background: var(--primary); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: 600; transition: opacity 0.2s; width: 100%; }
        button:active { opacity: 0.8; }
        
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; margin-top: 4px; }
        .header-left { display: flex; align-items: center; gap: 10px; }
        h1 { font-size: 18px; font-weight: 700; margin: 0; }
        .theme-toggle { background: none; border: none; font-size: 20px; cursor: pointer; padding: 4px; width: auto; }
        .logout-btn { background: none; color: var(--primary); font-weight: 400; padding: 4px 0; width: auto; font-size: 13px; border: none; cursor: pointer; }

        .tabs { display: flex; gap: 4px; background: rgba(0,0,0,0.05); padding: 4px; border-radius: 10px; margin-bottom: 12px; }
        [data-theme='dark'] .tabs { background: rgba(255,255,255,0.05); }
        .tab { flex: 1; text-align: center; padding: 6px; font-size: 13px; border-radius: 6px; cursor: pointer; color: var(--subtext); transition: all 0.2s; }
        .tab.active { background: var(--card-bg); color: var(--text); font-weight: 600; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }

        .new-task { background: var(--card-bg); padding: 8px 10px; border-radius: 10px; margin-bottom: 12px; box-shadow: 0 1px 4px rgba(0,0,0,0.04); display: flex; flex-direction: column; gap: 8px; }
        .new-task-row { display: flex; gap: 8px; }
        .new-task input { margin: 0; border: none; background: transparent; padding: 0; font-size: 14px; }
        .new-task select { padding: 6px; border-radius: 6px; border: 1px solid #e5e5ea; background: var(--bg); font-size: 13px; color: var(--text); }
        [data-theme='dark'] .new-task select { border-color: #3a3a3c; }
        .add-btn { width: auto; padding: 6px 12px; font-size: 13px; border-radius: 6px; }

        .groups-container { display: flex; flex-direction: column; gap: 8px; }
        .group-title { font-size: 13px; font-weight: 700; margin: 0 0 4px 4px; display: flex; align-items: center; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.8; color: var(--subtext); cursor: pointer; }
        .group-title .arrow { margin-right: 6px; font-size: 10px; transition: transform 0.2s; }
        .group-title .arrow.collapsed { transform: rotate(-90deg); }
        .group-title span { background: rgba(0,0,0,0.05); padding: 1px 6px; border-radius: 8px; font-size: 10px; margin-left: 6px; color: var(--text); font-weight: 600; }
        [data-theme='dark'] .group-title span { background: rgba(255,255,255,0.1); }
        
        .todo-list { display: flex; flex-direction: column; gap: 0; background: var(--card-bg); border-radius: 10px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.04); }
        .todo-item { background: transparent; padding: 10px 12px; border-radius: 0; display: flex; align-items: flex-start; gap: 10px; margin-bottom: 0; border-bottom: 1px solid var(--border); cursor: pointer; }
        .todo-item:last-child { border-bottom: none; }
        .todo-item:active { background: var(--bg); }
        .todo-item.done { opacity: 0.5; }
        .todo-item.done .title { text-decoration: line-through; }
        
        /* Custom Checkbox */
        .checkbox { width: 16px; height: 16px; border-radius: 50%; border: 2px solid #c7c7cc; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; margin-top: 1px; }
        .todo-item.done .checkbox { background: var(--primary); border-color: var(--primary); }
        .checkbox::after { content: '‚úì'; color: white; font-size: 10px; display: none; }
        .todo-item.done .checkbox::after { display: block; }

        .content { flex-grow: 1; display: flex; flex-direction: row; align-items: flex-start; justify-content: space-between; gap: 8px; flex-wrap: nowrap; }
        .title { font-size: 13px; line-height: 1.3; word-break: break-word; flex-grow: 1; margin-right: 4px; color: var(--text); }
        .title-container { flex-grow: 1; display: flex; align-items: flex-start; justify-content: space-between; gap: 8px; }
        .issue-meta { font-size: 9px; color: var(--subtext); white-space: nowrap; margin-top: 2px; flex-shrink: 0; }

        /* Full Screen Editor Modal */
        .editor-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg); z-index: 1000; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s ease; }
        .editor-modal.active { transform: translateY(0); }
        .editor-header { padding: 15px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: rgba(var(--card-bg), 0.9); }
        .editor-body { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        .editor-title { font-size: 18px; font-weight: bold; border: none; background: transparent; outline: none; }
        .editor-textarea { flex: 1; border: none; background: transparent; resize: none; font-size: 16px; line-height: 1.6; outline: none; font-family: inherit; }
        .md-preview { display: none; padding: 10px 0; font-size: 16px; line-height: 1.6; }
        .md-preview.active { display: block; }
        .md-preview h1 { border-bottom: 1px solid var(--border); padding-bottom: 5px; }
        .md-preview img { max-width: 100%; border-radius: 8px; }

        /* New Group Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1100; display: flex; justify-content: center; align-items: center; }
        .modal { background: var(--card-bg); padding: 20px; border-radius: 12px; width: 80%; max-width: 300px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .modal h3 { margin-top: 0; font-size: 16px; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }
        .btn-cancel { background: transparent; color: var(--subtext); border: 1px solid var(--border); width: auto; padding: 8px 16px; }
        .btn-create { width: auto; padding: 8px 16px; }
        /* Menu Popover */
        .menu-popover {
            position: absolute; right: 40px; background: var(--card-bg); 
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
            z-index: 100; overflow: hidden; display: none; min-width: 100px;
        }
        .menu-popover.active { display: block; }
        .menu-item { padding: 10px 15px; font-size: 14px; cursor: pointer; color: #ff3b30; display: flex; align-items: center; gap: 8px; }
        .menu-item:active { background: var(--bg); }
    </style>
</head>
<body>
    <div id="app" @click="closeAllMenus">
        <!-- Login -->
        <div v-if="!token" class="login-box">
            <h1>üîê TofuTodo</h1>
            <p style="color:var(--subtext); margin-bottom: 20px;">GitHub Personal Access Token</p>
            <input v-model="inputToken" type="password" placeholder="ghp_..." style="text-align: center;">
            <button @click="saveToken" style="margin-top: 10px;">Connect</button>
        </div>

        <!-- Main -->
        <div v-else>
            <div class="header">
                <div class="header-left">
                    <h1>üìã ÂæÖÂäûÊ∏ÖÂçï</h1>
                    <button @click="toggleTheme" class="theme-toggle">{{ isDark ? 'üåô' : '‚òÄÔ∏è' }}</button>
                </div>
                <div style="display:flex; gap:10px;">
                    <button @click="showGroupModal = true" class="logout-btn" style="color:var(--text); font-weight:600;">
                        {{ currentTab === 'idea' ? '+ üìÅ' : '+ ÁªÑ' }}
                    </button>
                    <button @click="logout" class="logout-btn">Logout</button>
                </div>
            </div>

            <div class="tabs">
                <div class="tab" :class="{ active: currentTab === 'todo' }" @click="currentTab = 'todo'">üìã Ê∏ÖÂçï</div>
                <div class="tab" :class="{ active: currentTab === 'idea' }" @click="currentTab = 'idea'">üìù Â§áÂøòÂΩï</div>
            </div>

            <div class="new-task">
                <div class="new-task-row">
                    <input v-model="newTask" :placeholder="currentTab === 'todo' ? 'Add task...' : 'New memo title...'" @keyup.enter="addTask" style="flex-grow: 1;">
                </div>
                <div class="new-task-row" style="justify-content: space-between; align-items: center;">
                    <select v-model="newLabel">
                        <option v-for="label in availableLabels" :value="label" :key="label">{{ label }}</option>
                    </select>
                    <button @click="addTask" class="add-btn">Add</button>
                </div>
            </div>

            <div v-if="loading" style="text-align: center; color: var(--subtext); padding: 20px;">Loading...</div>

            <!-- Memo View (File Structure) -->
            <div v-if="currentTab === 'idea'" class="groups-container">
                <div v-for="groupName in sortedGroupNames" :key="groupName" class="group-section">
                    <div class="group-title" @click="toggleGroup(groupName)" :class="'text-' + groupName">
                        <span class="arrow" :class="{ collapsed: collapsedGroups[groupName] }">‚ñº</span> üìÇ {{ groupName }} 
                        <span style="font-weight:400; color:var(--subtext); font-size:12px; margin-left:6px;">{{ (groupedIssues[groupName] || []).length }}</span>
                        <span v-if="isCustomGroup(groupName)" @click.stop="deleteGroup(groupName)" style="float:right; font-size:12px; margin-left:10px;">üóëÔ∏è</span>
                    </div>
                    <div class="todo-list" v-show="!collapsedGroups[groupName]">
                        <div v-for="issue in (groupedIssues[groupName] || [])" :key="issue.id" class="todo-item" @click="openEditor(issue)">
                            <div class="content" style="align-items: center;">
                                <span style="font-size:18px; margin-right:8px;">üìÑ</span>
                                <div class="title-container" style="flex-direction: column; gap:0;">
                                    <div class="title" style="font-weight:600; font-size:14px;">{{ issue.title }}</div>
                                    <div class="issue-meta" style="font-size:11px; margin-top:0;">{{ formatDate(issue.updated_at) }}</div>
                                </div>
                            </div>
                            <!-- Kebab Menu -->
                            <div style="position:relative;">
                                <button @click.stop="toggleMenu(issue.id)" style="background:none; border:none; color:var(--subtext); font-size:18px; padding:0 8px;">‚ãÆ</button>
                                <div class="menu-popover" :class="{ active: activeMenuId === issue.id }">
                                    <div class="menu-item" @click.stop="deleteIssue(issue)">üóëÔ∏è Âà†Èô§</div>
                                </div>
                            </div>
                        </div>
                        <div v-if="(groupedIssues[groupName] || []).length === 0" style="padding:10px; font-size:12px; color:var(--subtext); text-align:center;">(Empty)</div>
                    </div>
                </div>
            </div>

            <!-- Todo View (Checkboxes) -->
            <div v-else class="groups-container">
                <div v-for="groupName in sortedGroupNames" :key="groupName" class="group-section">
                    <div class="group-title" @click="toggleGroup(groupName)" :class="'text-' + groupName">
                        <span class="arrow" :class="{ collapsed: collapsedGroups[groupName] }">‚ñº</span> {{ groupName }}
                        <span style="font-weight:400; color:var(--subtext); font-size:12px; margin-left:6px;">{{ (groupedIssues[groupName] || []).length }}</span>
                        <span v-if="isCustomGroup(groupName)" @click.stop="deleteGroup(groupName)" style="float:right; font-size:12px; margin-left:10px;">üóëÔ∏è</span>
                    </div>
                    <div class="todo-list" v-show="!collapsedGroups[groupName]">
                        <div v-for="issue in (groupedIssues[groupName] || [])" :key="issue.id" class="todo-item" :class="{done: issue.state === 'closed'}">
                            <div class="checkbox" @click.stop="toggleIssue(issue)"></div>
                            <div class="content" @click="openEditor(issue)">
                                <div class="title-container">
                                    <div class="title">{{ issue.title }}</div>
                                    <div class="issue-meta">{{ formatDate(issue.created_at) }}</div>
                                </div>
                            </div>
                            <button v-if="issue.state === 'closed'" @click.stop="deleteIssue(issue)" class="delete-btn" style="background:none; border:none; color:var(--subtext); padding:5px; margin-left:5px;">‚úï</button>
                        </div>
                        <div v-if="(groupedIssues[groupName] || []).length === 0" style="padding:10px; font-size:12px; color:var(--subtext); text-align:center;">(Empty)</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Editor Modal -->
        <div class="editor-modal" :class="{ active: isEditorOpen }">
            <div class="editor-header">
                <button class="logout-btn" @click="closeEditor">ÂèñÊ∂à</button>
                <div style="font-weight:600;">ÁºñËæë</div>
                <button class="logout-btn" style="font-weight:600;" @click="saveEditor">‰øùÂ≠ò</button>
            </div>
            <div class="editor-body">
                <input v-model="editingTitle" class="editor-title" placeholder="Ê†áÈ¢ò">
                <div style="display:flex; gap:10px; border-bottom: 1px solid var(--border); padding-bottom:5px;">
                    <button class="logout-btn" @click="showPreview = !showPreview">{{ showPreview ? '‚úèÔ∏è ÁºñËæë' : 'üëÅÔ∏è È¢ÑËßà' }}</button>
                </div>
                <textarea v-show="!showPreview" v-model="editingBody" class="editor-textarea" placeholder="ÊîØÊåÅ Markdown..."></textarea>
                <div v-show="showPreview" class="md-preview active" v-html="renderedMarkdown"></div>
            </div>
        </div>

        <!-- New Group Modal -->
        <div v-if="showGroupModal" class="modal-overlay" @click.self="showGroupModal = false">
            <div class="modal">
                <h3>Êñ∞Âª∫ÂàÜÁªÑ (Label)</h3>
                <input v-model="newGroupName" placeholder="ËæìÂÖ•ÂàÜÁªÑÂêçÁß∞ (Ëã±Êñá)" @keyup.enter="createGroup">
                <div class="modal-actions">
                    <button class="btn-cancel" @click="showGroupModal = false">ÂèñÊ∂à</button>
                    <button class="btn-create" @click="createGroup">ÂàõÂª∫</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, computed, nextTick, watch } = Vue;
        const REPO = "dogEleven/tofutodo";

        createApp({
            setup() {
                // State
                const token = ref(localStorage.getItem('gh_token') || '');
                const inputToken = ref('');
                const issues = ref([]);
                const allLabels = ref([]); 
                const loading = ref(false);
                const newTask = ref('');
                const newLabel = ref('Work');
                const isDark = ref(localStorage.getItem('theme') === 'dark');
                const currentTab = ref(localStorage.getItem('currentTab') || 'todo');
                const collapsedGroups = ref(JSON.parse(localStorage.getItem('collapsedGroups')) || {});
                const showGroupModal = ref(false);
                const newGroupName = ref('');
                const activeMenuId = ref(null);

                // Editor State
                const isEditorOpen = ref(false);
                const editingIssue = ref(null);
                const editingTitle = ref('');
                const editingBody = ref('');
                const showPreview = ref(false);

                // Config
                const defaultTodoLabels = ['Work', 'Life', 'HellDrop', 'Zhutousan'];
                const defaultIdeaLabels = ['Idea', 'Project', 'Reference'];
                const ignoredLabels = ['bug', 'documentation', 'duplicate', 'enhancement', 'good first issue', 'help wanted', 'invalid', 'question', 'wontfix', 'trash'];

                // Axios
                const api = axios.create({
                    baseURL: `https://api.github.com/repos/${REPO}`,
                    headers: { 'Accept': 'application/vnd.github.v3+json' }
                });

                // Computed
                const availableLabels = computed(() => {
                    const defaults = currentTab.value === 'todo' ? defaultTodoLabels : defaultIdeaLabels;
                    const opposite = currentTab.value === 'todo' ? defaultIdeaLabels : defaultTodoLabels;
                    
                    const custom = allLabels.value
                        .map(l => l.name)
                        .filter(n => !defaults.includes(n) && !opposite.includes(n) && n !== 'Other' && !ignoredLabels.includes(n.toLowerCase()));
                    
                    return [...defaults, ...custom];
                });

                const sortedGroupNames = computed(() => {
                    const labels = availableLabels.value;
                    const hasOther = groupedIssues.value['Other'] && groupedIssues.value['Other'].length > 0;
                    return hasOther ? [...labels, 'Other'] : labels;
                });

                const groupedIssues = computed(() => {
                    const groups = {};
                    availableLabels.value.forEach(l => groups[l] = []);
                    
                    // Separate bucket for truly uncategorized items (no known labels at all)
                    groups['Other'] = [];

                    // Define all known system labels to exclude them from 'Other' if they don't match current tab
                    const allSystemLabels = [...defaultTodoLabels, ...defaultIdeaLabels];

                    issues.value.forEach(issue => {
                        // Skip Trash items entirely
                        if (issue.labels.some(l => l.name.toLowerCase() === 'trash')) return;

                        let placed = false;
                        let hasSystemLabel = false;

                        if (issue.labels && issue.labels.length > 0) {
                            for (const label of issue.labels) {
                                // Check if this issue belongs to ANY known system group
                                if (allSystemLabels.includes(label.name)) {
                                    hasSystemLabel = true;
                                }

                                // Place in current tab's groups if matched
                                if (groups[label.name]) {
                                    groups[label.name].push(issue);
                                    placed = true;
                                    break;
                                }
                            }
                        }

                        // Only add to 'Other' if it wasn't placed AND it doesn't belong to the *other* tab's system labels
                        if (!placed && !hasSystemLabel && !issue.labels.some(l => ignoredLabels.includes(l.name.toLowerCase()))) {
                            groups['Other'].push(issue);
                        }
                    });
                    return groups;
                });

                const renderedMarkdown = computed(() => {
                    return editingBody.value ? marked.parse(editingBody.value) : '';
                });

                // Watchers
                watch(currentTab, (val) => {
                    localStorage.setItem('currentTab', val);
                    // Default labels for each tab
                    if (val === 'todo') {
                        newLabel.value = 'Work';
                    } else {
                        newLabel.value = 'Idea';
                    }
                }, { immediate: true });
                watch(collapsedGroups, (val) => localStorage.setItem('collapsedGroups', JSON.stringify(val)), { deep: true });

                // Methods
                const saveToken = () => {
                    if (!inputToken.value.startsWith('ghp_') && !inputToken.value.startsWith('github_pat_')) {
                        alert('Invalid Token format'); return;
                    }
                    localStorage.setItem('gh_token', inputToken.value);
                    token.value = inputToken.value;
                    initData();
                };

                const logout = () => {
                    localStorage.removeItem('gh_token');
                    token.value = '';
                    issues.value = [];
                };

                const initData = () => { fetchIssues(); fetchLabels(); };

                const fetchIssues = async () => {
                    if (!token.value) return;
                    loading.value = true;
                    try {
                        const res = await api.get('/issues?state=all&sort=updated&direction=desc&per_page=100', {
                            headers: { 'Authorization': `token ${token.value}` }
                        });
                        issues.value = res.data;
                    } catch (e) {
                        alert('Error loading issues: ' + (e.response ? e.response.status : e.message));
                        if (e.response && e.response.status === 401) logout();
                    } finally { loading.value = false; }
                };

                const fetchLabels = async () => {
                    if (!token.value) return;
                    try {
                        const res = await api.get('/labels', { headers: { 'Authorization': `token ${token.value}` } });
                        allLabels.value = res.data;
                    } catch (e) { console.error("Error labels"); }
                };

                const addTask = async () => {
                    if (!newTask.value) return;
                    try {
                        const res = await api.post('/issues', {
                            title: newTask.value,
                            labels: [newLabel.value]
                        }, { headers: { 'Authorization': `token ${token.value}` } });
                        issues.value.unshift(res.data);
                        newTask.value = '';
                    } catch (e) { alert('Failed to create task'); }
                };

                const toggleIssue = async (issue) => {
                    const newState = issue.state === 'open' ? 'closed' : 'open';
                    issue.state = newState;
                    try {
                        await api.patch(`/issues/${issue.number}`, { state: newState }, {
                            headers: { 'Authorization': `token ${token.value}` }
                        });
                        // Do not filter out locally
                    } catch (e) {
                        alert('Update failed'); issue.state = issue.state === 'open' ? 'closed' : 'open';
                    }
                };

                const createGroup = async () => {
                    const name = newGroupName.value.trim();
                    if (!name) return;
                    try {
                        await api.post('/labels', {
                            name: name,
                            color: Math.floor(Math.random()*16777215).toString(16)
                        }, { headers: { 'Authorization': `token ${token.value}` } });
                        await fetchLabels();
                        showGroupModal.value = false;
                        newGroupName.value = '';
                        newLabel.value = name;
                    } catch (e) { alert('Create failed: ' + e.message); }
                };

                const deleteGroup = async (name) => {
                    if (!confirm(`Delete group "${name}"?`)) return;
                    try {
                        await api.delete(`/labels/${name}`, { headers: { 'Authorization': `token ${token.value}` } });
                        await fetchLabels();
                    } catch (e) { alert('Delete failed'); }
                };
                
                const deleteIssue = async (issue) => {
                    // Optimistic remove
                    issues.value = issues.value.filter(i => i.id !== issue.id);
                    try {
                        // Ensure 'Trash' label exists first (just in case)
                        // Actually, just try to set the labels. GitHub usually requires the label to exist.
                        // Let's try to REPLACE all labels with just 'Trash' (Move to Trash), 
                        // OR append it. Appending is safer to keep history.
                        // API: POST /repos/{owner}/{repo}/issues/{issue_number}/labels (Append)
                        // API: PUT /repos/{owner}/{repo}/issues/{issue_number}/labels (Replace)
                        
                        // Let's try appending. If it fails, maybe 'Trash' doesn't exist.
                        // We will try to create it first if the post fails, but for now let's just append.
                        
                        await api.post(`/issues/${issue.number}/labels`, { labels: ['Trash'] }, {
                            headers: { 'Authorization': `token ${token.value}` }
                        });
                        
                        // Also CLOSE it if it's not closed, to be sure
                        if (issue.state !== 'closed') {
                            await api.patch(`/issues/${issue.number}`, { state: 'closed' }, {
                                headers: { 'Authorization': `token ${token.value}` }
                            });
                        }
                    } catch (e) {
                        // If 404/422, maybe label doesn't exist. Try creating it.
                        console.error("Failed to trash, trying to create label...", e);
                        try {
                            await api.post('/labels', { name: 'Trash', color: '000000' }, {
                                headers: { 'Authorization': `token ${token.value}` }
                            });
                            // Retry adding label
                            await api.post(`/issues/${issue.number}/labels`, { labels: ['Trash'] }, {
                                headers: { 'Authorization': `token ${token.value}` }
                            });
                        } catch (err2) {
                            alert('Failed to move to Trash. Please check network/permissions.');
                            // Revert UI if failed
                            fetchIssues(); 
                        }
                    }
                };

                const toggleGroup = (name) => { collapsedGroups.value[name] = !collapsedGroups.value[name]; };
                
                const toggleMenu = (id) => {
                    activeMenuId.value = activeMenuId.value === id ? null : id;
                };
                const closeAllMenus = () => { activeMenuId.value = null; };

                const isCustomGroup = (name) => !defaultTodoLabels.includes(name) && !defaultIdeaLabels.includes(name) && name !== 'Other';

                // Editor
                const openEditor = (issue) => {
                    editingIssue.value = issue;
                    editingTitle.value = issue.title;
                    editingBody.value = issue.body || '';
                    showPreview.value = false;
                    isEditorOpen.value = true;
                };
                const closeEditor = () => { isEditorOpen.value = false; };
                const saveEditor = async () => {
                    if (!editingTitle.value) return;
                    try {
                        const res = await api.patch(`/issues/${editingIssue.value.number}`, {
                            title: editingTitle.value, body: editingBody.value
                        }, { headers: { 'Authorization': `token ${token.value}` } });
                        const idx = issues.value.findIndex(i => i.id === editingIssue.value.id);
                        if (idx !== -1) issues.value[idx] = res.data;
                        closeEditor();
                    } catch (e) { alert('Save failed'); }
                };

                // UI Helpers
                const formatDate = (isoString) => {
                    const date = new Date(isoString);
                    return date.getFullYear() === new Date().getFullYear() 
                        ? `${date.getMonth() + 1}/${date.getDate()}` 
                        : date.toLocaleDateString();
                };
                const getMetaOpacity = (isoString) => {
                    const diff = (new Date() - new Date(isoString)) / 86400000;
                    return diff <= 1 ? 0.8 : (diff >= 7 ? 0.2 : 0.8 - (diff - 1) * 0.1);
                };
                const toggleTheme = () => {
                    isDark.value = !isDark.value;
                    const theme = isDark.value ? 'dark' : 'light';
                    document.documentElement.setAttribute('data-theme', theme);
                    localStorage.setItem('theme', theme);
                };

                // Init
                onMounted(() => {
                    if (token.value) initData();
                    const theme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
                    isDark.value = theme === 'dark';
                    document.documentElement.setAttribute('data-theme', theme);
                });

                return { 
                    token, inputToken, saveToken, logout, issues, loading, toggleIssue, newTask, newLabel, addTask, 
                    groupedIssues, sortedGroupNames, availableLabels, isDark, toggleTheme, formatDate, getMetaOpacity, currentTab,
                    // Groups
                    showGroupModal, newGroupName, createGroup, deleteGroup, isCustomGroup, collapsedGroups, toggleGroup,
                    // Menu
                    activeMenuId, toggleMenu, closeAllMenus,
                    // Editor
                    openEditor, closeEditor, saveEditor, isEditorOpen, editingTitle, editingBody, showPreview, renderedMarkdown,
                    // Delete
                    deleteIssue
                };
            }
        }).mount('#app');
    </script>
</body>
</html>