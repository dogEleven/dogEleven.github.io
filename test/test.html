<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TofuTodo</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TofuTodo">
    <link rel="apple-touch-icon" href="https://github.com/dogEleven.png">
    <link rel="icon" type="image/png" href="https://github.com/dogEleven.png">

    <!-- Use jsDelivr for better stability -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.6.0/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        :root { 
            --primary: #4a90e2; 
            --bg: #f5f5f7; 
            --card-bg: #ffffff; 
            --text: #1c1c1e; 
            --subtext: #8e8e93; 
            --input-bg: #f9f9f9;
            --border: rgba(0,0,0,0.05);
        }
        [data-theme='dark'] {
            --bg: #1c1c1e;
            --card-bg: #2c2c2e;
            --text: #f2f2f7;
            --subtext: #8e8e93;
            --input-bg: #3a3a3c;
            --border: rgba(255,255,255,0.1);
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif; background: var(--bg); padding: 12px; max-width: 600px; margin: 0 auto; color: var(--text); -webkit-font-smoothing: antialiased; transition: background 0.3s, color 0.3s; }
        .login-box { background: var(--card-bg); padding: 30px; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); text-align: center; margin-top: 50px; }
        input, textarea { width: 100%; box-sizing: border-box; padding: 12px 16px; border: 1px solid #d1d1d6; border-radius: 10px; font-size: 16px; background: var(--input-bg); color: var(--text); transition: all 0.2s; font-family: inherit; }
        [data-theme='dark'] input, [data-theme='dark'] textarea { border-color: #3a3a3c; }
        input:focus, textarea:focus { border-color: var(--primary); outline: none; background: var(--card-bg); }
        button { padding: 12px 24px; background: var(--primary); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 16px; font-weight: 600; transition: opacity 0.2s; width: 100%; }
        button:active { opacity: 0.8; }
        
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; margin-top: 4px; }
        .header-left { display: flex; align-items: center; gap: 10px; }
        h1 { font-size: 18px; font-weight: 700; margin: 0; }
        .theme-toggle { background: none; border: none; font-size: 20px; cursor: pointer; padding: 4px; width: auto; }
        .logout-btn { background: none; color: var(--primary); font-weight: 400; padding: 4px 0; width: auto; font-size: 13px; border: none; cursor: pointer; }

        .tabs { display: flex; gap: 4px; background: rgba(0,0,0,0.05); padding: 4px; border-radius: 10px; margin-bottom: 12px; }
        [data-theme='dark'] .tabs { background: rgba(255,255,255,0.05); }
        .tab { flex: 1; text-align: center; padding: 6px; font-size: 13px; border-radius: 6px; cursor: pointer; color: var(--subtext); transition: all 0.2s; }
        .tab.active { background: var(--card-bg); color: var(--text); font-weight: 600; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }

        .new-task { background: var(--card-bg); padding: 8px 10px; border-radius: 10px; margin-bottom: 12px; box-shadow: 0 1px 4px rgba(0,0,0,0.04); display: flex; flex-direction: column; gap: 8px; }
        .new-task-row { display: flex; gap: 8px; }
        .new-task input { margin: 0; border: none; background: transparent; padding: 0; font-size: 14px; }
        .new-task select { padding: 6px; border-radius: 6px; border: 1px solid #e5e5ea; background: var(--bg); font-size: 13px; color: var(--text); }
        [data-theme='dark'] .new-task select { border-color: #3a3a3c; }
        .add-btn { width: auto; padding: 6px 12px; font-size: 13px; border-radius: 6px; }

        .groups-container { display: flex; flex-direction: column; gap: 8px; }
        .group-title { font-size: 13px; font-weight: 700; margin: 0 0 4px 4px; display: flex; align-items: center; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.8; color: var(--subtext); cursor: pointer; }
        .group-title .arrow { margin-right: 6px; font-size: 10px; transition: transform 0.2s; }
        .group-title .arrow.collapsed { transform: rotate(-90deg); }
        .group-title span { background: rgba(0,0,0,0.05); padding: 1px 6px; border-radius: 8px; font-size: 10px; margin-left: 6px; color: var(--text); font-weight: 600; }
        [data-theme='dark'] .group-title span { background: rgba(255,255,255,0.1); }
        
        .todo-list { background: var(--card-bg); border-radius: 10px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.04); margin-top: 4px; }
        .todo-item { 
            background: transparent; 
            padding: 12px; 
            display: grid; 
            /* Grid columns: [Priority] [Icon/Checkbox] [Title/Meta (Flexible)] [Delete Button] */
            grid-template-columns: auto auto 1fr auto;
            align-items: center; 
            gap: 12px; 
            border-bottom: 1px solid var(--border); 
            cursor: pointer; 
            width: 100%; 
            box-sizing: border-box; 
        }
        .todo-item:last-child { border-bottom: none; }
        .todo-item:active { background: var(--bg); }
        .todo-item.done { opacity: 0.5; }
        .todo-item.done .title { text-decoration: line-through; }
        
        /* Custom Checkbox */
        .checkbox { width: 16px; height: 16px; border-radius: 50%; border: 2px solid #c7c7cc; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; margin-top: 1px; }
        .todo-item.done .checkbox { background: var(--primary); border-color: var(--primary); }
        .checkbox::after { content: '‚úì'; color: white; font-size: 10px; display: none; }
        .todo-item.done .checkbox::after { display: block; }

        .title-container { 
            min-width: 0; /* Important for grid stability */
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .title { 
            font-size: 14px; 
            line-height: 1.4; 
            color: var(--text); 
            font-weight: 600; 
            word-break: break-word; /* Allow wrap for long words */
            margin: 0;
        }
        .issue-meta { font-size: 11px; color: var(--subtext); margin: 0; }

        /* Full Screen Editor Modal */
        .editor-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg); z-index: 1000; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s ease; }
        .editor-modal.active { transform: translateY(0); }
        .editor-header { padding: 15px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: rgba(var(--card-bg), 0.9); }
        .editor-body { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        .editor-title { font-size: 18px; font-weight: bold; border: none; background: transparent; outline: none; }
        .editor-textarea { flex: 1; border: none; background: transparent; resize: none; font-size: 16px; line-height: 1.6; outline: none; font-family: inherit; }
        .md-preview { display: none; padding: 10px 0; font-size: 16px; line-height: 1.6; }
        .md-preview.active { display: block; }
        .md-preview h1 { border-bottom: 1px solid var(--border); padding-bottom: 5px; }
        .md-preview img { max-width: 100%; border-radius: 8px; }

        /* New Group Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1100; display: flex; justify-content: center; align-items: center; }
        .modal { background: var(--card-bg); padding: 20px; border-radius: 12px; width: 80%; max-width: 300px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); }
        .modal h3 { margin-top: 0; font-size: 16px; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }
        .btn-cancel { background: transparent; color: var(--subtext); border: 1px solid var(--border); width: auto; padding: 8px 16px; }
        .btn-create { width: auto; padding: 8px 16px; }
        /* Menu Popover */
        .menu-popover {
            position: absolute; right: 40px; background: var(--card-bg); 
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
            z-index: 100; overflow: hidden; display: none; min-width: 100px;
            border: 1px solid rgba(128,128,128,0.2); /* Add border for visibility */
        }
        [data-theme='dark'] .menu-popover {
            border: 1px solid rgba(255,255,255,0.2); /* Lighter border for dark mode */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .menu-popover.active { display: block; }
        .menu-item { padding: 10px 15px; font-size: 14px; cursor: pointer; color: #ff3b30; display: flex; align-items: center; gap: 8px; }
        .menu-item:active { background: var(--bg); }

        /* Priority Box */
        .priority-btn {
            width: 28px;
            height: 18px;
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
            transition: transform 0.1s;
            margin-right: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 800;
            color: white;
            border: none;
        }
        .priority-btn:active { transform: scale(1.1); }
        .priority-p0 { background-color: #ff3b30; }
        .priority-p1 { background-color: #ff9500; } /* More Orange */
        .priority-p2 { background-color: #34c759; }
        .priority-p3 { background-color: #444446; } /* Darker Grey */
        .priority-none { background-color: #444446; } /* Fallback for legacy */

        .del-btn {
            background: none;
            border: none;
            color: #ff3b30;
            font-size: 11px;
            font-weight: 600;
            padding: 4px 8px;
            opacity: 0.3;
            cursor: pointer;
            flex-shrink: 0;
            transition: opacity 0.2s;
            text-align: right;
        }
        .todo-item:hover .del-btn { opacity: 0.8; }
        .del-btn:active { opacity: 1; transform: scale(0.9); }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .spinning {
            display: inline-block;
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body>
    <div id="app" @click="closeAllMenus">
        <!-- Login -->
        <div v-if="!token" class="login-box">
            <h1>üîê TofuTodo</h1>
            <p style="color:var(--subtext); margin-bottom: 20px;">GitHub Personal Access Token</p>
            <input v-model="inputToken" type="password" placeholder="ghp_..." style="text-align: center;">
            <button @click="saveToken" style="margin-top: 10px;">Connect</button>
        </div>

        <!-- Main -->
        <div v-else>
            <div class="header">
                <div class="header-left">
                    <h1>üìã ÂæÖÂäûÊ∏ÖÂçï</h1>
                    <button @click="toggleTheme" class="theme-toggle">{{ isDark ? 'üåô' : '‚òÄÔ∏è' }}</button>
                </div>
                <div style="display:flex; gap:10px;">
                    <button @click="showGroupModal = true" class="logout-btn" style="color:var(--text); font-weight:600;">
                        {{ currentTab === 'idea' ? '+ üìÅ' : '+ ÁªÑ' }}
                    </button>
                    <button @click="initData" class="logout-btn" style="color:var(--text);">
                        <span :class="{ spinning: loading }">üîÑ</span>
                    </button>
                    <button @click="logout" class="logout-btn">Logout</button>
                </div>
            </div>

            <div class="tabs">
                <div class="tab" :class="{ active: currentTab === 'todo' }" @click="currentTab = 'todo'">üìã Ê∏ÖÂçï</div>
                <div class="tab" :class="{ active: currentTab === 'idea' }" @click="currentTab = 'idea'">üìù Â§áÂøòÂΩï</div>
            </div>

            <div class="new-task">
                <div class="new-task-row">
                    <input v-model="newTask" :placeholder="currentTab === 'todo' ? 'Add task...' : 'New memo title...'" @keyup.enter="addTask" style="flex-grow: 1;">
                </div>
                <div class="new-task-row" style="justify-content: space-between; align-items: center;">
                    <select v-model="newLabel">
                        <option v-for="label in availableLabels" :value="label" :key="label">{{ label }}</option>
                    </select>
                    <button @click="addTask" class="add-btn">Add</button>
                </div>
            </div>

            <div v-if="loading" style="text-align: center; color: var(--subtext); padding: 20px;">Loading...</div>

            <!-- Memo View (File Structure) -->
            <div v-if="currentTab === 'idea'" class="groups-container">
                <div v-for="groupName in sortedGroupNames" :key="groupName" class="group-section">
                    <div class="group-title" @click="toggleGroup(groupName)" :class="'text-' + groupName">
                        <span class="arrow" :class="{ collapsed: collapsedGroups[groupName] }">‚ñº</span> üìÇ {{ groupName }} 
                        <span style="font-weight:400; color:var(--subtext); font-size:12px; margin-left:6px;">{{ (groupedIssues[groupName] || []).length }}</span>
                        <span v-if="isCustomGroup(groupName)" @click.stop="deleteGroup(groupName)" style="float:right; font-size:12px; margin-left:10px;">üóëÔ∏è</span>
                        
                    </div>
                    <div class="todo-list" v-show="!collapsedGroups[groupName]">
                        <div v-for="issue in (groupedIssues[groupName] || [])" :key="issue.id" class="todo-item" @click="openEditor(issue)">
                            <div class="priority-btn" :class="getPriorityClass(issue)" @click.stop="cyclePriority(issue)">{{ getPriorityText(issue) }}</div>
                            <span style="font-size:18px; margin-right:8px; flex-shrink:0;">üìÑ</span>
                            <div class="title-container">
                                <div class="title">{{ issue.title }}</div>
                                <div class="issue-meta">{{ formatDate(issue.updated_at) }}</div>
                            </div>
                            <button @click.stop="deleteIssue(issue)" class="del-btn">Del</button>
                        </div>
                        <div v-if="(groupedIssues[groupName] || []).length === 0" style="padding:10px; font-size:12px; color:var(--subtext); text-align:center;">(Empty)</div>
                    </div>
                </div>
            </div>

            <!-- Todo View (Checkboxes) -->
            <div v-else class="groups-container">
                <div v-for="groupName in sortedGroupNames" :key="groupName" class="group-section">
                    <div class="group-title" @click="toggleGroup(groupName)" :class="'text-' + groupName">
                        <span class="arrow" :class="{ collapsed: collapsedGroups[groupName] }">‚ñº</span> {{ groupName }}
                        <span style="font-weight:400; color:var(--subtext); font-size:12px; margin-left:6px;">{{ (groupedIssues[groupName] || []).length }}</span>
                        <span v-if="isCustomGroup(groupName)" @click.stop="deleteGroup(groupName)" style="float:right; font-size:12px; margin-left:10px;">üóëÔ∏è</span>
                        
                    </div>
                    <div class="todo-list" v-show="!collapsedGroups[groupName]">
                        <div v-for="issue in (groupedIssues[groupName] || [])" :key="issue.id" class="todo-item" :class="{done: issue.state === 'closed'}">
                            <div class="priority-btn" :class="getPriorityClass(issue)" @click.stop="cyclePriority(issue)">{{ getPriorityText(issue) }}</div>
                            <div class="checkbox" @click.stop="toggleIssue(issue)"></div>
                            <div class="title-container" @click="openEditor(issue)">
                                <div class="title">{{ issue.title }}</div>
                                <div class="issue-meta">{{ formatDate(issue.created_at) }}</div>
                            </div>
                            <button @click.stop="deleteIssue(issue)" class="del-btn">Del</button>
                        </div>
                        <div v-if="(groupedIssues[groupName] || []).length === 0" style="padding:10px; font-size:12px; color:var(--subtext); text-align:center;">(Empty)</div>
                    </div>
                </div>
            </div>
            <!-- Editor Modal -->
            <div class="editor-modal" :class="{ active: isEditorOpen }">
                <div class="editor-header">
                    <button class="logout-btn" @click="closeEditor">ÂèñÊ∂à</button>
                    <div style="font-weight:600;">ÁºñËæë</div>
                    <button class="logout-btn" style="font-weight:600;" @click="saveEditor">‰øùÂ≠ò</button>
                </div>
                <div class="editor-body">
                    <input v-model="editingTitle" class="editor-title" placeholder="Ê†áÈ¢ò">
                    <div style="display:flex; gap:10px; border-bottom: 1px solid var(--border); padding-bottom:5px;">
                        <button class="logout-btn" @click="showPreview = !showPreview">{{ showPreview ? '‚úèÔ∏è ÁºñËæë' : 'üëÅÔ∏è È¢ÑËßà' }}</button>
                    </div>
                    <textarea v-show="!showPreview" v-model="editingBody" class="editor-textarea" placeholder="ÊîØÊåÅ Markdown..."></textarea>
                    <div v-show="showPreview" class="md-preview active" v-html="renderedMarkdown"></div>
                </div>
            </div>

            <!-- New Group Modal -->
            <div v-if="showGroupModal" class="modal-overlay" @click.self="showGroupModal = false">
                <div class="modal">
                    <h3>Êñ∞Âª∫ÂàÜÁªÑ (Label)</h3>
                    <input v-model="newGroupName" placeholder="ËæìÂÖ•ÂàÜÁªÑÂêçÁß∞ (Ëã±Êñá)" @keyup.enter="createGroup">
                    <div class="modal-actions">
                        <button class="btn-cancel" @click="showGroupModal = false">ÂèñÊ∂à</button>
                        <button class="btn-create" @click="createGroup">ÂàõÂª∫</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, computed, nextTick, watch } = Vue;
        const REPO = "dogEleven/tofutodo";

        createApp({
            setup() {
                // State
                const token = ref(localStorage.getItem('gh_token') || '');
                const inputToken = ref('');
                const issues = ref([]);
                const allLabels = ref([]); 
                const loading = ref(false);
                const newTask = ref('');
                const newLabel = ref('Work');
                const isDark = ref(localStorage.getItem('theme') === 'dark');
                const currentTab = ref(localStorage.getItem('currentTab') || 'todo');
                const collapsedGroups = ref(JSON.parse(localStorage.getItem('collapsedGroups')) || {});
                const showGroupModal = ref(false);
                const newGroupName = ref('');
                const activeMenuId = ref(null);

                // Editor State
                const isEditorOpen = ref(false);
                const editingIssue = ref(null);
                const editingTitle = ref('');
                const editingBody = ref('');
                const showPreview = ref(false);

                // Config
                const defaultTodoLabels = ['Work', 'Life', 'HellDrop', 'Zhutousan'];
                const defaultIdeaLabels = ['Idea', 'Project', 'Reference'];
                const ignoredLabels = ['bug', 'documentation', 'duplicate', 'enhancement', 'good first issue', 'help wanted', 'invalid', 'question', 'wontfix', 'trash', 'p0', 'p1', 'p2', 'p3', 'deleted', 'archived'];

                // Axios
                const api = axios.create({
                    baseURL: `https://api.github.com/repos/${REPO}`,
                    headers: { 'Accept': 'application/vnd.github.v3+json' }
                });

                // Computed
                const availableLabels = computed(() => {
                    const defaults = currentTab.value === 'todo' ? defaultTodoLabels : defaultIdeaLabels;
                    const opposite = currentTab.value === 'todo' ? defaultIdeaLabels : defaultTodoLabels;
                    
                    const custom = allLabels.value
                        .map(l => l.name)
                        .filter(n => !defaults.includes(n) && !opposite.includes(n) && n !== 'Other' && !ignoredLabels.includes(n.toLowerCase()));
                    
                    return [...defaults, ...custom];
                });

                const sortedGroupNames = computed(() => {
                    const labels = availableLabels.value;
                    const hasOther = groupedIssues.value['Other'] && groupedIssues.value['Other'].length > 0;
                    const hasTrash = groupedIssues.value['Trash'] && groupedIssues.value['Trash'].length > 0;
                    
                    let result = [...labels];
                    if (hasOther) result.push('Other');
                    if (hasTrash) result.push('Trash');
                    return result;
                });

                const groupedIssues = computed(() => {
                    const groups = {};
                    availableLabels.value.forEach(l => groups[l] = []);
                    
                    // Define all known system labels to exclude them from 'Other' if they don't match current tab
                    const allSystemLabels = [...defaultTodoLabels, ...defaultIdeaLabels, 'Trash'];
                    groups['Other'] = [];
                    groups['Trash'] = [];

                    issues.value.forEach(issue => {
                        // Priority labels should NOT create groups
                        const isPriorityLabel = (name) => ['P0', 'P1', 'P2', 'P3'].includes(name);

                        // CRITICAL: If it has Trash label, it MUST go to Trash group immediately
                        if (issue.labels.some(l => l.name === 'Trash')) {
                            groups['Trash'].push(issue);
                            return;
                        }

                        let placed = false;
                        let hasSystemLabel = false;

                        if (issue.labels && issue.labels.length > 0) {
                            for (const label of issue.labels) {
                                // Check if this issue belongs to ANY known system group
                                if (allSystemLabels.includes(label.name)) {
                                    hasSystemLabel = true;
                                }

                                // Place in current tab's groups if matched (ignoring priority labels)
                                if (groups[label.name] && !isPriorityLabel(label.name)) {
                                    groups[label.name].push(issue);
                                    placed = true;
                                    break;
                                }
                            }
                        }

                        // Only add to 'Other' if it wasn't placed AND it doesn't belong to the *other* tab's system labels
                        if (!placed && !hasSystemLabel && !issue.labels.some(l => ignoredLabels.includes(l.name.toLowerCase()))) {
                            // Extra check: hide Archived from UI entirely
                            if (!issue.labels.some(l => l.name === 'Archived')) {
                                groups['Other'].push(issue);
                            }
                        }
                    });

                    return groups;
                });

                const renderedMarkdown = computed(() => {
                    return editingBody.value ? marked.parse(editingBody.value) : '';
                });

                // Watchers
                watch(currentTab, (val) => {
                    localStorage.setItem('currentTab', val);
                    // Default labels for each tab
                    if (val === 'todo') {
                        newLabel.value = 'Work';
                    } else {
                        newLabel.value = 'Idea';
                    }
                }, { immediate: true });
                watch(collapsedGroups, (val) => localStorage.setItem('collapsedGroups', JSON.stringify(val)), { deep: true });

                // Methods
                const saveToken = () => {
                    if (!inputToken.value.startsWith('ghp_') && !inputToken.value.startsWith('github_pat_')) {
                        alert('Invalid Token format'); return;
                    }
                    localStorage.setItem('gh_token', inputToken.value);
                    token.value = inputToken.value;
                    initData();
                };

                const logout = () => {
                    localStorage.removeItem('gh_token');
                    token.value = '';
                    issues.value = [];
                };

                const initData = () => { fetchIssues(); fetchLabels(); };

                const fetchIssues = async () => {
                    if (!token.value) return;
                    loading.value = true;
                    try {
                        const res = await api.get(`issues?state=all&sort=updated&direction=desc&per_page=100&_=${Date.now()}`, {
                            headers: { 'Authorization': `token ${token.value}` }
                        });
                        
                        // Sort by priority on load
                        const priorityMap = { 'P0': 4, 'P1': 3, 'P2': 2, 'P3': 1 };
                        res.data.sort((a, b) => {
                            const pA = a.labels.find(l => priorityMap[l.name])?.name || 'P3';
                            const pB = b.labels.find(l => priorityMap[l.name])?.name || 'P3';
                            const scoreA = priorityMap[pA] || 1;
                            const scoreB = priorityMap[pB] || 1;
                            if (scoreA !== scoreB) return scoreB - scoreA;
                            return new Date(b.updated_at) - new Date(a.updated_at);
                        });

                        issues.value = res.data;
                    } catch (e) {
                        alert('Error loading issues: ' + (e.response ? e.response.status : e.message));
                        if (e.response && e.response.status === 401) logout();
                    } finally { loading.value = false; }
                };

                const fetchLabels = async () => {
                    if (!token.value) return;
                    try {
                        const res = await api.get(`labels`, {
 headers: { 'Authorization': `token ${token.value}` } });
                        allLabels.value = res.data;
                    } catch (e) { console.error("Error labels"); }
                };

                const addTask = async () => {
                    if (!newTask.value) return;
                    try {
                        const res = await api.post('/issues', {
                            title: newTask.value,
                            labels: [newLabel.value, 'P3']
                        }, { headers: { 'Authorization': `token ${token.value}` } });
                        issues.value.unshift(res.data);
                        newTask.value = '';
                    } catch (e) { alert('Failed to create task'); }
                };

                const toggleIssue = async (issue) => {
                    const newState = issue.state === 'open' ? 'closed' : 'open';
                    issue.state = newState;
                    try {
                        await api.patch(`/issues/${issue.number}`, { state: newState }, {
                            headers: { 'Authorization': `token ${token.value}` }
                        });
                        // Do not filter out locally
                    } catch (e) {
                        alert('Update failed'); issue.state = issue.state === 'open' ? 'closed' : 'open';
                    }
                };

                const createGroup = async () => {
                    const name = newGroupName.value.trim();
                    if (!name) return;
                    try {
                        await api.post('labels', {
                            name: name,
                            color: Math.floor(Math.random()*16777215).toString(16)
                        }, { headers: { 'Authorization': `token ${token.value}` } });
                        await fetchLabels();
                        showGroupModal.value = false;
                        newGroupName.value = '';
                        newLabel.value = name;
                    } catch (e) { alert('Create failed: ' + e.message); }
                };

                const deleteGroup = async (name) => {
                    if (!confirm(`Delete group "${name}"? This will remove the label from all issues.`)) return;
                    try {
                        await api.delete(`labels/${encodeURIComponent(name)}`, { headers: { 'Authorization': `token ${token.value}` } });
                        await fetchLabels();
                    } catch (e) { 
                        console.error('Delete failed', e);
                        alert('Delete failed: ' + (e.response?.data?.message || e.message)); 
                    }
                };
                
                const deleteIssue = async (issue) => {
                    const oldLabels = [...issue.labels];
                    const oldState = issue.state;
                    
                    // 1. ËØÜÂà´‰ºòÂÖàÁ∫ßÊ†áÁ≠æ
                    const priorityLabel = issue.labels.find(l => ['P0', 'P1', 'P2', 'P3'].includes(l.name));
                    
                    // 2. ÊûÑÈÄ†Êñ∞ÁöÑÊ†áÁ≠æÂàóË°®Ôºö[Trash, ‰ºòÂÖàÁ∫ß]
                    // Ê≥®ÊÑèÔºöGitHub API Êé•Êî∂ labels Êï∞ÁªÑÊó∂Âª∫ËÆÆ‰ΩøÁî®ÁÆÄÂçïÁöÑÂ≠óÁ¨¶‰∏≤Êï∞ÁªÑ
                    const nextLabels = ['Trash'];
                    if (priorityLabel) nextLabels.push(priorityLabel.name);
                    
                    // ‰πêËßÇÊõ¥Êñ∞ UI
                    issue.labels = nextLabels.map(name => ({ name }));
                    issue.state = 'closed';
                    
                    try {
                        console.log(`[TofuTodo] Attempting to trash issue #${issue.number}...`);
                        
                        // Áõ¥Êé•Â∞ùËØï Patch
                        const res = await api.patch(`issues/${issue.number}`, { 
                            labels: nextLabels,
                            state: 'closed' 
                        }, {
                            headers: { 'Authorization': `token ${token.value}` }
                        });
                        
                        console.log(`[TofuTodo] Issue #${issue.number} moved to trash successfully.`);
                        Object.assign(issue, res.data);
                    } catch (e) {
                        console.error("[TofuTodo] Delete attempt failed:", e);
                        
                        const status = e.response?.status;
                        const errorMsg = e.response?.data?.message || "";

                        // ÊÉÖÂÜµ AÔºöÊ†áÁ≠æ‰∏çÂ≠òÂú® (422 Unprocessable Entity)
                        if (status === 422 || errorMsg.includes("Label does not exist")) {
                            console.log("[TofuTodo] Trash label missing, attempting to create...");
                            try {
                                await api.post('labels', { name: 'Trash', color: '000000' }, {
                                    headers: { 'Authorization': `token ${token.value}` }
                                });
                                // ÂàõÂª∫ÊàêÂäüÂêéÈáçËØï
                                const retryRes = await api.patch(`issues/${issue.number}`, { 
                                    labels: nextLabels,
                                    state: 'closed' 
                                }, {
                                    headers: { 'Authorization': `token ${token.value}` }
                                });
                                Object.assign(issue, retryRes.data);
                                return;
                            } catch (labelErr) {
                                if (labelErr.response?.status === 422) {
                                    // Âç≥‰ΩøÊä• 422 (Â∑≤Â≠òÂú®)Ôºå‰πüËØ¥ÊòéÊ†áÁ≠æÁé∞Âú®Êúâ‰∫ÜÔºåÂÜçÊúÄÂêéËØï‰∏ÄÊ¨° Patch
                                    try {
                                        const finalRes = await api.patch(`issues/${issue.number}`, { 
                                            labels: nextLabels,
                                            state: 'closed' 
                                        }, {
                                            headers: { 'Authorization': `token ${token.value}` }
                                        });
                                        Object.assign(issue, finalRes.data);
                                        return;
                                    } catch (fErr) {}
                                }
                                alert(`Êó†Ê≥ïÂàõÂª∫ "Trash" Ê†áÁ≠æ„ÄÇËØ∑Ê£ÄÊü•ÊÇ®ÁöÑ Token ÊùÉÈôêÔºàÈúÄÂåÖÂê´ repo ‰ΩúÁî®ÂüüÔºâÔºåÊàñÊâãÂä®Âú® GitHub ‰ªìÂ∫ì‰∏≠ÂàõÂª∫‰∏Ä‰∏™Âêç‰∏∫ Trash ÁöÑÊ†áÁ≠æ„ÄÇ\n\nÈîôËØØ‰ø°ÊÅØ: ${labelErr.message}`);
                            }
                        } 
                        // ÊÉÖÂÜµ BÔºöÊùÉÈôê‰∏çË∂≥ (403/404)
                        else if (status === 403 || status === 404) {
                            alert('Êó†ÊùÉ‰øÆÊîπÊ≠§Êù°ÁõÆ„ÄÇËØ∑Ê£ÄÊü•Ôºö\n1. Token ÊòØÂê¶ÂãæÈÄâ‰∫Ü "repo" ÊùÉÈôê„ÄÇ\n2. ÊÇ®ÊòØÂê¶ÂØπ dogEleven/tofutodo ‰ªìÂ∫ìÊúâÂÜôÊùÉÈôê„ÄÇ');
                        } 
                        // ÂÖ∂‰ªñÊÉÖÂÜµ
                        else {
                            alert('Âà†Èô§Â§±Ë¥•: ' + (e.response?.data?.message || e.message));
                        }

                        // ÂõûÊªö UI
                        issue.labels = oldLabels;
                        issue.state = oldState;
                        fetchIssues(); 
                    }
                };

                const cyclePriority = async (issue) => {
                    const priorities = ['P0', 'P1', 'P2', 'P3'];
                    const currentPriority = issue.labels.find(l => priorities.includes(l.name))?.name || 'P3';
                    const idx = priorities.indexOf(currentPriority);
                    const nextPriority = priorities[(idx + 1) % priorities.length];

                    // Update local state first (optimistic)
                    issue.labels = issue.labels.filter(l => !priorities.includes(l.name));
                    issue.labels.push({ name: nextPriority });

                    try {
                        // We need the full set of labels to preserve other categories (like Work/Idea)
                        const allRemainingLabels = issue.labels.map(l => l.name);
                        
                        // Ensure the label exists on the repo (GitHub will return 422 if it doesn't)
                        // For simplicity, we assume labels exist or will be created on first use in background
                        // But to be robust, let's just send the patch.
                        await api.patch(`/issues/${issue.number}`, {
                            labels: allRemainingLabels
                        }, { headers: { 'Authorization': `token ${token.value}` } });
                    } catch (e) {
                        console.error("Priority update failed", e);
                        // In a real app, we'd try to create the label once if it fails with 422
                    }
                };

                const getPriorityClass = (issue) => {
                    const p = issue.labels.find(l => ['P0', 'P1', 'P2', 'P3'].includes(l.name))?.name;
                    return p ? `priority-${p.toLowerCase()}` : 'priority-p3';
                };

                const getPriorityText = (issue) => {
                    return issue.labels.find(l => ['P0', 'P1', 'P2', 'P3'].includes(l.name))?.name || 'P3';
                };

                const toggleGroup = (name) => { collapsedGroups.value[name] = !collapsedGroups.value[name]; };
                
                const toggleMenu = (id) => {
                    activeMenuId.value = activeMenuId.value === id ? null : id;
                };
                const closeAllMenus = () => { activeMenuId.value = null; };

                const isCustomGroup = (name) => !defaultTodoLabels.includes(name) && !defaultIdeaLabels.includes(name) && name !== 'Other' && name !== 'Trash';

                // Editor
                const openEditor = (issue) => {
                    editingIssue.value = issue;
                    editingTitle.value = issue.title;
                    editingBody.value = issue.body || '';
                    showPreview.value = false;
                    isEditorOpen.value = true;
                };
                const closeEditor = () => { isEditorOpen.value = false; };
                const saveEditor = async () => {
                    if (!editingTitle.value) return;
                    try {
                        const res = await api.patch(`/issues/${editingIssue.value.number}`, {
                            title: editingTitle.value, body: editingBody.value
                        }, { headers: { 'Authorization': `token ${token.value}` } });
                        const idx = issues.value.findIndex(i => i.id === editingIssue.value.id);
                        if (idx !== -1) issues.value[idx] = res.data;
                        closeEditor();
                    } catch (e) { alert('Save failed'); }
                };

                // UI Helpers
                const formatDate = (isoString) => {
                    const date = new Date(isoString);
                    return date.getFullYear() === new Date().getFullYear() 
                        ? `${date.getMonth() + 1}/${date.getDate()}` 
                        : date.toLocaleDateString();
                };
                const getMetaOpacity = (isoString) => {
                    const diff = (new Date() - new Date(isoString)) / 86400000;
                    return diff <= 1 ? 0.8 : (diff >= 7 ? 0.2 : 0.8 - (diff - 1) * 0.1);
                };
                const toggleTheme = () => {
                    isDark.value = !isDark.value;
                    const theme = isDark.value ? 'dark' : 'light';
                    document.documentElement.setAttribute('data-theme', theme);
                    localStorage.setItem('theme', theme);
                };

                // Init
                onMounted(() => {
                    if (token.value) initData();
                    const theme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
                    isDark.value = theme === 'dark';
                    document.documentElement.setAttribute('data-theme', theme);
                });

                return { 
                    token, inputToken, saveToken, logout, issues, loading, toggleIssue, newTask, newLabel, addTask, 
                    groupedIssues, sortedGroupNames, availableLabels, isDark, toggleTheme, formatDate, getMetaOpacity, currentTab,
                    // Groups
                    showGroupModal, newGroupName, createGroup, deleteGroup, isCustomGroup, collapsedGroups, toggleGroup,
                    // Menu
                    activeMenuId, toggleMenu, closeAllMenus,
                    // Editor
                    openEditor, closeEditor, saveEditor, isEditorOpen, editingTitle, editingBody, showPreview, renderedMarkdown,
                    // Delete
                    deleteIssue,
                    // Priority
                    cyclePriority, getPriorityClass, getPriorityText,
                    // Refresh
                    initData
                };
            }
        }).mount('#app');
    </script>
</body>
</html>