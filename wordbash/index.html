<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WordBash</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --tile-bg: #ecf0f1;
            --text-color: #34495e;
            --highlight: #2ecc71;
            --gold: #f1c40f;
            --tile-size: 60px; /* Smaller tiles */
        }

        body {
            font-family: 'Verdana', sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .header { 
            padding: 10px; text-align: center; z-index: 20; 
            height: 50px; box-sizing: border-box; flex-shrink: 0;
        }
        h1 { margin: 0; font-size: 20px; letter-spacing: 2px; }
        .score { font-size: 16px; color: var(--gold); font-weight: bold; margin-top: 2px; }

        .game-board {
            position: relative;
            display: flex;
            justify-content: center;
            gap: 6px;
            /* Full height minus header */
            flex: 1; 
            width: 100%;
            margin-top: 0;
            /* Remove mask as requested */
            -webkit-mask-image: none;
            mask-image: none;
        }

        /* Payline Indicator */
        .payline {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: var(--tile-size); 
            transform: translateY(-50%);
            border-top: 1px solid rgba(231, 76, 60, 0.6);
            border-bottom: 1px solid rgba(231, 76, 60, 0.6);
            background: rgba(255, 255, 255, 0.03);
            pointer-events: none;
            z-index: 0;
        }
        
        /* Column (Scroll Container) */
        .column {
            width: var(--tile-size);
            height: 100%;
            overflow-y: scroll;
            scroll-snap-type: y mandatory; /* Native Snap */
            scrollbar-width: none; /* Hide scrollbar */
            -ms-overflow-style: none;
            /* Center alignment padding logic */
            /* We want center of first tile to be at center of container */
            /* Container height is dynamic (flex:1). */
            /* Padding top = 50vh (approx) - tile/2 */
            padding-top: calc(50vh - 30px - var(--tile-size)/2); 
            padding-bottom: calc(50vh - 30px - var(--tile-size)/2);
            box-sizing: border-box;
        }
        .column::-webkit-scrollbar { display: none; }

        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            background: var(--tile-bg);
            color: var(--text-color);
            font-size: 32px; /* Smaller font */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            margin-bottom: 6px; /* Smaller gap */
            scroll-snap-align: center; /* Snap target */
            box-shadow: 0 2px 0 rgba(0,0,0,0.1);
            user-select: none;
            flex-shrink: 0;
        }
        
        .tile.matched {
            background-color: #2ecc71;
            color: white;
            animation: pop 0.4s ease-out;
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .controls { position:fixed; bottom:20px; text-align:center; font-size:14px; color:#bdc3c7; }
    </style>
</head>
<body>

    <div class="header">
        <h1>WORD BASH</h1>
        <div class="score">SCORE: <span id="scoreVal">0</span></div>
    </div>

    <div class="game-board" id="board">
        <div class="payline"></div>
        <!-- Columns -->
    </div>

    <div class="controls">
        <p>Scroll columns to bash words!</p>
    </div>

    <script>
        const COLS = 4;
        const TILE_HEIGHT = 60; // Adjusted for new CSS
        const TILE_MARGIN = 6;
        const TOTAL_ITEM_HEIGHT = TILE_HEIGHT + TILE_MARGIN;
        
        // Massive 4-letter dictionary
        const COMMON_WORDS = [
"ABLE","ACID","AGED","ALSO","AREA","ARMY","AWAY","BABY","BACK","BALL","BAND","BANK","BASE","BATH","BEAR","BEAT","BEEN","BEER","BELL","BELT","BEST","BILL","BIRD","BLOW","BLUE","BOAT","BODY","BOMB","BOND","BONE","BOOK","BOOM","BORN","BOSS","BOTH","BOWL","BULK","BURN","BUSH","BUSY","CALL","CALM","CAME","CAMP","CARD","CARE","CASE","CASH","CAST","CELL","CHAT","CHIP","CITY","CLUB","COAL","COAT","CODE","COLD","COME","COOK","COOL","COPE","COPY","CORE","COST","CREW","CROP","DARK","DATA","DATE","DAWN","DAYS","DEAD","DEAL","DEAN","DEAR","DEBT","DEEP","DENY","DESK","DIAL","DIET","DISC","DISK","DOES","DONE","DOOR","DOSE","DOWN","DRAW","DREW","DROP","DRUG","DUAL","DUKE","DUST","DUTY","EACH","EARN","EARS","EASE","EAST","EASY","EDGE","ELSE","EVEN","EVER","EVIL","EXIT","FACE","FACT","FAIL","FAIR","FALL","FARM","FAST","FATE","FEAR","FEED","FEEL","FEET","FELL","FELT","FILE","FILL","FILM","FIND","FINE","FIRE","FIRM","FISH","FIVE","FLAT","FLOW","FOOD","FOOT","FORD","FORM","FORT","FOUR","FREE","FROM","FUEL","FULL","FUND","GAIN","GAME","GATE","GAVE","GEAR","GENE","GIFT","GIRL","GIVE","GLAD","GOAL","GOES","GOLD","GOLF","GONE","GOOD","GRAY","GREW","GREY","GROW","GULF","HAIR","HALF","HALL","HAND","HANG","HARD","HARM","HATE","HAVE","HEAD","HEAR","HEAT","HELL","HELP","HERE","HERO","HIGH","HILL","HIRE","HOLD","HOLE","HOLY","HOME","HOPE","HOST","HOUR","HUGE","HUNG","HUNT","HURT","IDEA","INCH","INTO","IRON","ITEM","JACK","JANE","JEAN","JOHN","JOIN","JUMP","JURY","JUST","KEEN","KEEP","KEPT","KICK","KILL","KIND","KING","KNEE","KNEW","KNOW","LACK","LADY","LAID","LAKE","LAND","LANE","LAST","LATE","LEAD","LEFT","LESS","LIFE","LIFT","LIKE","LINE","LINK","LIST","LIVE","LOAD","LOAN","LOCK","LOGO","LONG","LOOK","LORD","LOSE","LOSS","LOST","LOVE","LUCK","MADE","MAIL","MAIN","MAKE","MALE","MANY","MARK","MASS","MEAL","MEAN","MEAT","MEET","MENU","MERE","MILE","MILK","MILL","MIND","MINE","MISS","MODE","MOOD","MOON","MORE","MOST","MOVE","MUCH","MUST","NAME","NAVY","NEAR","NECK","NEED","NEWS","NEXT","NICE","NINE","NONE","NOSE","NOTE","OKAY","ONCE","ONLY","ONTO","OPEN","ORAL","OVER","PACE","PACK","PAGE","PAID","PAIN","PAIR","PALM","PARK","PART","PASS","PAST","PATH","PEAK","PICK","PILE","PINK","PIPE","PLAN","PLAY","PLOT","PLUG","PLUS","POLL","POOL","POOR","PORT","POST","PULL","PURE","PUSH","RACE","RAIL","RAIN","RANK","RARE","RATE","READ","REAL","REAR","RELY","RENT","REST","RICE","RICH","RIDE","RING","RISE","RISK","ROAD","ROCK","ROLE","ROLL","ROOF","ROOM","ROOT","ROSE","RULE","RUSH","RUTH","SAFE","SAID","SAKE","SALE","SALT","SAME","SAND","SAVE","SEAT","SEED","SEEK","SEEM","SEEN","SELF","SELL","SEND","SENT","SEPT","SHIP","SHOP","SHOT","SHOW","SHUT","SICK","SIDE","SIGN","SILK","SITE","SIZE","SKIN","SLIP","SLOW","SNOW","SOFT","SOIL","SOLD","SOLE","SOME","SONG","SOON","SORT","SOUL","SOUP","SPOT","STAR","STAY","STEP","STOP","SUCH","SUIT","SURE","TAKE","TALE","TALK","TALL","TANK","TAPE","TASK","TEAM","TECH","TELL","TEND","TERM","TEST","TEXT","THAT","THEM","THEN","THIN","THIS","THUS","TILL","TIME","TINY","TOLD","TOLL","TONE","TONY","TOOK","TOOL","TOUR","TOWN","TREE","TRIP","TRUE","TUBE","TURN","TWIN","TYPE","UNIT","UPON","USED","USER","VARY","VAST","VERY","VICE","VIEW","VOTE","WAGE","WAIT","WAKE","WALK","WALL","WANT","WARD","WARM","WASH","WAVE","WAYS","WEAK","WEAR","WEEK","WELL","WENT","WERE","WEST","WHAT","WHEN","WHOM","WIDE","WIFE","WILD","WILL","WIND","WINE","WING","WIRE","WISE","WISH","WITH","WOOD","WORD","WORK","YARD","YEAR","ZERO","ZONE","ZOO","ZOOM","ZINC","ZEST","YOGA","YOGI","YOLK","YAWN","YARN","WORM","WOOL","WOLF"
        ];
        const DICT = new Set(COMMON_WORDS);
        const ALPHABET = "EEEEAAAAIIIOOOUURRTLLSSNNDGBCMPFHVWYKJXQZ"; // Weighted for playability
        
        let score = 0;
        const columns = [];
        const scoreEl = document.getElementById('scoreVal');

        function init() {
            const board = document.getElementById('board');
            
            for (let c = 0; c < COLS; c++) {
                const col = document.createElement('div');
                col.className = 'column';
                col.id = `col-${c}`;
                
                // Add lots of tiles for infinite scroll feel
                for (let i = 0; i < 50; i++) {
                    addTileToColumn(col);
                }
                
                // Infinite Scroll Logic: Append/Prepend
                col.addEventListener('scroll', () => handleScroll(col, c));
                
                // Scroll End Detection (for checking matches)
                let isScrolling;
                col.addEventListener('scroll', () => {
                    window.clearTimeout(isScrolling);
                    isScrolling = setTimeout(() => {
                        checkMatches();
                    }, 200); // Check after scroll stops
                });

                board.appendChild(col);
                columns.push(col);
                
                // Initial random position (must be multiple of item height for snap)
                // Using timeout to allow layout
                setTimeout(() => {
                    col.scrollTop = Math.floor(Math.random() * 20) * TOTAL_ITEM_HEIGHT;
                }, 10);
            }
        }

        function getRandomChar() {
            return ALPHABET[Math.floor(Math.random() * ALPHABET.length)];
        }

        function addTileToColumn(col, prepend = false) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.innerText = getRandomChar();
            if (prepend) col.prepend(tile);
            else col.appendChild(tile);
        }

        function handleScroll(col, c) {
            // If near bottom, add more to bottom
            if (col.scrollHeight - col.scrollTop - col.clientHeight < 200) {
                for(let i=0; i<5; i++) addTileToColumn(col);
            }
            // If near top, this is harder with native scroll because prepending shifts scrollTop.
            // For simplicity in this demo, we just make the list very long initially.
            // A true infinite scroll upwards requires adjusting scrollTop to maintain position.
        }

        function checkMatches() {
            // Find visible rows based on center of view
            // Because height is dynamic (100vh), we need to check more rows.
            // Let's assume max possible visible rows is ~15.
            // We check center +/- 8 rows just to be safe.
            
            let colIndices = [];
            
            columns.forEach(col => {
                const centerY = col.scrollTop + (col.clientHeight / 2);
                // content starts at padding-top
                // padding-top is dynamic.
                // But native scroll logic: scrollTop=0 means you see content from top.
                // However, our content is centered via padding.
                // If scrollTop=0, we see the padding.
                // Let's rely on getBoundingClientRect? No, too slow.
                // Let's recalculate padding logic.
                
                // CSS Padding-top: calc(50vh - 30px - 30px) approx.
                // Let's simplify:
                // Index 0 is at Y = padding-top.
                // Center of Index 0 is at Y = padding-top + TILE_SIZE/2.
                // We want the index whose center is at (scrollTop + ClientHeight/2).
                
                // CenterOfView = scrollTop + ClientHeight/2
                // CenterOfTile(i) = PaddingTop + i*TotalHeight + TileHeight/2
                // scrollTop + CH/2 = PT + i*TH + TH/2
                
                // i = (scrollTop + CH/2 - PT - TH/2) / TH
                // Since PT = CH/2 - TH/2 (roughly, see CSS calc)
                // i = (scrollTop + CH/2 - (CH/2 - TH/2) - TH/2) / TH
                // i = scrollTop / TotalHeight
                
                // This formula holds true if padding centers the first item!
                
                const idx = Math.round(col.scrollTop / TOTAL_ITEM_HEIGHT);
                colIndices.push(idx);
            });

            let wordFound = false;
            let matchedTiles = []; // {col, childIndex}

            // Check range: Center row is 0 relative to colIndices.
            // Screen fits roughly 10-12 rows. So check -6 to +6.
            for (let offset = -6; offset <= 6; offset++) {
                let word = "";
                let rowTiles = [];
                
                for (let c = 0; c < COLS; c++) {
                    const targetIdx = colIndices[c] + offset;
                    // Check bounds
                    if (columns[c].children[targetIdx]) {
                        const tile = columns[c].children[targetIdx];
                        word += tile.innerText;
                        rowTiles.push({c, idx: targetIdx, el: tile});
                    } else {
                        word += "?";
                    }
                }
                
                if (DICT.has(word)) {
                    wordFound = true;
                    matchedTiles.push(...rowTiles);
                    score += 100;
                }
            }
            
            // ... (rest logic same)

            if (wordFound) {
                scoreEl.innerText = score;
                matchedTiles.forEach(item => {
                    item.el.classList.add('matched');
                    // Replace logic: 
                    // To keep native scroll stable, we just change text and remove class
                    setTimeout(() => {
                        item.el.classList.remove('matched');
                        item.el.innerText = getRandomChar(); // "Eliminate" by replacing
                        // Trigger check again?
                        // setTimeout(checkMatches, 300); // Chain reaction
                    }, 500);
                });
            }
        }

        init();

    </script>
</body>
</html>