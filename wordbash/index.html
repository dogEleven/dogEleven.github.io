<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WordBash</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --tile-bg: #ecf0f1;
            --text-color: #34495e;
            --highlight: #2ecc71;
            --gold: #f1c40f;
            --tile-size: 80px;
        }

        body {
            font-family: 'Verdana', sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .header { padding: 20px; text-align: center; z-index: 20; height: 60px; box-sizing: border-box; }
        h1 { margin: 0; font-size: 24px; letter-spacing: 2px; }
        .score { font-size: 20px; color: var(--gold); font-weight: bold; margin-top: 5px; }

        .game-board {
            position: relative;
            display: flex;
            justify-content: center;
            gap: 8px;
            /* Use a fixed height that is an ODD multiple of tile size to ensure center is a tile */
            /* 5 tiles * 80 = 400px. Center is 200px. */
            height: 400px; 
            width: 100%;
            margin-top: 20px;
            /* Gradient mask for fade effect */
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);
            mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);
        }

        /* Payline Indicator */
        .payline {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: var(--tile-size); 
            transform: translateY(-50%);
            border-top: 2px solid rgba(231, 76, 60, 0.8);
            border-bottom: 2px solid rgba(231, 76, 60, 0.8);
            background: rgba(255, 255, 255, 0.05);
            pointer-events: none;
            z-index: 0;
        }

        /* Column (Scroll Container) */
        .column {
            width: var(--tile-size);
            height: 100%;
            overflow-y: scroll;
            scroll-snap-type: y mandatory; /* Native Snap */
            scrollbar-width: none; /* Hide scrollbar */
            -ms-overflow-style: none;
            padding-top: calc(50% - var(--tile-size)/2); /* Center first item */
            padding-bottom: calc(50% - var(--tile-size)/2);
            box-sizing: border-box;
        }
        .column::-webkit-scrollbar { display: none; }

        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            background: var(--tile-bg);
            color: var(--text-color);
            font-size: 40px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            margin-bottom: 8px; /* Gap between tiles */
            scroll-snap-align: center; /* Snap target */
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            user-select: none;
        }
        
        .tile.matched {
            background-color: #2ecc71;
            color: white;
            animation: pop 0.4s ease-out;
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .controls { position:fixed; bottom:20px; text-align:center; font-size:14px; color:#bdc3c7; }
    </style>
</head>
<body>

    <div class="header">
        <h1>WORD BASH</h1>
        <div class="score">SCORE: <span id="scoreVal">0</span></div>
    </div>

    <div class="game-board" id="board">
        <div class="payline"></div>
        <!-- Columns -->
    </div>

    <div class="controls">
        <p>Scroll columns to bash words!</p>
    </div>

    <script>
        const COLS = 4;
        const TILE_HEIGHT = 80;
        const TILE_MARGIN = 8;
        const TOTAL_ITEM_HEIGHT = TILE_HEIGHT + TILE_MARGIN;
        
        // Massive 4-letter dictionary
        const COMMON_WORDS = [
"ABLE","ACID","AGED","ALSO","AREA","ARMY","AWAY","BABY","BACK","BALL","BAND","BANK","BASE","BATH","BEAR","BEAT","BEEN","BEER","BELL","BELT","BEST","BILL","BIRD","BLOW","BLUE","BOAT","BODY","BOMB","BOND","BONE","BOOK","BOOM","BORN","BOSS","BOTH","BOWL","BULK","BURN","BUSH","BUSY","CALL","CALM","CAME","CAMP","CARD","CARE","CASE","CASH","CAST","CELL","CHAT","CHIP","CITY","CLUB","COAL","COAT","CODE","COLD","COME","COOK","COOL","COPE","COPY","CORE","COST","CREW","CROP","DARK","DATA","DATE","DAWN","DAYS","DEAD","DEAL","DEAN","DEAR","DEBT","DEEP","DENY","DESK","DIAL","DIET","DISC","DISK","DOES","DONE","DOOR","DOSE","DOWN","DRAW","DREW","DROP","DRUG","DUAL","DUKE","DUST","DUTY","EACH","EARN","EARS","EASE","EAST","EASY","EDGE","ELSE","EVEN","EVER","EVIL","EXIT","FACE","FACT","FAIL","FAIR","FALL","FARM","FAST","FATE","FEAR","FEED","FEEL","FEET","FELL","FELT","FILE","FILL","FILM","FIND","FINE","FIRE","FIRM","FISH","FIVE","FLAT","FLOW","FOOD","FOOT","FORD","FORM","FORT","FOUR","FREE","FROM","FUEL","FULL","FUND","GAIN","GAME","GATE","GAVE","GEAR","GENE","GIFT","GIRL","GIVE","GLAD","GOAL","GOES","GOLD","GOLF","GONE","GOOD","GRAY","GREW","GREY","GROW","GULF","HAIR","HALF","HALL","HAND","HANG","HARD","HARM","HATE","HAVE","HEAD","HEAR","HEAT","HELL","HELP","HERE","HERO","HIGH","HILL","HIRE","HOLD","HOLE","HOLY","HOME","HOPE","HOST","HOUR","HUGE","HUNG","HUNT","HURT","IDEA","INCH","INTO","IRON","ITEM","JACK","JANE","JEAN","JOHN","JOIN","JUMP","JURY","JUST","KEEN","KEEP","KEPT","KICK","KILL","KIND","KING","KNEE","KNEW","KNOW","LACK","LADY","LAID","LAKE","LAND","LANE","LAST","LATE","LEAD","LEFT","LESS","LIFE","LIFT","LIKE","LINE","LINK","LIST","LIVE","LOAD","LOAN","LOCK","LOGO","LONG","LOOK","LORD","LOSE","LOSS","LOST","LOVE","LUCK","MADE","MAIL","MAIN","MAKE","MALE","MANY","MARK","MASS","MEAL","MEAN","MEAT","MEET","MENU","MERE","MILE","MILK","MILL","MIND","MINE","MISS","MODE","MOOD","MOON","MORE","MOST","MOVE","MUCH","MUST","NAME","NAVY","NEAR","NECK","NEED","NEWS","NEXT","NICE","NINE","NONE","NOSE","NOTE","OKAY","ONCE","ONLY","ONTO","OPEN","ORAL","OVER","PACE","PACK","PAGE","PAID","PAIN","PAIR","PALM","PARK","PART","PASS","PAST","PATH","PEAK","PICK","PILE","PINK","PIPE","PLAN","PLAY","PLOT","PLUG","PLUS","POLL","POOL","POOR","PORT","POST","PULL","PURE","PUSH","RACE","RAIL","RAIN","RANK","RARE","RATE","READ","REAL","REAR","RELY","RENT","REST","RICE","RICH","RIDE","RING","RISE","RISK","ROAD","ROCK","ROLE","ROLL","ROOF","ROOM","ROOT","ROSE","RULE","RUSH","RUTH","SAFE","SAID","SAKE","SALE","SALT","SAME","SAND","SAVE","SEAT","SEED","SEEK","SEEM","SEEN","SELF","SELL","SEND","SENT","SEPT","SHIP","SHOP","SHOT","SHOW","SHUT","SICK","SIDE","SIGN","SILK","SITE","SIZE","SKIN","SLIP","SLOW","SNOW","SOFT","SOIL","SOLD","SOLE","SOME","SONG","SOON","SORT","SOUL","SOUP","SPOT","STAR","STAY","STEP","STOP","SUCH","SUIT","SURE","TAKE","TALE","TALK","TALL","TANK","TAPE","TASK","TEAM","TECH","TELL","TEND","TERM","TEST","TEXT","THAT","THEM","THEN","THIN","THIS","THUS","TILL","TIME","TINY","TOLD","TOLL","TONE","TONY","TOOK","TOOL","TOUR","TOWN","TREE","TRIP","TRUE","TUBE","TURN","TWIN","TYPE","UNIT","UPON","USED","USER","VARY","VAST","VERY","VICE","VIEW","VOTE","WAGE","WAIT","WAKE","WALK","WALL","WANT","WARD","WARM","WASH","WAVE","WAYS","WEAK","WEAR","WEEK","WELL","WENT","WERE","WEST","WHAT","WHEN","WHOM","WIDE","WIFE","WILD","WILL","WIND","WINE","WING","WIRE","WISE","WISH","WITH","WOOD","WORD","WORK","YARD","YEAR","ZERO","ZONE","ZOO","ZOOM","ZINC","ZEST","YOGA","YOGI","YOLK","YAWN","YARN","WORM","WOOL","WOLF"
        ];
        const DICT = new Set(COMMON_WORDS);
        const ALPHABET = "EEEEAAAAIIIOOOUURRTLLSSNNDGBCMPFHVWYKJXQZ"; // Weighted for playability
        
        let score = 0;
        const columns = [];
        const scoreEl = document.getElementById('scoreVal');

        function init() {
            const board = document.getElementById('board');
            
            for (let c = 0; c < COLS; c++) {
                const col = document.createElement('div');
                col.className = 'column';
                col.id = `col-${c}`;
                
                // Add lots of tiles for infinite scroll feel
                for (let i = 0; i < 50; i++) {
                    addTileToColumn(col);
                }
                
                // Infinite Scroll Logic: Append/Prepend
                col.addEventListener('scroll', () => handleScroll(col, c));
                
                // Scroll End Detection (for checking matches)
                let isScrolling;
                col.addEventListener('scroll', () => {
                    window.clearTimeout(isScrolling);
                    isScrolling = setTimeout(() => {
                        checkMatches();
                    }, 200); // Check after scroll stops
                });

                board.appendChild(col);
                columns.push(col);
                
                // Initial random position (must be multiple of item height for snap)
                // Using timeout to allow layout
                setTimeout(() => {
                    col.scrollTop = Math.floor(Math.random() * 20) * TOTAL_ITEM_HEIGHT;
                }, 10);
            }
        }

        function getRandomChar() {
            return ALPHABET[Math.floor(Math.random() * ALPHABET.length)];
        }

        function addTileToColumn(col, prepend = false) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.innerText = getRandomChar();
            if (prepend) col.prepend(tile);
            else col.appendChild(tile);
        }

        function handleScroll(col, c) {
            // If near bottom, add more to bottom
            if (col.scrollHeight - col.scrollTop - col.clientHeight < 200) {
                for(let i=0; i<5; i++) addTileToColumn(col);
            }
            // If near top, this is harder with native scroll because prepending shifts scrollTop.
            // For simplicity in this demo, we just make the list very long initially.
            // A true infinite scroll upwards requires adjusting scrollTop to maintain position.
        }

        function checkMatches() {
            // Find visible rows
            // Container height is 400. Center is 200.
            // Payline is at 200.
            // Item height 88 (80+8).
            
            // We want to check ~5 rows centered around the viewport.
            // For each column, find the index of the tile closest to center.
            
            let colIndices = [];
            
            columns.forEach(col => {
                // scrollTop is distance from top of content to top of view
                // View center = scrollTop + 200
                const centerY = col.scrollTop + (col.clientHeight / 2);
                // Index = centerY / ItemHeight
                // But we have padding-top (calc(50% - 40px)) = 160px
                // So content starts at 160px.
                // Tile 0 center = 160 + 40 = 200.
                // Tile N center = 160 + N*88 + 40 = 200 + N*88.
                // center Y = 200 + N*88.
                // N = (centerY - 200) / 88.
                
                // Wait, scrollTop 0 means we are at top.
                // If scrollTop = 0, CenterY = 200.
                // Tile 0 center is at 200. So Index 0 is selected.
                // Index = Math.round(col.scrollTop / TOTAL_ITEM_HEIGHT)
                
                const idx = Math.round(col.scrollTop / TOTAL_ITEM_HEIGHT);
                colIndices.push(idx);
            });

            // Check Row 0 (Center), Row -1 (Above), Row +1 (Below), etc.
            // Let's check center row and +/- 2 rows
            let wordFound = false;
            let matchedTiles = []; // {col, childIndex}

            for (let offset = -2; offset <= 2; offset++) {
                let word = "";
                let rowTiles = [];
                
                for (let c = 0; c < COLS; c++) {
                    const targetIdx = colIndices[c] + offset;
                    const tile = columns[c].children[targetIdx];
                    
                    if (tile) {
                        word += tile.innerText;
                        rowTiles.push({c, idx: targetIdx, el: tile});
                    } else {
                        word += "?";
                    }
                }
                
                if (DICT.has(word)) {
                    wordFound = true;
                    matchedTiles.push(...rowTiles);
                    // Bonus score
                    score += 100;
                }
            }

            if (wordFound) {
                scoreEl.innerText = score;
                matchedTiles.forEach(item => {
                    item.el.classList.add('matched');
                    // Replace logic: 
                    // To keep native scroll stable, we just change text and remove class
                    setTimeout(() => {
                        item.el.classList.remove('matched');
                        item.el.innerText = getRandomChar(); // "Eliminate" by replacing
                        // Trigger check again?
                        // setTimeout(checkMatches, 300); // Chain reaction
                    }, 500);
                });
            }
        }

        init();

    </script>
</body>
</html>