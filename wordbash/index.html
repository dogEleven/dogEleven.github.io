<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WordBash</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --tile-bg: #ecf0f1;
            --text-color: #34495e;
            --highlight: #2ecc71;
            --gold: #f1c40f;
        }

        body {
            font-family: 'Verdana', sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* Prevent browser scroll */
        }

        .header {
            padding: 20px;
            text-align: center;
        }

        h1 { margin: 0; font-size: 24px; letter-spacing: 2px; }
        .score { font-size: 20px; color: var(--gold); font-weight: bold; margin-top: 5px; }

        .game-board {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            margin-top: 10px;
            position: relative;
        }

        .column {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 60px;
            /* Allow vertical dragging visual */
            cursor: grab;
            position: relative;
        }

        .tile {
            width: 60px;
            height: 60px;
            background: var(--tile-bg);
            border-radius: 8px;
            color: var(--text-color);
            font-size: 32px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            transition: transform 0.2s, background-color 0.2s, opacity 0.3s;
            user-select: none;
        }

        .tile.matched {
            background-color: var(--highlight);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--highlight);
            z-index: 10;
        }
        
        .tile.falling {
            transition: transform 0.3s cubic-bezier(0.5, 0, 0.5, 1);
        }

        /* Dragging state */
        .column.dragging { cursor: grabbing; }

        .controls {
            margin-top: 20px;
            text-align: center;
            font-size: 14px;
            color: #bdc3c7;
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>WORD BASH</h1>
        <div class="score">SCORE: <span id="scoreVal">0</span></div>
    </div>

    <div class="game-board" id="board">
        <!-- Columns generated by JS -->
    </div>

    <div class="controls">
        <p>Drag columns vertically to form words across.</p>
        <p>4-letter words only.</p>
    </div>

    <script>
        // Config
        const COLS = 4;
        const ROWS = 6;
        const TILE_SIZE = 68; // 60px + 8px gap
        
        // Dictionary (Expanded for demo)
        const COMMON_WORDS = [
            "WORD", "GAME", "PLAY", "COOL", "BASH", "GOOD", "LOVE", "HATE", 
            "TIME", "LIFE", "WORK", "HARD", "EASY", "LUCK", "SLOT", "SPIN",
            "CATS", "DOGS", "FISH", "BIRD", "BLUE", "PINK", "GOLD", "READ",
            "BOOK", "COOK", "LOOK", "TOOK", "MAKE", "CAKE", "LAKE", "FAKE",
            "TEAM", "BEAN", "MEAN", "LEAN", "CODE", "MODE", "NODE", "RIDE",
            "DATA", "BETA", "META", "ACID", "GRID", "IRON", "LION", "NEON",
            "ZINC", "ATOM", "MOLE", "CELL", "GENE", "GERM", "SEED", "TREE",
            "LEAF", "ROOT", "STEM", "ROSE", "LILY", "CORN", "RICE", "FOOD",
            "MEAT", "BEEF", "PORK", "LAMB", "FISH", "MILK", "SOUP", "SODA",
            "SALT", "SOUR", "SWEET", "COLD", "WARM", "HOT", "FIRE", "ICE",
            "RAIN", "SNOW", "WIND", "STORM", "HAIL", "MIST", "FOG", "DEW",
            "SAND", "DUST", "MUD", "CLAY", "ROCK", "STONE", "HILL", "MTN",
            "SEA", "BAY", "GULF", "COVE", "PORT", "PIER", "DOCK", "SHIP",
            "BOAT", "SAIL", "MAST", "HULL", "DECK", "CREW", "CAPT", "MATE"
        ];
        const DICT = new Set(COMMON_WORDS);
        const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        
        // State
        let grid = []; // grid[col][row] -> char
        let score = 0;
        let isProcessing = false;

        const boardEl = document.getElementById('board');
        const scoreEl = document.getElementById('scoreVal');

        // Init
        function init() {
            // Create DOM Columns
            for (let c = 0; c < COLS; c++) {
                const colEl = document.createElement('div');
                colEl.className = 'column';
                colEl.id = `col-${c}`;
                
                // Add drag listeners
                setupDrag(colEl, c);

                grid[c] = [];
                for (let r = 0; r < ROWS; r++) {
                    const char = getRandomChar();
                    grid[c][r] = char;
                    const tile = createTile(char);
                    colEl.appendChild(tile);
                }
                boardEl.appendChild(colEl);
            }
            checkMatches(); // Initial check
        }

        function createTile(char) {
            const div = document.createElement('div');
            div.className = 'tile';
            div.innerText = char;
            return div;
        }

        function getRandomChar() {
            // Weighted random could be better
            return ALPHABET[Math.floor(Math.random() * ALPHABET.length)];
        }

        // Drag Logic
        function setupDrag(colEl, colIndex) {
            let startY = 0;
            let currentTranslateY = 0;
            let isDragging = false;

            const onStart = (e) => {
                if (isProcessing) return;
                isDragging = true;
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                colEl.classList.add('dragging');
                colEl.style.transition = 'none';
            };

            const onMove = (e) => {
                if (!isDragging) return;
                const y = e.touches ? e.touches[0].clientY : e.clientY;
                const delta = y - startY;
                currentTranslateY = delta;
                
                // Visual feedback (limit drag to 1 tile distance for feel)
                colEl.style.transform = `translateY(${delta}px)`;
            };

            const onEnd = () => {
                if (!isDragging) return;
                isDragging = false;
                colEl.classList.remove('dragging');
                colEl.style.transition = 'transform 0.2s ease-out';
                
                // Determine snap
                if (Math.abs(currentTranslateY) > TILE_SIZE / 2) {
                    if (currentTranslateY > 0) {
                        shiftColumnDown(colIndex);
                    } else {
                        shiftColumnUp(colIndex);
                    }
                }
                
                // Reset visual transform
                colEl.style.transform = `translateY(0)`;
                currentTranslateY = 0;
            };

            colEl.addEventListener('mousedown', onStart);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onEnd);
            
            colEl.addEventListener('touchstart', onStart);
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', onEnd);
        }

        // Logic: Shift Column
        function shiftColumnDown(c) {
            // Move last item to top (Rotate) or Generate new?
            // "Slot machine" usually rotates. "Falling block" generates new.
            // Let's Rotate for now to keep board full easily, or Generate new for difficulty.
            // Let's Generate New on Top, Remove Bottom.
            
            const colEl = document.getElementById(`col-${c}`);
            
            // Logic Update
            grid[c].pop(); // remove last
            const newChar = getRandomChar();
            grid[c].unshift(newChar); // add new to top
            
            // DOM Update
            colEl.lastElementChild.remove();
            const newTile = createTile(newChar);
            // newTile.style.height = '0'; // Animation prep
            colEl.prepend(newTile);
            
            // Check
            setTimeout(checkMatches, 250);
        }

        function shiftColumnUp(c) {
            const colEl = document.getElementById(`col-${c}`);
            
            // Logic
            grid[c].shift(); // remove first
            const newChar = getRandomChar();
            grid[c].push(newChar); // add to bottom
            
            // DOM
            colEl.firstElementChild.remove();
            colEl.appendChild(createTile(newChar));
            
            setTimeout(checkMatches, 250);
        }

        // Match Logic
        function checkMatches() {
            if (isProcessing) return;
            isProcessing = true;
            
            let matchedCoords = new Set(); // "c,r" strings
            let matchedWords = [];

            // Check Rows
            for (let r = 0; r < ROWS; r++) {
                let word = "";
                for (let c = 0; c < COLS; c++) {
                    word += grid[c][r];
                }
                
                if (DICT.has(word)) {
                    matchedWords.push(word);
                    for (let c = 0; c < COLS; c++) matchedCoords.add(`${c},${r}`);
                }
            }

            if (matchedCoords.size > 0) {
                // Highlight
                matchedCoords.forEach(coord => {
                    const [c, r] = coord.split(',').map(Number);
                    const tile = document.getElementById(`col-${c}`).children[r];
                    tile.classList.add('matched');
                });
                
                score += matchedWords.length * 100;
                scoreEl.innerText = score;

                // Eliminate and Fall after delay
                setTimeout(() => {
                    eliminateAndRefill(matchedCoords);
                }, 800);
            } else {
                isProcessing = false;
            }
        }

        function eliminateAndRefill(matchedCoords) {
            // Organize matches by column
            // For each column, find which rows matched, remove them, add new ones at top
            
            // This is tricky with DOM nodes index.
            // Safest way: Re-render columns that changed?
            // Or manipulate DOM carefully.
            
            for (let c = 0; c < COLS; c++) {
                const colEl = document.getElementById(`col-${c}`);
                const rowsToRemove = [];
                
                for (let r = 0; r < ROWS; r++) {
                    if (matchedCoords.has(`${c},${r}`)) {
                        rowsToRemove.push(r);
                    }
                }
                
                if (rowsToRemove.length > 0) {
                    // Update Grid Logic: remove indices
                    // Filter out matched chars from this column
                    const newColChars = grid[c].filter((val, idx) => !matchedCoords.has(`${c},${idx}`));
                    
                    // Add new random chars to top to fill back to ROWS length
                    const missingCount = ROWS - newColChars.length;
                    for(let k=0; k<missingCount; k++) {
                        newColChars.unshift(getRandomChar());
                    }
                    grid[c] = newColChars;
                    
                    // Update DOM completely for this column to be safe and simple
                    colEl.innerHTML = '';
                    grid[c].forEach(char => {
                        colEl.appendChild(createTile(char));
                    });
                }
            }
            
            // Check again for cascading matches
            setTimeout(() => {
                isProcessing = false; // Release lock for next check
                checkMatches();
            }, 300);
        }

        init();

    </script>
</body>
</html>