<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Planet Demo</title>
    <link rel="icon" href="../favicon.png" type="image/png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Space Background: Black to Deep Galaxy Blue */
            background: linear-gradient(to top, #000000 0%, #191970 100%);
        }

        #dormLabel {
            position: absolute;
            display: none !important;
            /* Force hide */
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.75);
            padding: 8px 12px;
            border-radius: 20px;
            pointer-events: none;
            z-index: 20;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            /* Center bottom anchor */
        }

        #dormLabel .icon {
            /* font-size: 20px; OLD EMOJI STYLE - Overridden by custom structure */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }

        .follower-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .follower-icon .head {
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            margin-bottom: -2px;
            /* Slight overlap */
            position: relative;
            z-index: 2;
        }

        .follower-icon .body {
            width: 18px;
            height: 10px;
            background: white;
            border-radius: 10px 10px 0 0;
            /* Semi-circle top */
        }

        #dormLabel .text {
            color: #fff;
            font-family: 'Inter', sans-serif;
            font-weight: 800;
            font-size: 18px;
        }

        /* Dorm Health Bar UI */
        #dormHealthUI {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10000;
            display: none !important;
            /* Force hide */
            flex-direction: column;
            gap: 4px;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.5));
        }

        #dormHealthUI .label {
            color: white;
            font-family: 'Inter', sans-serif;
            font-weight: 900;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #dormHealthUI .bar-bg {
            width: 300px;
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        #dormHealthUI .bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff416c, #ff4b2b);
            transition: width 0.3s ease-out;
            box-shadow: 0 0 15px rgba(255, 75, 43, 0.6);
        }

        #dormHealthUI .task-msg {
            color: #ffd700;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 600;
            margin-top: 4px;
        }

        /* Roguelike Upgrade UI */
        #rogueUpgradeUI {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 500000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', sans-serif;
            color: white;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Player Health Bar UI */
        #playerHealthUI {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.5));
        }

        #playerHealthUI .label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 2;
            color: white;
            font-family: 'Inter', sans-serif;
            font-weight: 900;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
        }

        #playerHealthUI .bar-bg {
            width: 300px;
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        /* Player XP Bar UI */
        #playerExpUI {
            position: fixed;
            bottom: 52px;
            /* Above health bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            filter: drop-shadow(0 0 15px rgba(0, 170, 255, 0.3));
        }

        #playerExpUI .bar-bg {
            width: 300px;
            height: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            overflow: visible;
            position: relative;
        }

        #playerExpFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00aaff, #00ffff);
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.8);
            border-radius: 4px;
            transition: width 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #playerExpUI .level-tag {
            position: absolute;
            left: 0;
            top: -18px;
            color: #00aaff;
            font-family: 'Inter', sans-serif;
            font-weight: 900;
            font-size: 13px;
            text-shadow: 0 0 8px rgba(0, 170, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Floating XP Text */
        .xp-text {
            position: fixed;
            color: #00ffff;
            font-family: 'Inter', sans-serif;
            font-weight: 900;
            font-size: 20px;
            pointer-events: none;
            z-index: 10002;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            animation: float-up 1s ease-out forwards;
        }

        @keyframes float-up {
            0% {
                transform: translate(-50%, 0);
                opacity: 0;
            }

            20% {
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -60px);
                opacity: 0;
            }
        }

        /* Damage Numbers */
        .damage-text {
            position: fixed;
            pointer-events: none;
            z-index: 10003;
            font-family: 'Inter', sans-serif;
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            animation: damage-float 0.8s ease-out forwards;
        }

        .damage-player {
            color: #cc88ff;
        }

        /* Purple for player/follower attacked */
        .damage-enemy {
            color: #ffffff;
        }

        /* White for enemies attacked */
        .damage-crit {
            color: #ff3333;
            text-shadow: 0 0 8px rgba(255, 0, 0, 0.8);
        }

        /* Red for crits */

        /* Level Up Message */
        #levelUpMsg {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-family: 'Inter', sans-serif;
            font-weight: 900;
            font-size: 60px;
            letter-spacing: 10px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 1);
            z-index: 11000;
            pointer-events: none;
            display: none;
            white-space: nowrap;
            text-transform: uppercase;
        }

        @keyframes damage-float {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            20% {
                transform: scale(1.1);
                opacity: 1;
            }

            40% {
                transform: scale(1.0);
            }

            100% {
                transform: translateY(-40px);
                opacity: 0;
            }
        }

        #playerExpUI .bar-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ffeb3b, #fbc02d);
            transition: width 0.3s ease-out;
            box-shadow: 0 0 10px rgba(251, 192, 45, 0.6);
        }

        /* Enemy Indicators */
        .enemy-arrow-indicator {
            position: fixed;
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 20px solid #ff3333;
            z-index: 10001;
            pointer-events: none;
            display: none;
            filter: drop-shadow(0 0 4px red);
            transform-origin: 50% 50%;
        }

        #playerHealthUI .bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #41ff6c, #2bff4b);
            /* Green for Player */
            transition: width 0.3s ease-out;
            box-shadow: 0 0 15px rgba(43, 255, 75, 0.6);
        }

        #rogueUpgradeUI h2 {
            font-size: 32px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: rgba(255, 255, 255, 0.8);
        }

        .rogue-card-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            max-width: 90vw;
        }

        /* Mobile Portrait Optimization */
        @media (max-width: 768px) and (orientation: portrait) {
            #rogueUpgradeUI {
                padding: 10px 0;
            }

            #rogueUpgradeUI h2 {
                font-size: 18px;
                margin-bottom: 8px;
                margin-top: 0;
            }

            .rogue-card-container {
                flex-direction: column;
                gap: 8px;
                max-width: 85vw;
            }

            .rogue-card {
                width: 100%;
                height: auto;
                min-height: 60px;
                padding: 6px 10px;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                text-align: center;
            }

            .rogue-card .icon {
                display: none;
            }

            .rogue-card .title {
                font-size: 13px;
                margin-bottom: 2px;
                line-height: 1.2;
            }

            .rogue-card .desc {
                font-size: 10px;
                line-height: 1.2;
                margin: 0;
            }

            .rogue-card .title {
                margin-bottom: 0px;
            }
        }

        .rogue-card {
            width: 200px;
            height: auto;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
        }

        .rogue-card:hover {
            transform: scale(1.1) translateY(-10px);
            border-color: #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.05));
        }

        .rogue-card .icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .rogue-card .title {
            font-weight: 800;
            font-size: 15px;
            margin-bottom: 2px;
            color: #ffd700;
        }

        .rogue-card .desc {
            font-size: 14px;
            color: #ccc;
        }

        #pop-hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            padding: 8px 16px;
            border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10001;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .pop-item {
            width: 14px;
            height: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0.3;
            /* Empty state */
            transition: opacity 0.3s ease;
        }

        .pop-item.filled {
            opacity: 1;
        }

        .pop-item .follower-icon .head {
            background: white;
            border: 1.5px solid white;
            /* Outline feel if empty? No, use classes */
        }

        .pop-item .follower-icon .body {
            background: white;
            border: 1.5px solid white;
        }

        .pop-item:not(.filled) .follower-icon .head,
        .pop-item:not(.filled) .follower-icon .body {
            background: transparent;
        }
    </style>
    <!-- Load Three.js from CDN (UMD version for file:// compatibility) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post-Processing Dependencies (r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/shaders/BokehShader.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/BokehPass.js"></script>
</head>

<body>
    <!-- Duplicate HUD Elements Removed -->

    <!-- Enemy Arrow Indicators -->
    <div id="enemyArrow1" class="enemy-arrow-indicator"></div>
    <div id="enemyArrow2" class="enemy-arrow-indicator"></div>

    <!-- ROGUE UPGRADE SCREEN -->

    <div id="rogueUpgradeUI">
        <h2>Choose Your Blessing</h2>
        <div class="rogue-card-container" id="rogueCardOptions">
            <!-- Cards injected here -->
        </div>
    </div>
    <!-- LOADING SCREEN -->

    <div id="loading-overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #ffffff; z-index: 100000; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: 'Arial', sans-serif;">
        <img src="../index.html/Photo/TofuSoupBlack.png" alt="TofuSoup"
            style="max-width: 80%; max-height: 200px; width: auto; height: auto; margin-bottom: 30px; display: block;">
        <div
            style="width: 240px; height: 24px; border: 3px solid black; border-radius: 20px; padding: 3px; box-sizing: border-box;">
            <div id="loading-bar"
                style="width: 0%; height: 100%; background: black; border-radius: 12px; transition: width 0.05s linear;">
            </div>
        </div>
    </div>
    <!-- GAME OVER SCREEN -->
    <div id="game-over-overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 200000; display: none; flex-direction: column; justify-content: center; align-items: center; font-family: 'Inter', sans-serif; opacity: 0; transition: opacity 2s;">
        <h1 style="color: red; font-size: 80px; font-weight: 900; letter-spacing: 10px; margin: 0;">GAME OVER</h1>
        <p style="color: #666; font-size: 20px; text-transform: uppercase; margin-top: 20px;">The Dormitory has been
            destroyed</p>
        <div id="game-over-restart-msg"
            style="color: #444; font-size: 16px; margin-top: 60px; opacity: 0; transition: opacity 1s;">CLICK ANYWHERE
            OR PRESS ANY KEY TO RESTART</div>
    </div>

    <!-- WAVE TRANSITION OVERLAY -->
    <div id="waveTransitionOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; pointer-events: none; opacity: 0; transition: opacity 2.0s; z-index: 150000; display: flex; justify-content: center; align-items: center;">
        <div id="waveText"
            style="color: white; font-family: 'Inter', sans-serif; font-size: 60px; font-weight: 900; letter-spacing: 8px; text-transform: uppercase;">
            DAY 1
        </div>
    </div>
    <script> (function () {
            const bar = document.getElementById('loading-bar');
            const screen = document.getElementById('loading-overlay');
            let p = 0;

            const t = setInterval(() => {
                p += Math.random() * 2 + 1;
                if (p > 100) p = 100;
                bar.style.width = p + '%';

                if (p >= 100) {
                    clearInterval(t);

                    setTimeout(() => {
                        screen.style.transition = 'opacity 0.6s ease';
                        screen.style.opacity = '0';
                        setTimeout(() => screen.remove(), 600);
                    }

                        , 200);
                }
            }

                , 30);
        })();
    </script>

    <!-- Dormitory Label (Floating UI) -->
    <div id="dormLabel"></div>

    <!-- Population HUD -->
    <div id="pop-hud">
        <!-- Icons populated by JS -->
    </div>

    <div id="waveInfoUI"
        style="position: fixed; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px); padding: 8px 16px; border-radius: 20px; border: 2px solid rgba(255, 50, 50, 0.4); color: #ff6b6b; font-family: 'Inter', sans-serif; font-weight: 800; font-size: 16px; z-index: 10001; display: none; text-transform: uppercase; align-items: center; gap: 8px;">
        <span>💀</span>
        <span>ENEMIES:</span>
        <span id="enemyCountText" style="color: white; font-size: 20px;">0</span>
    </div>

    <div id="playerExpUI">
        <div class="level-tag">LEVEL 1</div>
        <div class="bar-bg">
            <div id="playerExpFill"></div>
        </div>
    </div>
    <div id="levelUpMsg">LEVEL UP!</div>
    <div id="playerHealthUI">
        <div class="bar-bg">
            <div id="playerHealthFill" class="bar-fill"></div>
            <div class="label" id="playerHealthLabel">HP</div>
        </div>
    </div>
    <div style="position: absolute; top: 20px; right: 20px; z-index: 9999; pointer-events: none;"> <a
            href="../index.html/index.html"
            style="color: white; text-decoration: none; font-size: 14px; font-weight: bold; font-family: 'Arial', sans-serif; text-shadow: 0 2px 4px rgba(0,0,0,0.5); pointer-events: auto;">tofusoup.cc</a>
    </div>
    <script>
        // --- 0. Localization System ---
        const translations = {
            en: {
                loading: "LOADING...",
                gameOver: "GAME OVER",
                dormDestroyed: "The Dormitory has been destroyed",
                restartMsg: "CLICK ANYWHERE OR PRESS ANY KEY TO RESTART",
                chooseBlessing: "CHOOSE YOUR BLESSING",
                enemies: "ENEMIES:",
                playerHealth: "PLAYER HEALTH",
                day: "DAY {0}",
                dayCompleted: "DAY {0} COMPLETED",
                // Rogue Upgrades
                popTitle: "+10% Population",
                popDesc: "Increase follower capacity by 10%",
                speedTitle: "+10% Move Speed",
                speedDesc: "Followers move 10% faster",
                attackTitle: "+10% Attack",
                attackDesc: "Increase attack damage by 10%",
                freqTitle: "+10% Attack Freq",
                freqDesc: "Increase attack speed by 10%",
                critTitle: "+5% Crit Rate",
                critDesc: "5% chance to deal 150% damage",
                defTitle: "+10% Defense",
                defDesc: "Reduce damage taken by 10%",
                expTitle: "+10% XP Gain",
                expDesc: "Increase experience gained by 10%",
                hpTitle: "+10% Max HP",
                hpDesc: "Increase Max HP by 10%",
                // Console messages
                bearSpawned: "Bear spawned near player!",
                bearJump: "Bear initiating jump attack! (Distance: {0}m)",
                bearLand: "Bear landed!",
                playerDodge: "Player dodged bear slam! (Height: {0}m)",
                bearHitPlayer: "Bear slam hit player! HP: {0}/{1}",
                bearHitFollowers: "Bear slam hit {0} follower(s)!",
                waveStart: "Starting Wave {0}: {1} Wolves, {2} Bears",
                critHit: "CRITICAL HIT!",
                hitLog: "[{0}] Follower Hit {1}: Damage={2}, TargetHP={3}"
            },
            zh: {
                loading: "加载中...",
                gameOver: "游戏结束",
                dormDestroyed: "大本营已被摧毁",
                restartMsg: "点击任意位置或按任意键重新开始",
                chooseBlessing: "选择你的祝福",
                enemies: "敌人：",
                playerHealth: "玩家生命",
                day: "第 {0} 天",
                dayCompleted: "第 {0} 天已结束",
                // Rogue Upgrades
                popTitle: "+10% 人口上限",
                popDesc: "增加 10% 的随从容量",
                speedTitle: "+10% 移动速度",
                speedDesc: "随从移动速度增加 10%",
                attackTitle: "+10% 攻击力",
                attackDesc: "增加 10% 的攻击伤害",
                freqTitle: "+10% 攻击频率",
                freqDesc: "增加 10% 的攻击速度",
                critTitle: "+5% 暴击率",
                critDesc: "5% 概率造成 150% 伤害",
                defTitle: "+10% 防御力",
                defDesc: "减少 10% 受到的伤害",
                expTitle: "+10% 经验获取",
                expDesc: "增加 10% 的经验获取量",
                hpTitle: "+10% 最大生命",
                hpDesc: "增加 10% 的最大生命值",
                // Console messages
                bearSpawned: "熊在玩家附近出现了！",
                bearJump: "熊发动了弹跳攻击！（距离：{0}米）",
                bearLand: "熊落地了！",
                playerDodge: "玩家躲开了震击！（高度：{0}米）",
                bearHitPlayer: "熊的震击命中了玩家！HP: {0}/{1}",
                bearHitFollowers: "熊的震击命中了 {0} 个随从！",
                waveStart: "开始第 {0} 天：{1} 狼，{2} 熊",
                critHit: "暴击！",
                hitLog: "[{0}] 随从击中了 {1}: 伤害={2}, 目标HP={3}"
            }
        };

        const userLang = (navigator.language || navigator.userLanguage || "en").startsWith('zh') ? 'zh' : 'en';
        function t(key, ...args) {
            let str = (translations[userLang] && translations[userLang][key]) ? translations[userLang][key] : (translations['en'][key] || key);
            args.forEach((arg, i) => {
                str = str.replace(`{${i}}`, arg);
            });
            return str;
        }

        // Apply translations to static HTML
        window.addEventListener('DOMContentLoaded', () => {
            const elUpgTitle = document.querySelector('#rogueUpgradeUI h2');
            if (elUpgTitle) elUpgTitle.textContent = t('chooseBlessing');

            const elGameOverTitle = document.querySelector('#game-over-overlay h1');
            if (elGameOverTitle) elGameOverTitle.textContent = t('gameOver');

            const elGameOverDesc = document.querySelector('#game-over-overlay p');
            if (elGameOverDesc) elGameOverDesc.textContent = t('dormDestroyed');

            const elRestartMsg = document.getElementById('game-over-restart-msg');
            if (elRestartMsg) elRestartMsg.textContent = t('restartMsg');

            const elEnemiesLabel = document.querySelector('#waveInfoUI span:nth-child(2)');
            if (elEnemiesLabel) elEnemiesLabel.textContent = t('enemies');


        });

        // --- 1. Noise Implementation ---
        const p = [151,
            160,
            137,
            91,
            90,
            15,
            131,
            13,
            201,
            95,
            96,
            53,
            194,
            233,
            7,
            225,
            140,
            36,
            103,
            30,
            69,
            142,
            8,
            99,
            37,
            240,
            21,
            10,
            23,
            190,
            6,
            148,
            247,
            120,
            234,
            75,
            0,
            26,
            197,
            62,
            94,
            252,
            219,
            203,
            117,
            35,
            11,
            32,
            57,
            177,
            33,
            88,
            237,
            149,
            56,
            87,
            174,
            20,
            125,
            136,
            171,
            168,
            68,
            175,
            74,
            165,
            71,
            134,
            139,
            48,
            27,
            166,
            77,
            146,
            158,
            231,
            83,
            111,
            229,
            122,
            60,
            211,
            133,
            230,
            220,
            105,
            92,
            41,
            55,
            46,
            245,
            40,
            244,
            102,
            143,
            54,
            65,
            25,
            63,
            161,
            1,
            216,
            80,
            73,
            209,
            76,
            132,
            187,
            208,
            89,
            18,
            169,
            200,
            196,
            135,
            130,
            116,
            188,
            159,
            86,
            164,
            100,
            109,
            198,
            173,
            186,
            3,
            64,
            52,
            217,
            226,
            250,
            124,
            123,
            5,
            202,
            38,
            147,
            118,
            126,
            255,
            82,
            85,
            212,
            207,
            206,
            59,
            227,
            47,
            16,
            58,
            17,
            182,
            189,
            28,
            42,
            223,
            183,
            170,
            213,
            119,
            248,
            152,
            2,
            44,
            154,
            163,
            70,
            221,
            153,
            101,
            155,
            167,
            43,
            172,
            9,
            129,
            22,
            39,
            253,
            19,
            98,
            108,
            110,
            79,
            113,
            224,
            232,
            178,
            185,
            112,
            104,
            218,
            246,
            97,
            228,
            251,
            34,
            242,
            193,
            238,
            210,
            144,
            12,
            191,
            179,
            162,
            241,
            81,
            51,
            145,
            235,
            249,
            14,
            239,
            107,
            49,
            192,
            214,
            31,
            181,
            199,
            106,
            157,
            184,
            84,
            204,
            176,
            115,
            121,
            50,
            45,
            127,
            4,
            150,
            254,
            138,
            236,
            205,
            93,
            222,
            114,
            67,
            29,
            24,
            72,
            243,
            141,
            128,
            195,
            78,
            66,
            215,
            61,
            156,
            180];
        const perm = new Uint8Array(512);
        for (let i = 0; i < 512; i++) perm[i] = p[i & 255];

        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        function lerp(t, a, b) {
            return a + t * (b - a);
        }

        function grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        function noise(x, y, z) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            const u = fade(x);
            const v = fade(y);
            const w = fade(z);
            const A = perm[X] + Y,
                AA = perm[A] + Z,
                AB = perm[A + 1] + Z,
                B = perm[X + 1] + Y,
                BA = perm[B] + Z,
                BB = perm[B + 1] + Z;
            return lerp(w, lerp(v, lerp(u, grad(perm[AA], x, y, z),
                grad(perm[BA], x - 1, y, z)),
                lerp(u, grad(perm[AB], x, y - 1, z),
                    grad(perm[BB], x - 1, y - 1, z))),
                lerp(v, lerp(u, grad(perm[AA + 1], x, y, z - 1),
                    grad(perm[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(perm[AB + 1], x, y - 1, z - 1),
                        grad(perm[BB + 1], x - 1, y - 1, z - 1))));
        }

        // --- 2. Scene Setup ---
        const scene = new THREE.Scene();
        // scene.background = new THREE.Color(0x87CEEB); // Removed for CSS Gradient
        // Match Fog to the bottom color of the gradient (#000000 - Space)
        scene.fog = new THREE.Fog(0x000000, 20, 150);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Enable alpha to let CSS background show through
        const renderer = new THREE.WebGLRenderer({
            antialias: true, alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 3. Planet Generation ---
        const planetRadius = 40;
        const geometry = new THREE.SphereGeometry(planetRadius, 128, 128);

        const count = geometry.attributes.position.count;
        const positions = geometry.attributes.position;
        const v3 = new THREE.Vector3();

        // Deform Geometry on CPU (so physics raycaster matches visual)
        for (let i = 0; i < count; i++) {
            v3.fromBufferAttribute(positions, i);
            const dir = v3.clone().normalize();

            // 1. Structure Noise (Large features)
            // Smoother terrain: base freq 1.0
            let n = noise(dir.x * 1.0, dir.y * 1.0, dir.z * 1.0);

            // Reduced detail noise amplitude (0.25) and frequency (3.0)
            n += 0.25 * noise(dir.x * 3.0, dir.y * 3.0, dir.z * 3.0);

            // Terrain Logic
            // Apply Power Curve for "Flat Plains, High Peaks"
            // Use Math.pow(abs(n), 2.5) * sign(n)
            const power = 3.0;
            const sign = n < 0 ? -1 : 1;
            let shapedN = sign * Math.pow(Math.abs(n), power);

            // Scale up significantly because pow(x, 3) makes values much smaller
            const heightScale = 30.0;
            let h = shapedN * heightScale;

            // --- ROAD GENERATION START ---
            // Normalized Y is roughly dir.y
            // Road Width definition
            const roadHalfWidth = 2.0; // Half width in world units approx

            // Distance from equator on surface ~= planetRadius * abs(dir.y) (approx)
            // Arc length = R * angle. angle = asin(y). linear approx y works for small y.
            const distFromEquator = planetRadius * Math.abs(dir.y);

            const roadBandWidth = 3.0; // The flat area width (Narrowed to match)
            const roadTransition = 3.0; // The blend area

            // If within road band, flatten to constant height
            if (distFromEquator < (roadBandWidth + roadTransition)) {
                // Road Height: slightly above sea level (0.0) 
                // Sea Level is -1.0. Let's make it 0.5 for a nice causeway.
                const roadHeight = 0.5;

                let t = 0.0;

                if (distFromEquator < roadBandWidth) {
                    t = 1.0;
                }

                else {
                    // Linear transition? Or smoothstep.
                    // normalized edge distance: 0 (at band) to 1 (at band+trans)
                    let edgeDist = (distFromEquator - roadBandWidth) / roadTransition;
                    t = 1.0 - (edgeDist * edgeDist * (3.0 - 2.0 * edgeDist)); // smoothstep logic manually
                }

                // Blend h towards roadHeight
                // h = h + (roadHeight - h) * t;
                h = h * (1.0 - t) + roadHeight * t;
            }

            // --- ROAD GENERATION END ---

            // Flatten Water removed, just natural terrain
            let finalRadius = planetRadius + h;

            // --- DEEP TERRAIN ADJUSTMENT (User Request) ---
            // If terrain is below 80% radius ( < 32.0 ), raise it to random 80-90% (32.0 - 36.0)
            if (finalRadius < planetRadius * 0.8) {
                // FLATTENING FIX (User Request): 
                // Reduced frequency (8.0 -> 1.5) and amplitude (0.1 -> 0.05) for smooth floor
                // Use dir scaled up significantly
                let rNoise = noise(dir.x * 1.5, dir.y * 1.5, dir.z * 1.5);
                // Map from -1..1 (approx) to 0..1 magnitude
                // Math.abs might create creases, let's use 0.5 * (n + 1)
                let normNoise = 0.5 * (rNoise + 1.0);

                // Map to 80% - 90% range -> Reduced to 82.5% - 87.5%
                let factor = 0.825 + normNoise * 0.05;
                finalRadius = planetRadius * factor;

                // Recalculate h for consistency if needed elsewhere (though mostly used for position)
                h = finalRadius - planetRadius;
            }

            dir.multiplyScalar(finalRadius);
            positions.setXYZ(i, dir.x, dir.y, dir.z);
        }

        geometry.computeVertexNormals();
        geometry.attributes.position.needsUpdate = true;

        // Procedural Shader for sharp details
        const material = new THREE.ShaderMaterial({
            vertexShader: ` varying vec3 vPosition;
            varying vec3 vNormal;

            void main() {
                vPosition=position; // Local position (includes CPU deformation)
                vNormal=normal;
                gl_Position=projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }

            `,
            fragmentShader: ` varying vec3 vPosition;
            varying vec3 vNormal;
            uniform float time;


            // Simple pseudo-random for noise
            float noise(vec3 p) {
                return fract(sin(dot(p, vec3(12.9898, 78.233, 128.85))) * 43758.5453);
            }

            // Smooth mixing function
            vec3 softMix(vec3 a, vec3 b, float val, float edge0, float edge1) {
                float t=smoothstep(edge0, edge1, val);
                return mix(a, b, t);
            }

            void main() {
                // Calculate height relative to base radius
                float r=length(vPosition);
                float baseRadius=40.0;
                float h=r - baseRadius;

                // Bolder, Saturated Colors
                vec3 cDeepWater=vec3(0.05, 0.2, 0.4); // Darker Deep Blue (50% darker)
                vec3 cWater=vec3(0.2, 0.7, 0.95); // Lighter Cyan (was 0.0, 0.8, 1.0)
                vec3 cWetSand=vec3(0.8, 0.6, 0.3); // Darker/Wet Sand
                vec3 cSand=vec3(1.0, 0.85, 0.5); // Bright Sand
                vec3 cGrass=vec3(0.4, 0.8, 0.2); // Vibrant Light Green
                vec3 cForest=vec3(0.1, 0.5, 0.15); // Rich Green (not black)
                vec3 cRock=vec3(0.5, 0.5, 0.55); // Neutral Grey
                vec3 cSnow=vec3(0.9, 0.95, 1.0); // White with hint of blue

                // Noise grain for texture
                float grain=noise(vPosition * 8.0) * 0.08;
                float sh=h + grain; // Noisy height for terrain transitions

                // Adjust Sea Level for new scale
                float seaLevel=-1.0;

                // 2. Land Layer (Restored)
                // Start with Deep Water Color (Darker)
                vec3 landCol=cDeepWater;

                // Deep Water -> Wet Sand
                // Expanded Gradient (User Request): -6.0 to +0.5 (Into Shallow Water)
                landCol=softMix(landCol, cWetSand, sh, seaLevel - 6.0, seaLevel + 0.5);

                // Wet Sand -> Dry Sand
                // Below seaLevel it is wet, dries as it goes up
                // User Request: Lower it so gradient matches water line.
                // Water Level is -1.0. 
                // Let's transition from -2.0 (Deep Wet) to 0.0 (Dry).
                // Midpoint is -1.0 (Water Line).
                landCol=softMix(landCol, cSand, sh, seaLevel - 1.0, seaLevel + 1.0);

                // Sand -> Grass 
                // EXPANDED GREEN ZONE: Start very close to water
                landCol=softMix(landCol, cGrass, sh, seaLevel + 0.2, seaLevel + 0.8);
                // Grass -> Forest 
                // Smoother/Wider Transition: 0.0 to 12.0 (was -1.5 to 4.0)
                // Eliminates "dead green" block by mixing earlier and longer
                landCol=softMix(landCol, cForest, sh, 0.0, 12.0);
                // Forest -> Rock 
                // Overlap with Forest: 8.0 to 25.0 (was 15.0 to 22.0)
                // Starts fading to rock while still in forest zone
                landCol=softMix(landCol, cRock, sh, 8.0, 25.0);
                // Rock -> Snow 
                // Higher peaks: 20.0 to 32.0 (was 24.0 to 32.0)
                landCol=softMix(landCol, cSnow, sh, 20.0, 32.0);

                // --- ROAD RENDERING ---
                // vPosition.y is distance from equator plane.
                // Flattened area is where abs(vPosition.y) < roadBandWidth approx.
                // Because we deformed the mesh, vPosition reflects that.
                // However, 'vPosition' in FS is interpolated. 
                float distFromEq=abs(vPosition.y);
                const float roadBandW=3.0; // Narrowed by 40% (was 5.0)


                if (distFromEq < roadBandW) {
                    // Soft edge for texture
                    float edgeDist=roadBandW - distFromEq;
                    // Sharpened Road Edge: 0.0 to 0.2 (was 1.0)
                    float roadMix=smoothstep(0.0, 0.2, edgeDist);

                    vec3 cRoad=vec3(0.3, 0.3, 0.3); // Lighter Asphalt (was 0.15)

                    // White Dashed Lines
                    float roadWidth=roadBandW * 2.0;
                    // Center line:
                    // angle = atan(z, x)
                    float angle=atan(vPosition.z, vPosition.x);
                    float dash=sin(angle * 40.0); // Frequency lowered (was 80) -> Larger Gaps

                    // Line thickened by 40% (0.2 -> 0.28)
                    // THEN Narrowed by 30% (0.28 -> 0.2)
                    if (distFromEq < 0.2 && dash > 0.0) {
                        cRoad=vec3(0.9, 0.9, 0.9); // White
                    }

                    landCol=mix(landCol, cRoad, roadMix);
                }

                // --- ROAD END ---



                // --- ROAD END ---


                // --- FOAM REMOVED (User Request) ---


                // 3. Final Color (No Water Mix)
                vec3 finalColor=landCol;

                gl_FragColor=vec4(finalColor, 1.0);
            }

            `,
            uniforms: {
                time: {
                    value: 0.0
                }
            }
        });

        const planet = new THREE.Mesh(geometry, material);
        scene.add(planet);

        // --- 3.5 Water Sphere ---
        const seaLevelRef = -0.5; // Slightly deeper
        const waterGeo = new THREE.SphereGeometry(planetRadius + seaLevelRef, 96, 96);

        const waterMat = new THREE.MeshBasicMaterial({
            color: 0x00ccff, // Cyan-Blue (User Request)
            transparent: true,
            opacity: 0.68,
            side: THREE.FrontSide
        });
        const waterSphere = new THREE.Mesh(waterGeo, waterMat);
        scene.add(waterSphere);

        // Add a directional light so the water shines
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(50, 50, 50);
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
        scene.add(ambientLight);

        // --- 3.6 Star Field ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 3000;
        const starPos = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
            // Spherical distribution to keep away from planet
            // User Request: Much further away to reduce parallax/movement speed
            const r = 1000 + Math.random() * 1500; // Min radius 1000, Max 2500
            const theta = Math.random() * Math.PI * 2; // Azimuth
            const phi = Math.acos(2 * Math.random() - 1); // Polar

            starPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            starPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            starPos[i * 3 + 2] = r * Math.cos(phi);
        }

        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));

        const starMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 5.0
        });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // --- 3.8 Interactive Grass ---
        // --- 3.8 Interactive Grass ---
        const grassCount = 80000;
        // Reduced Size: Wide Base (0.3), tapered by shader
        // Height 1.2 (was 0.8), Translate 0.2 (was 0.3)
        // Original: Base -0.1, Top 0.7
        // New: 1.2 height -> [-0.6, 0.6]. +0.2Y -> [-0.4, 0.8].
        // Result: Deeper underground (-0.4) and taller (+0.8).
        // Height 2.2 (was 1.2) to sink roots deeper and prevent floating
        // Translate -0.3: Bottom at -1.4, Top at 0.8
        const grassGeo = new THREE.PlaneGeometry(0.3, 2.2);
        grassGeo.translate(0, -0.3, 0); // Pivot logic

        const grassMat = new THREE.ShaderMaterial({
            uniforms: {
                time: {
                    value: 0
                }

                ,
                carPos: {
                    value: new THREE.Vector3()
                }

                ,
                cameraPos: {
                    value: new THREE.Vector3()
                }
            }

            ,
            vertexShader: ` uniform float time;
            uniform vec3 carPos;
            attribute vec3 offset;
            attribute vec3 instanceNormal;
            attribute float scale;
            attribute float rot;

            varying vec2 vUv;
            varying float vAltitude; // Pass height to fragment
            varying vec3 vPos; // World position for noise

            // Quaternion rotation utility
            vec3 rotateVector(vec4 q, vec3 v) {
                return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
            }

            vec4 axisAngleToQuaternion(vec3 axis, float angle) {
                float halfAngle=angle * 0.5;
                float s=sin(halfAngle);
                return vec4(axis * s, cos(halfAngle));
            }

            void main() {
                vUv=uv;

                // Calculate Altitude for coloring
                // Planet Radius is 40.0
                vAltitude=length(offset) - 40.0;
                vPos=offset;

                // 1. Base Geometry
                vec3 pos=position;
                pos.y *=scale;
                // Width Logic: CONSTANT WIDTH (for rounded top via Fragment Shader)
                // User Request: Round top (not pointy)
                // We remove the taper here and handle the shape in Fragment Shader.
                pos.x *=(scale * 0.5 + 0.5);

                // Capture length to restore later
                float originalLen=length(pos);

                // --- Wind Sway ---
                // Combine sine waves for random-ish motion
                // Phase depends on world position (offset) so they don't sway together
                float wind=sin(time * 3.0 + offset.x * 0.5) + sin(time * 1.5 + offset.z * 0.5) * 0.5;
                // Apply to top only (uv.y), scaled STRONGER (was 0.05)
                // User Request: Stronger wind feel.
                pos.x +=wind * 0.15 * uv.y;

                // 2. Random Rotation (Y-axis)
                vec4 qRand=axisAngleToQuaternion(vec3(0, 1, 0), rot);
                pos=rotateVector(qRand, pos);

                // 3. Align to Surface Normal
                vec3 up=vec3(0, 1, 0); // Grass local up
                vec3 normal=normalize(instanceNormal);

                // Rotation from Up to Normal
                vec3 axis=cross(up, normal);
                float cosA=dot(up, normal);

                // Simple alignment
                vec4 qAlign=vec4(0, 0, 0, 1);

                if (cosA > -0.99) {
                    qAlign=normalize(vec4(axis, 1.0 + cosA));
                }

                else {
                    qAlign=vec4(1, 0, 0, 0); // Flip
                }

                pos=rotateVector(qAlign, pos);

                // --- 4. Car Interaction ---
                    {
                    vec3 totalPush=vec3(0.0);

                    // Player (Radius 1.4)
                    float dCar=distance(offset, carPos);

                    if (dCar < 1.4) {
                        totalPush +=normalize(offset - carPos) * (1.0 - dCar/1.4);
                    }

                    pos +=totalPush * 1.0 * uv.y;
                }

                // --- Fix Stretching ---
                // Force the bent grass to maintain its original length (relative to its pivot)
                // This naturally lowers the Y as it bends X/Z, preventing the "rubber" look.
                if (originalLen > 0.001) {
                    pos=normalize(pos) * originalLen;
                }

                // 5. Translate
                vec3 worldPos=pos + offset;

                gl_Position=projectionMatrix * viewMatrix * vec4(worldPos, 1.0);
            }

            `,
            fragmentShader: ` varying vec2 vUv;
            varying float vAltitude;
            varying vec3 vPos;

            // Simple pseudo-random for noise (Same as Planet Shader)
            float noise(vec3 p) {
                return fract(sin(dot(p, vec3(12.9898, 78.233, 128.85))) * 43758.5453);
            }

            // Smooth mixing function
            vec3 softMix(vec3 a, vec3 b, float val, float edge0, float edge1) {
                float t=smoothstep(edge0, edge1, val);
                return mix(a, b, t);
            }

            void main() {
                // Simple Alpha Cutoff (Side Margins)
                if (vUv.x < 0.1 || vUv.x > 0.9) discard;
                if (vUv.y < 0.0) discard;

                // ROUNDED TOP LOGIC
                // Aspect ratio correction: Geo is 0.3 x 1.2 (Ratio ~0.25)
                // Effective width in UV is 0.8 (0.1 to 0.9).
                // To get a circle, RadiusY should vary.
                // Let's assume a semi-circle cap at the top 10% (0.9 to 1.0)
                if (vUv.y > 0.9) {
                    float nx=(vUv.x - 0.5) / 0.4; // Map 0.1..0.9 to -1..1
                    float ny=(vUv.y - 0.9) / 0.1; // Map 0.9..1.0 to 0..1
                    if (nx*nx + ny*ny > 1.0) discard;
                }

                // Exact Color Match with Planet Shader
                vec3 cGrass=vec3(0.4, 0.8, 0.2); // Vibrant Light Green
                vec3 cForest=vec3(0.1, 0.5, 0.15); // Rich Green
                vec3 cRock=vec3(0.5, 0.5, 0.55); // Neutral Grey

                // Add noise to altitude just like planet shader
                float grain=noise(vPos * 8.0) * 0.08;
                float sh=vAltitude + grain;

                // Base Color: Grass
                // Gradient: Darker base to Lighter tip
                vec3 cGrassTop=vec3(0.42, 0.82, 0.22); // Very subtle gradient vs base (0.4, 0.8, 0.2)
                // Use pow(vUv.y) to control gradient curve if needed, linear for now
                vec3 col=mix(cGrass, cGrassTop, vUv.y);

                // Transition: Grass -> Forest (Match Planet 0.0 -> 12.0)
                // Start mixing forest at 0.0 (near sea level)
                // Widen range to eliminate "dead green"
                col=softMix(col, cForest, sh, 0.0, 12.0);

                // Transition: Forest -> Rock (Match Planet 8.0 -> 25.0)
                // High altitude grass will blend into the rock color
                col=softMix(col, cRock, sh, 8.0, 25.0);

                gl_FragColor=vec4(col, 1.0);
            }

            `,
            side: THREE.DoubleSide
        });

        const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, grassCount);

        // Populate Grass Instances
        const dummy = new THREE.Object3D();
        const _v3 = new THREE.Vector3();
        const _normal = new THREE.Vector3();

        // Arrays for attributes
        const offsets = new Float32Array(grassCount * 3);
        const normals = new Float32Array(grassCount * 3);
        const scales = new Float32Array(grassCount);
        const rots = new Float32Array(grassCount);

        let grassIdx = 0;

        // Try up to X times to find valid spots
        for (let i = 0; i < grassCount * 3 && grassIdx < grassCount; i++) {
            // Random point on sphere surface
            _v3.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();

            // Re-calculate noise height for this point
            // Re-calculate noise height for this point
            // Copy logic from planet generation loop EXACTLY
            // 1. Structure Noise (Large features)
            // Smoother terrain: base freq 1.0
            let n = noise(_v3.x * 1.0, _v3.y * 1.0, _v3.z * 1.0);
            // Reduced detail noise amplitude (0.25) and frequency (3.0)
            n += 0.25 * noise(_v3.x * 3.0, _v3.y * 3.0, _v3.z * 3.0);

            // Terrain Logic
            // Apply Power Curve for "Flat Plains, High Peaks"
            const power = 3.0;
            const sign = n < 0 ? -1 : 1;
            let shapedN = sign * Math.pow(Math.abs(n), power);

            const heightScale = 30.0;
            let h = shapedN * heightScale;

            // Green Zone Criteria
            const seaLevel = -0.5;

            // Define Road Zone (Must match Planet Generation)
            const distFromEquator = planetRadius * Math.abs(_v3.y);
            // Road Band (3.0)
            // User Request: Grow closer to road.
            // Buffer 0.5 -> Limit 3.5
            const roadZoneLimit = 3.5;
            const isRoad = distFromEquator < roadZoneLimit;

            // --- SYNC HEIGHT WITH ROAD SHADER ---
            // The shader flattens the geometry near the road, but 'h' here is the raw noisy height.
            // We must replicate the shader's height modification so grass sits ON the flattened ground.

            const roadBandWidth = 3.0; // Matches Shader
            const roadTransition = 3.0; // Matches Shader (assumed default)

            if (distFromEquator < (roadBandWidth + roadTransition)) {
                const roadHeight = 0.5; // Matches Shader
                let t = 0.0;

                if (distFromEquator < roadBandWidth) {
                    t = 1.0;
                }

                else {
                    // Smoothstep logic from shader
                    let edgeDist = (distFromEquator - roadBandWidth) / roadTransition;
                    t = 1.0 - (edgeDist * edgeDist * (3.0 - 2.0 * edgeDist));
                }

                // Blend height towards roadHeight
                h = h * (1.0 - t) + roadHeight * t;
            }

            // --- END SYNC ---

            // --- DEEP TERRAIN SYNC (User Request) ---
            // Must match Planet Generation Logic EXACTLY or grass will float/bury
            let finalRadius = planetRadius + h;

            if (finalRadius < planetRadius * 0.8) {
                // FLATTENING FIX (User Request): 
                // Reduced frequency (8.0 -> 1.5) and amplitude (0.1 -> 0.05) for smooth floor
                let rNoise = noise(_v3.x * 1.5, _v3.y * 1.5, _v3.z * 1.5);
                let normNoise = 0.5 * (rNoise + 1.0);
                let factor = 0.825 + normNoise * 0.05; // Range: 0.825 to 0.875
                finalRadius = planetRadius * factor;
                h = finalRadius - planetRadius;
            }

            // --- END DEEP TERRAIN SYNC ---


            // Green Height Range: 
            // -1.0 is water line. 
            // EXPANDED: Spawn closer to water (was 0.5, now -0.2) because green starts earlier
            // 8.0 is start of rock. -> Raised to 24.0 (start of snow/rock transition)
            const isGreenHeight = (h > -0.2) && (h < 24.0);

            // Density Noise REMOVED for Uniform Distribution
            // User Request: Uniformly dense grass (no clumps)
            // let density = noise(_v3.x * 8.0, _v3.y * 8.0, _v3.z * 8.0);

            // Allow if satisfies criteria (removed density check)
            if (!isRoad && isGreenHeight) {
                // Determine Position
                const r = planetRadius + h;
                const pos = _v3.clone().multiplyScalar(r);

                offsets[grassIdx * 3 + 0] = pos.x;
                offsets[grassIdx * 3 + 1] = pos.y;
                offsets[grassIdx * 3 + 2] = pos.z;

                // Normal is direction from center
                normals[grassIdx * 3 + 0] = _v3.x;
                normals[grassIdx * 3 + 1] = _v3.y;
                normals[grassIdx * 3 + 2] = _v3.z;

                // Reverted Size Logic
                scales[grassIdx] = 0.5 + Math.random() * 0.5;
                rots[grassIdx] = Math.random() * Math.PI * 2;

                grassIdx++;
            }
        }

        // --- Bind Attributes (Outside Loop) ---
        grassMesh.geometry.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets, 3));
        grassMesh.geometry.setAttribute('instanceNormal', new THREE.InstancedBufferAttribute(normals, 3));
        grassMesh.geometry.setAttribute('scale', new THREE.InstancedBufferAttribute(scales, 1));
        grassMesh.geometry.setAttribute('rot', new THREE.InstancedBufferAttribute(rots, 1));

        // Fix: User reported invisible grass.
        // InstancedMesh bounding sphere might not be computed correctly for all instances automatically.
        // Disabling frustum culling to ensure it's always rendered.
        grassMesh.frustumCulled = false;

        scene.add(grassMesh);

        // --- 3.9 Additional Vegetation (Trees, Flowers, Mushrooms) ---

        // Helper to merge geometries with baked vertex colors (Support Gradient)
        function createColoredGeometry(parts) {
            let totalVerts = 0;

            const unindexedParts = parts.map(p => ({
                geo: p.geo.toNonIndexed(),
                color: p.color,
                gradient: p.gradient // { from: hex, to: hex }
            }));

            unindexedParts.forEach(p => totalVerts += p.geo.attributes.position.count);

            const positions = new Float32Array(totalVerts * 3);
            const normals = new Float32Array(totalVerts * 3);
            const colors = new Float32Array(totalVerts * 3);
            const uvs = new Float32Array(totalVerts * 2);

            let offset = 0;
            const _col = new THREE.Color();
            const _colStart = new THREE.Color();
            const _colEnd = new THREE.Color();

            unindexedParts.forEach(p => {
                const geo = p.geo;
                const pos = geo.attributes.position;
                const norm = geo.attributes.normal;
                const uv = geo.attributes.uv;
                const count = pos.count;

                let useGradient = false;
                let yMin = 0, yRange = 1;

                if (p.gradient) {
                    useGradient = true;
                    _colStart.setHex(p.gradient.from);
                    _colEnd.setHex(p.gradient.to);

                    geo.computeBoundingBox();
                    yMin = geo.boundingBox.min.y;
                    yRange = geo.boundingBox.max.y - yMin;
                    if (yRange < 0.001) yRange = 1.0;
                }

                else {
                    _col.setHex(p.color);
                }

                for (let i = 0; i < count; i++) {
                    // Position
                    const px = pos.getX(i);
                    const py = pos.getY(i);
                    const pz = pos.getZ(i);

                    positions[(offset + i) * 3 + 0] = px;
                    positions[(offset + i) * 3 + 1] = py;
                    positions[(offset + i) * 3 + 2] = pz;

                    // Color Logic
                    if (useGradient) {
                        // t = 0 (bottom) to 1 (top)
                        let t = (py - yMin) / yRange;
                        // Lerp
                        _col.lerpColors(_colStart, _colEnd, t);
                    }

                    colors[(offset + i) * 3 + 0] = _col.r;
                    colors[(offset + i) * 3 + 1] = _col.g;
                    colors[(offset + i) * 3 + 2] = _col.b;

                    if (norm) {
                        normals[(offset + i) * 3 + 0] = norm.getX(i);
                        normals[(offset + i) * 3 + 1] = norm.getY(i);
                        normals[(offset + i) * 3 + 2] = norm.getZ(i);
                    }

                    if (uv) {
                        uvs[(offset + i) * 2 + 0] = uv.getX(i);
                        uvs[(offset + i) * 2 + 1] = uv.getY(i);
                    }
                }

                offset += count;
                geo.dispose();
            });

            const finalGeo = new THREE.BufferGeometry();
            finalGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            finalGeo.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
            finalGeo.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
            finalGeo.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            return finalGeo;
        }

        // 1. Tree Geometry (Trunk + 2 Cones) with Gradients
        const treeParts = [{
            geo: new THREE.CylinderGeometry(0.2, 0.3, 1.0, 7).translate(0, 0.5, 0), color: 0x5C4033
        }

            , // Trunk (Solid)

        // Base Leaves: Dark Green to Mid Green
        {
            geo: new THREE.ConeGeometry(1.2, 2.0, 7).translate(0, 2.0, 0), gradient: {
                from: 0x004d00, to: 0x228B22
            }
        }

            ,
        // Top Leaves: Mid Green to Lighter Green
        {
            geo: new THREE.ConeGeometry(0.9, 1.5, 7).translate(0, 2.8, 0), gradient: {
                from: 0x228B22, to: 0x66cc44
            }
        }

        ];
        const treeGeo = createColoredGeometry(treeParts);

        // 2. Mushroom Geometry (Stem + Cap)
        const mushParts = [ // Stem: Shortened to 0.35 height, Tapered top to 0.1 to fit inside cap

            {
                geo: new THREE.CylinderGeometry(0.12, 0.1, 0.35, 6).translate(0, 0.175, 0), color: 0xFFF8DC
            }

            ,
            // Cap: Lowered to 0.3 to fully cover stem top
            {
                geo: new THREE.SphereGeometry(0.4, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2).translate(0, 0.3, 0), gradient: {
                    from: 0xFF0000, to: 0x8B0000
                }
            }

        ];
        const mushGeo = createColoredGeometry(mushParts);

        // 3. Flower Geometry (Yellow Heart, White Petals)
        const flowerParts = [{
            geo: new THREE.CylinderGeometry(0.04, 0.04, 0.4, 4).translate(0, 0.2, 0), color: 0x006400
        }

            , // Stem

        {
            geo: new THREE.SphereGeometry(0.12, 4, 4).translate(0, 0.45, 0), color: 0xFFD700
        }

            , // Center (Yellow)

        // Petals as a flat circle/cone
        {
            geo: new THREE.CircleGeometry(0.28, 6).rotateX(-Math.PI / 2).translate(0, 0.42, 0), color: 0xFFFFFF
        }

            // White Petals
        ];
        const flowerGeo = createColoredGeometry(flowerParts);

        // 4. Stone Geometry (Low-poly Dodecahedron, flattened)
        const stoneParts = [ // User Request: Double Size (0.3 -> 0.6)

            {
                geo: new THREE.DodecahedronGeometry(0.6, 0).scale(1.0, 0.6, 1.0).translate(0, 0.3, 0), gradient: {
                    from: 0x505050, to: 0xAAAAAA
                }
            }

        ];
        const stoneGeo = createColoredGeometry(stoneParts);

        // 5. Twig Geometry (Thin, rotated Cylinder)
        const twigParts = [ // Main branch: Thicker & Longer (2x)

            // 0.07->0.14, 0.09->0.18, 0.6->1.2. Translate Y doubled 0.05->0.1.
            {
                geo: new THREE.CylinderGeometry(0.14, 0.18, 1.2, 5).rotateZ(Math.PI / 2.5).translate(0, 0.1, 0), color: 0x5C4033
            }

            ,
            // Side branch: Thicker & Longer (2x)
            // 0.05->0.10, 0.3->0.6. Translate 0.1->0.2.
            {
                geo: new THREE.CylinderGeometry(0.10, 0.10, 0.6, 4).rotateZ(-Math.PI / 3).translate(0.2, 0.1, 0), color: 0x5C4033
            }

        ];
        const twigGeo = createColoredGeometry(twigParts);

        // 6. Bush Geometry (Sphere + Leaves)
        const bushParts = [];

        // Core (Lighter Green: 0x4CA64C) matching leaves
        bushParts.push({
            geo: new THREE.SphereGeometry(1.3, 10, 10).translate(0, 1.0, 0), color: 0x4CA64C
        });

        // Leaves (Round headed, same color 0x4CA64C)
        const _bushDummy = new THREE.Object3D();

        // Increased leaf count (50 -> 150)
        for (let i = 0; i < 150; i++) {
            // Round head: Shorter (0.5) and Thicker (0.3 width)
            const leafGeo = new THREE.SphereGeometry(0.25, 6, 6);
            leafGeo.scale(0.6, 1.0, 0.6);
            leafGeo.translate(0, 0.25, 0); // Bottom of sphere at 0

            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);

            // Radius further inside (1.0) was 1.2
            const r = 1.0;
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            _bushDummy.position.set(x, y + 1.0, z); // +1.0 Y offset matching sphere core
            _bushDummy.rotation.set(0, 0, 0);
            _bushDummy.scale.set(1, 1, 1);

            const normal = new THREE.Vector3(x, y, z).normalize();
            _bushDummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);

            _bushDummy.rotateX((Math.random() - 0.5) * 1.0); // Increased spread
            _bushDummy.rotateZ((Math.random() - 0.5) * 1.0);

            _bushDummy.updateMatrix();

            leafGeo.applyMatrix4(_bushDummy.matrix);

            bushParts.push({
                geo: leafGeo, color: 0x4CA64C
            }); // Match Core Color
        }

        const bushGeo = createColoredGeometry(bushParts);
        // Move down by 20% of height (Height ~2.5 -> move 0.5)
        bushGeo.translate(0, -0.5, 0);

        const vegMaterial = new THREE.ShaderMaterial({

            vertexColors: true,
            uniforms: {
                time: {
                    value: 0
                }

                ,
                carPos: {
                    value: new THREE.Vector3()
                }

                ,
            }

            ,
            vertexShader: ` uniform float time;
            uniform vec3 carPos;
            attribute vec3 offset;
            attribute vec3 instanceNormal;
            attribute float scale;
            attribute float rot;
            attribute vec3 aColor; // Renamed from 'color' to avoid collisions
            attribute float isStatic;

            varying vec3 vColor;

            vec3 rotateVector(vec4 q, vec3 v) {
                return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
            }

            vec4 axisAngleToQuaternion(vec3 axis, float angle) {
                float halfAngle=angle * 0.5;
                float s=sin(halfAngle);
                return vec4(axis * s, cos(halfAngle));
            }

            void main() {
                vColor=aColor;
                vec3 pos=position;
                pos *=scale;

                // WIND SWAY
                float h=position.y; // Local height

                // Sway more at top
                if(h > 0.3) {
                    float wind=sin(time * 2.0 + offset.x * 0.5) + sin(time * 1.5 + offset.z * 0.5);
                    pos.x +=wind * 0.1 * h;
                    pos.z +=wind * 0.05 * h;
                }

                // Rotation
                vec4 qRand=axisAngleToQuaternion(vec3(0, 1, 0), rot);
                pos=rotateVector(qRand, pos);

                // Align to Normal
                vec3 up=vec3(0, 1, 0);
                vec3 normal=normalize(instanceNormal);
                vec3 axis=cross(up, normal);
                float cosA=dot(up, normal);
                vec4 qAlign=vec4(0, 0, 0, 1);
                if (cosA > -0.99) qAlign=normalize(vec4(axis, 1.0 + cosA));
                else qAlign=vec4(1, 0, 0, 0);
                pos=rotateVector(qAlign, pos);

                // Interaction
                if (isStatic < 0.5) {
                    vec3 worldOffset=offset;
                    vec3 totalDisp=vec3(0.0);
                    float originalLen=length(pos);

                    // Player
                    float dCar=distance(worldOffset, carPos);

                    if(dCar < 1.6) {
                        totalDisp +=normalize(worldOffset - carPos) * (1.0 - dCar/1.6);
                    }

                    pos +=totalDisp * 1.0 * (h > 0.1 ? 1.0 : 0.0);

                    // Consistency
                    if(originalLen > 0.001) pos=normalize(pos) * originalLen;
                }

                vec3 worldPos=pos + offset;
                gl_Position=projectionMatrix * viewMatrix * vec4(worldPos, 1.0);
            }

            `,
            fragmentShader: ` varying vec3 vColor;

            void main() {
                gl_FragColor=vec4(vColor, 1.0);
            }

            `,
            side: THREE.DoubleSide
        });

        let debugVegCount = 0;

        let seed = 12345;

        function seededRandom() {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }

        function scatterObjects(geo, count, type, minDistance = 0) {
            const mesh = new THREE.InstancedMesh(geo, vegMaterial, count);
            const offsets = new Float32Array(count * 3);
            const normals = new Float32Array(count * 3);
            const scales = new Float32Array(count);
            const rots = new Float32Array(count);
            const isStaticArr = new Float32Array(count);

            const _v3 = new THREE.Vector3();
            let idx = 0;

            // Try more attempts
            for (let i = 0; i < count * 20 && idx < count; i++) {
                _v3.set(seededRandom() - 0.5, seededRandom() - 0.5, seededRandom() - 0.5).normalize();

                let n = noise(_v3.x, _v3.y, _v3.z);
                n += 0.25 * noise(_v3.x * 3.0, _v3.y * 3.0, _v3.z * 3.0);
                // n range roughly -1.25 to 1.25

                const sign = n < 0 ? -1 : 1;
                let shapedN = sign * Math.pow(Math.abs(n), 3.0);
                let h = shapedN * 30.0;

                // Road Avoidance
                const distEq = 40.0 * Math.abs(_v3.y);
                if (distEq < 5.0) continue;

                // Deep Terrain Sync (Simplified Check)
                let finalR = 40.0 + h;

                // If very low, it's water/trench.
                // Apply specific Flattening Logic if needed, but for vegetation just check height.
                // Re-apply logic to get correct surface H
                if (finalR < 32.0) {
                    let rNoise = noise(_v3.x * 1.5, _v3.y * 1.5, _v3.z * 1.5);
                    let factor = 0.825 + (0.5 * (rNoise + 1.0)) * 0.05;
                    finalR = 40.0 * factor;
                    h = finalR - 40.0;
                }

                let valid = false;
                let scale = 1.0;

                // Min Distance Check (Optimization: only if minDistance > 0)
                if (minDistance > 0) {
                    // Check against already placed objects in this batch
                    // Note: This only checks against objects of the SAME type in this scatter call
                    // To be perfect, we'd need a global list, but self-spacing is usually enough.
                    let tooClose = false;
                    const candidatePos = _v3.clone().multiplyScalar(40.0 + h); // Approx position

                    // Simple O(N) check - sufficient for N < 1000
                    for (let d = 0; d < idx; d++) {
                        const px = offsets[d * 3];
                        const py = offsets[d * 3 + 1];
                        const pz = offsets[d * 3 + 2];
                        // Squared distance check is faster
                        const dx = px - candidatePos.x;
                        const dy = py - candidatePos.y;
                        const dz = pz - candidatePos.z;

                        if (dx * dx + dy * dy + dz * dz < minDistance * minDistance) {
                            tooClose = true;
                            break;
                        }
                    }

                    if (tooClose) continue;
                }

                // SIMPLIFIED ZONING (Debug)
                // Valid if above Water (-1.0) and below High Peaks (25.0)
                if (h > -0.5 && h < 25.0) {
                    valid = true;

                    if (type === 'tree') {
                        // Allow trees in 0..18
                        if (h < 0.0 || h > 18.0) valid = false;
                        // Simple Density Check
                        if (noise(_v3.x * 5.0, _v3.y * 5.0, _v3.z * 5.0) < 0.0) valid = false;
                        scale = 1.2 + seededRandom() * 1.0; // Larger trees
                    }

                    else if (type === 'mushroom') {
                        if (h < 1.0 || h > 15.0) valid = false;
                        // Clumps
                        if (noise(_v3.x * 10.0 + 10.0, _v3.y * 10.0, _v3.z * 10.0) > -0.2) valid = false;
                        scale = 0.8 + seededRandom() * 0.5; // Visible mushrooms
                    }

                    else if (type === 'flower') {
                        if (h < -0.5 || h > 15.0) valid = false;
                        // Clumpier distribution: Higher frequency, higher threshold
                        if (noise(_v3.x * 25.0, _v3.y * 25.0, _v3.z * 25.0) < 0.35) valid = false;
                        // Reduced Size 30%: 0.56 to 0.91 (Original was 0.8 to 1.3)
                        scale = 0.56 + seededRandom() * 0.35;
                    }

                    // Stones & Twigs Logic
                    else if (type === 'stone') {
                        if (h < -1.0 || h > 28.0) valid = false; // Anywhere on land
                        scale = 0.5 + seededRandom() * 0.8;
                    }

                    else if (type === 'twig') {
                        if (h < 0.0 || h > 18.0) valid = false; // Near trees (approx forest height)
                        scale = 0.6 + seededRandom() * 0.6;
                    }

                    else if (type === 'bush') {
                        if (h < -0.5 || h > 22.0) valid = false;
                        // Increased Size 20%: 1.0 -> 1.2
                        scale = 1.2 + seededRandom() * 0.6;
                    }
                }

                if (valid) {
                    const pos = _v3.clone().multiplyScalar(40.0 + h);
                    offsets[idx * 3] = pos.x;
                    offsets[idx * 3 + 1] = pos.y;
                    offsets[idx * 3 + 2] = pos.z;

                    normals[idx * 3] = _v3.x;
                    normals[idx * 3 + 1] = _v3.y;
                    normals[idx * 3 + 2] = _v3.z;

                    scales[idx] = scale;
                    rots[idx] = seededRandom() * Math.PI * 2;
                    isStaticArr[idx] = (type === 'stone' || type === 'twig') ? 1.0 : 0.0;
                    idx++;
                }
            }

            debugVegCount += idx;

            mesh.geometry.setAttribute('offset', new THREE.InstancedBufferAttribute(offsets, 3));
            mesh.geometry.setAttribute('instanceNormal', new THREE.InstancedBufferAttribute(normals, 3));
            mesh.geometry.setAttribute('scale', new THREE.InstancedBufferAttribute(scales, 1));
            mesh.geometry.setAttribute('rot', new THREE.InstancedBufferAttribute(rots, 1));
            mesh.geometry.setAttribute('isStatic', new THREE.InstancedBufferAttribute(isStaticArr, 1));
            mesh.frustumCulled = false;
            scene.add(mesh);
            return mesh;
        }

        seed = 12345; // Reset seed
        const trees = scatterObjects(treeGeo, 58, 'tree', 3.0); // Reduced count to 58 (user request half)
        const mushrooms = scatterObjects(mushGeo, 200, 'mushroom'); // Reduced 200
        const flowers = scatterObjects(flowerGeo, 250, 'flower'); // Reduced 50% again (500 -> 250)

        // Add Stones, Twigs, and Bushes
        const stones = scatterObjects(stoneGeo, 25, 'stone');
        const twigs = scatterObjects(twigGeo, 25, 'twig');
        const bushes = scatterObjects(bushGeo, 50, 'bush');

        function replenishResources() {
            const targets = [stones, twigs, mushrooms];
            const missing = [];

            targets.forEach(mesh => {
                if (!mesh || !mesh.geometry) return;
                const scales = mesh.geometry.attributes.scale;
                for (let i = 0; i < scales.count; i++) {
                    if (scales.getX(i) < 0.01) {
                        missing.push({ mesh, index: i });
                    }
                }
            });

            if (missing.length === 0) return;

            // Determine how many to restore: Randomly between 3 and 10
            let countToRestore = Math.floor(Math.random() * 8) + 3; // 3 to 10
            if (countToRestore > missing.length) countToRestore = missing.length;

            // Shuffle missing array to pick randomly
            for (let i = missing.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [missing[i], missing[j]] = [missing[j], missing[i]];
            }

            const restoredMeshes = new Set();
            for (let i = 0; i < countToRestore; i++) {
                const item = missing[i];
                const scales = item.mesh.geometry.attributes.scale;
                // Use original scale logic roughly: 0.8 to 1.3 for mushrooms, etc.
                // Looking at scatterObjects original logic:
                // mushroom: 0.8 + rand * 0.5
                // stone: 0.5 + rand * 0.8
                // twig: 0.6 + rand * 0.6

                let newScale = 1.0;
                if (item.mesh === mushrooms) newScale = 0.8 + Math.random() * 0.5;
                else if (item.mesh === stones) newScale = 0.5 + Math.random() * 0.8;
                else if (item.mesh === twigs) newScale = 0.6 + Math.random() * 0.6;

                scales.setX(item.index, newScale);
                restoredMeshes.add(item.mesh);
            }

            restoredMeshes.forEach(mesh => {
                mesh.geometry.attributes.scale.needsUpdate = true;
            });

            console.log(`Resources Replenished: ${countToRestore} items restored.`);
        }

        document.title = `Veg: $ {
            debugVegCount
        }

        `;


        // --- 4. Character (Humanoid) ---
        const carGroup = new THREE.Group();
        carGroup.position.set(0, planetRadius + 10, 0);

        // Character Container (For local rotation/animation)
        const characterContainer = new THREE.Group();
        carGroup.add(characterContainer);

        // Material (White)
        // Material (White, Flat, No Shadow)
        const charMat = new THREE.MeshBasicMaterial({
            color: 0xffffff
        });

        // Head
        const headGeo = new THREE.SphereGeometry(0.5, 32, 32);
        const headMesh = new THREE.Mesh(headGeo, charMat);
        headMesh.position.y = 1.7;
        characterContainer.add(headMesh);

        // Body (Capsule-ish: Cylinder with rounded feel, or just Cylinder)
        // Image shows a simple shape. Let's make it a slightly tapered cylinder.
        const bodyGeo = new THREE.CylinderGeometry(0.35, 0.45, 0.7, 16);
        const bodyMesh = new THREE.Mesh(bodyGeo, charMat);
        bodyMesh.position.y = 1.0;
        characterContainer.add(bodyMesh);

        // Legs
        // Pivot at the hips (top of leg)
        const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.7, 12);
        legGeo.translate(0, -0.35, 0); // Shift so origin is at top

        // Left Leg
        const leftLeg = new THREE.Mesh(legGeo, charMat);
        leftLeg.position.set(-0.2, 0.7, 0); // Hip position
        characterContainer.add(leftLeg);

        // Right Leg
        const rightLeg = new THREE.Mesh(legGeo, charMat);
        rightLeg.position.set(0.2, 0.7, 0); // Hip position
        characterContainer.add(rightLeg);

        scene.add(carGroup);





        // --- 4.5 Chest Navigation Arrow ---
        // --- 4.5 Chest Navigation Arrow (2D HUD) ---
        const hudArrow = document.createElement('div');
        hudArrow.id = 'hudArrow';
        // Triangle shape using borders
        hudArrow.style.width = '0';
        hudArrow.style.height = '0';
        hudArrow.style.borderLeft = '12px solid transparent';
        hudArrow.style.borderRight = '12px solid transparent';
        hudArrow.style.borderBottom = '24px solid white'; // White Color (User Request)
        hudArrow.style.position = 'absolute';
        hudArrow.style.zIndex = '9999';
        hudArrow.style.transformOrigin = 'center center';
        hudArrow.style.display = 'none';
        hudArrow.style.pointerEvents = 'none'; // Click through

        // Chest Icon at Tail
        const chestIcon = document.createElement('div');
        chestIcon.style.position = 'absolute';
        chestIcon.style.top = '32px'; // Spaced out from 24px base
        chestIcon.style.left = '-9px'; // Centered (width 16 + 2 border = 18 / 2 = 9)
        chestIcon.style.width = '16px';
        chestIcon.style.height = '12px';
        chestIcon.style.background = '#8B4513'; // SaddleBrown
        chestIcon.style.border = '1px solid #3e2723';
        chestIcon.style.borderRadius = '2px';
        hudArrow.appendChild(chestIcon);

        document.body.appendChild(hudArrow);

        const carPhysics = {
            pos: new THREE.Vector3(0, planetRadius + 10, 0),
            quat: new THREE.Quaternion(),
            speed: 0,
            up: new THREE.Vector3(0, 1, 0),
            smoothedUp: new THREE.Vector3(0, 1, 0)
        }

            ;

        const keys = {
            w: false, a: false, s: false, d: false, " ": false,
            j: false, k: false
        }

            ;

        let playerWalkTime = 0;

        const handleKeyDown = (e) => {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(k)) keys[k] = true;
            if (e.key === ' ') keys[" "] = true;
        }

        const handleKeyUp = (e) => {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(k)) keys[k] = false;
            if (e.key === ' ') keys[" "] = false;
        }

        // --- Procedural BGM Engine (AudioMaster) ---
        class AudioMaster {
            constructor() {
                this.ctx = null;
                this.isStarted = false;
                this.mainGain = null;
                this.isBattleMode = false;
                this.bpm = 60;
                this.nextNoteTime = 0;
                this.beatCount = 0;
            }

            init() {
                if (this.isStarted) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.mainGain = this.ctx.createGain();
                this.mainGain.gain.value = 0.4;
                this.mainGain.connect(this.ctx.destination);
                this.isStarted = true;
                this.nextNoteTime = this.ctx.currentTime;
                this.scheduleLoop();
            }

            setBattleMode(active) {
                if (this.isBattleMode !== active) {
                    this.isBattleMode = active;
                    this.bpm = active ? 130 : 60;
                }
            }

            playNote(freq, duration, wait = 0, vol = 0.15, type = 'triangle') {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime + wait);

                g.gain.setValueAtTime(0, this.ctx.currentTime + wait);
                g.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + wait + 0.05);
                g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + wait + duration);

                osc.connect(g);
                g.connect(this.mainGain);

                osc.start(this.ctx.currentTime + wait);
                osc.stop(this.ctx.currentTime + wait + duration);
            }

            playDrum(type, time) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();

                if (type === 'kick') {
                    osc.frequency.setValueAtTime(150, time);
                    osc.frequency.exponentialRampToValueAtTime(0.001, time + 0.5);
                    g.gain.setValueAtTime(1.0, time);
                    g.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                } else if (type === 'snare') {
                    osc.type = 'triangle'; // Simpler snare
                    osc.frequency.setValueAtTime(100, time);
                    g.gain.setValueAtTime(0.4, time); // Reduced gain
                    g.gain.exponentialRampToValueAtTime(0.001, time + 0.15); // Shorter decay
                    // Softer noise burst (Sine sweep instead of Sawtooth)
                    this.playSweep(400, 50, 0.08, 'sine', 0.15, time - this.ctx.currentTime);
                } else if (type === 'hihat') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, time);
                    osc.frequency.exponentialRampToValueAtTime(1200, time + 0.05); // Metallic
                    g.gain.setValueAtTime(0.15, time); // Reduced volume (was 0.3)
                    g.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                }

                osc.connect(g);
                g.connect(this.mainGain);
                osc.start(time);
                osc.stop(time + 0.5);
            }

            playSweep(startFreq, endFreq, duration, type = 'sine', vol = 0.1, wait = 0) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(startFreq, this.ctx.currentTime + wait);
                osc.frequency.exponentialRampToValueAtTime(endFreq, this.ctx.currentTime + wait + duration);
                g.gain.setValueAtTime(vol, this.ctx.currentTime + wait);
                g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + wait + duration);
                osc.connect(g);
                g.connect(this.mainGain);
                osc.start(this.ctx.currentTime + wait);
                osc.stop(this.ctx.currentTime + wait + duration);
            }

            // SFX Methods
            playJump() { this.playSweep(150, 400, 0.12, 'sine', 0.2); }
            playAttackMelee() { this.playSweep(200, 100, 0.15, 'sawtooth', 0.15); }
            playAttackBow() { this.playSweep(800, 1200, 0.05, 'sine', 0.1); }
            playHit() { this.playSweep(120, 40, 0.12, 'square', 0.15); }
            playPickup() { this.playNote(659.25, 0.1); this.playNote(880.00, 0.2, 0.05); }
            playLevelUp() { [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => this.playNote(f, 0.4, i * 0.12)); }
            playDeath() { this.playSweep(100, 20, 0.8, 'sawtooth', 0.3); }

            scheduleLoop() {
                const secondsPerBeat = 60.0 / this.bpm;
                const lookahead = 0.1; // Scheduling lookahead

                while (this.nextNoteTime < this.ctx.currentTime + lookahead) {
                    this.playStep(this.nextNoteTime);
                    this.nextNoteTime += secondsPerBeat;
                    this.beatCount++;
                }

                // Keep loop running
                requestAnimationFrame(() => this.scheduleLoop());
            }

            playStep(time) {
                // Scales
                const C_Major_Pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25];
                // D Harmonic Minor (Epic/Dramatic): D, E, F, G, A, Bb, C#, D
                const Epic_Scale = [146.83, 164.81, 174.61, 196.00, 220.00, 233.08, 277.18, 293.66, 349.23, 440.00];

                const beatIndex = this.beatCount % 16;
                const relTime = time - (this.ctx ? this.ctx.currentTime : 0);

                // --- BATTLE MODE (Epic Orchestral Style) ---
                if (this.isBattleMode) {
                    // Percussion: Orchestral Hits (Simulated Taiko/Timpani)
                    // High impact on 1, accents on syncopated beats
                    if (beatIndex === 0 || beatIndex === 6 || beatIndex === 10 || beatIndex === 14) {
                        // "Taiko" - Low Sine sweep
                        this.playSweep(120, 40, 0.2, 'sine', 0.6, relTime);
                    }
                    if (beatIndex % 2 === 0) {
                        // "Shaker/Hihat" - fast noise
                        // this.playDrum('hihat', time); // Keeping subtle metal
                        this.playSweep(800, 1200, 0.05, 'square', 0.05, relTime);
                    }

                    // Bass: Sustained "Cello/Double Bass" (Sawtooth Low Pass filter sim via lower vol/triangle mix)
                    if (beatIndex === 0 || beatIndex === 8) {
                        const root = Epic_Scale[0] / 2; // Low D
                        this.playNote(root, 0.4, relTime, 0.4, 'sawtooth');
                        this.playNote(root * 1.5, 0.4, relTime, 0.2, 'triangle'); // Fifth
                    }

                    // Lead: "Brass" Section (Slow, Stately, Heroic)
                    if (beatIndex === 0 || beatIndex === 4 || beatIndex === 8 || beatIndex === 12) {
                        if (Math.random() > 0.3) {
                            const note = Epic_Scale[Math.floor(Math.random() * Epic_Scale.length)];
                            // Brass envelope: sharp attack, sustain, decay
                            // Using Sawtooth for trombones/horns
                            this.playNote(note, 0.3, relTime, 0.25, 'sawtooth');
                        }
                    }

                    // Ostinato (Running Strings) - Fast 16th notes
                    if (true) { // constant motion
                        const arpNote = Epic_Scale[beatIndex % 4];
                        this.playNote(arpNote * 2, 0.1, relTime, 0.08, 'triangle');
                    }

                }

                // --- CALM MODE ---
                else {
                    const scale = C_Major_Pentatonic;
                    // Bass layer (Slow)
                    if (beatIndex === 0) {
                        this.playNote(scale[0] / 2, 4.0, relTime);
                        this.playNote(scale[2] / 2, 4.0, relTime);
                    }

                    // Random melody
                    if (Math.random() > 0.5 && (beatIndex % 2 === 0)) {
                        const note = scale[Math.floor(Math.random() * scale.length)];
                        const dur = 1.0 + Math.random() * 2.0;
                        this.playNote(note, dur, relTime);
                    }
                }
            }
        }
        const audioMaster = new AudioMaster();
        const startOverlay = document.createElement('div');
        startOverlay.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; z-index:100000; cursor:pointer; background:rgba(0,0,0,0);';
        startOverlay.innerHTML = '';
        document.body.appendChild(startOverlay);
        const startAudio = () => {
            audioMaster.init();
            if (audioMaster.ctx && audioMaster.ctx.state === 'suspended') {
                audioMaster.ctx.resume();
            }
            startOverlay.remove();
        };
        startOverlay.addEventListener('click', startAudio);
        startOverlay.addEventListener('touchstart', startAudio);
        window.addEventListener('keydown', (e) => {
            handleKeyDown(e);
            if (!audioMaster.isStarted && e.key) { audioMaster.init(); startOverlay.remove(); }
            if (keys.j && keys.k) {
                const playerPos = carGroup.position.clone();
                const angle = Math.random() * Math.PI * 2;
                const dist = 2 + Math.random() * 2;
                const offset = new THREE.Vector3(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
                const spawnPos = playerPos.clone().add(offset);
                spawnExpItem(spawnPos);
            }
        });
        window.addEventListener('keyup', handleKeyUp);

        // Debug: Spawn Bear with K key
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'k') {
                // Get player position
                const playerPos = carGroup.position.clone();

                // Spawn bear 5 units away from player in a random direction
                const angle = Math.random() * Math.PI * 2;
                const distance = 5;
                const offset = new THREE.Vector3(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );

                // Apply offset in world space
                const spawnPos = playerPos.clone().add(offset);

                // Adjust to surface height
                const surfaceHeight = getSurfaceHeight(spawnPos.x, spawnPos.y, spawnPos.z);
                const up = spawnPos.clone().normalize();
                spawnPos.copy(up.multiplyScalar(surfaceHeight));

                // Create bear
                const bear = createBear(spawnPos);
                wolves.push(bear);
                gameState.enemiesRemaining++;

                console.log(t('bearSpawned'));

                // Update UI
                const countText = document.getElementById('enemyCountText');
                if (countText) countText.textContent = gameState.enemiesRemaining;
            }
        });

        // --- Chest Implementation ---

        // 1. UI Bubble (REMOVED for Rogue Mode)
        const chestBubble = document.createElement('div'); // Dummy to prevent errors if referenced
        chestBubble.style.display = 'none';

        // Dynamic UI Generation (Disabled)
        function initTaskUI() {
            // No-op for Rogue Mode
        }

        // document.body.appendChild(chestBubble); // Removed

        // 2. Chest State
        const itemIcons = {}; // Moved here to avoid TDZ
        const chestInventory = {
            stone: 0,
            twig: 0,
            mushroom: 0,
            followers: 0, // Stored followers
            level: 1, // Current Dorm Level
            maxFollowers: 5,
            hp: 50,
            maxHp: 50
        };

        const gameState = {
            waveActive: false, // Legacy flag, effectively true during waves
            wave: 0, // Current Wave (Starts at 0, goes to 1 on init)
            waveState: 'waiting', // 'spawning', 'active', 'cleared', 'transition'
            enemiesRemaining: 0,

            gameOver: false,
            wolfKills: 0,
            killCount: 0,
            exp: 0,
            expToNextLevel: 10,
            roleLevel: 1,
            stats: {
                followerPopMult: 1.0,
                moveSpeedMult: 1.0,
                attackDmgMult: 1.0,
                attackFreqMult: 1.0,
                critRate: 0.0,
                defenseMult: 1.0,
                expGainMult: 1.0
            },
            paused: false
        };

        // --- Save System ---
        const SAVE_KEY = 'proxima_rogue_save_v1';

        function saveGame() {
            try {
                const data = {
                    gameState: {
                        wave: gameState.wave,
                        exp: gameState.exp,
                        expToNextLevel: gameState.expToNextLevel,
                        roleLevel: gameState.roleLevel,
                        stats: gameState.stats,
                        killCount: gameState.killCount
                    },
                    chestInventory: chestInventory
                };
                localStorage.setItem(SAVE_KEY, JSON.stringify(data));
                console.log('Game Saved', data);
            } catch (e) {
                console.error('Save Failed', e);
            }
        }

        function loadGame() {
            try {
                const raw = localStorage.getItem(SAVE_KEY);
                if (raw) {
                    const data = JSON.parse(raw);
                    if (data.gameState) {
                        // Restore Wave (Minus 1 so startNextWave increments to correct level)
                        gameState.wave = Math.max(0, (data.gameState.wave || 1) - 1);
                        gameState.exp = data.gameState.exp;
                        gameState.expToNextLevel = data.gameState.expToNextLevel;
                        gameState.roleLevel = data.gameState.roleLevel;
                        gameState.killCount = data.gameState.killCount;

                        // Restore Stats
                        if (data.gameState.stats) {
                            Object.assign(gameState.stats, data.gameState.stats);
                        }
                    }
                    if (data.chestInventory) {
                        Object.assign(chestInventory, data.chestInventory);
                    }
                    console.log('Game Loaded from LocalStorage');
                    return true;
                }
            } catch (e) {
                console.error('Load Failed', e);
            }
            return false;
        }

        function clearSave() {
            localStorage.removeItem(SAVE_KEY);
            console.log('Save Cleared');
        }

        // Auto-Load on Startup
        loadGame();

        // WAVE CONFIG
        function getWaveConfig(wave) {
            // Difficulty Scaling Formula
            // Wave 1: 5 Wolves
            // Wave 2: 8 Wolves
            // Wave 3: 5 Wolves + 2 Bears
            // Wave 5: Alpha introduction

            let wolves = 0;
            let bears = 0;
            let multiplier = 1.0 + (wave * 0.15); // +15% stats per wave

            if (wave === 1) wolves = 5;
            else if (wave === 2) wolves = 8;
            else if (wave === 3) { wolves = 6; bears = 2; }
            else {
                // Algorithmic growth
                wolves = 8 + Math.floor((wave - 3) * 2.5);
                bears = 2 + Math.floor((wave - 3) * 1.5);
            }

            // Cap checks
            if (wolves > 50) wolves = 50;
            if (bears > 20) bears = 20;

            return { wolves, bears, multiplier };
        }

        async function startNextWave() {
            if (gameState.waveState === 'transition') return;
            gameState.waveState = 'transition';
            gameState.wave++;
            saveGame(); // Save Checkpoint

            const overlay = document.getElementById('waveTransitionOverlay');
            const text = document.getElementById('waveText');

            // 1. Fade OUT (Black) - End of previous day
            if (gameState.wave > 1) {
                overlay.style.backgroundColor = 'black';
                overlay.style.opacity = '1';
                text.textContent = t('dayCompleted', gameState.wave - 1);
                text.style.opacity = '1';
                await new Promise(r => setTimeout(r, 3000));
            }

            // 2. Fade IN (White/Clear) - Start of new day
            // "First day end, light white: second day start"
            // Interpretation: Fade to black, then flash white/fade in?

            text.textContent = t('day', gameState.wave);
            overlay.style.backgroundColor = 'black'; // Keep black bg for text
            overlay.style.opacity = '1';

            await new Promise(r => setTimeout(r, 2000));

            // Fade to game
            overlay.style.opacity = '0';

            // Generate Enemies
            const config = getWaveConfig(gameState.wave);
            spawnWaveEnemies(config);

            gameState.waveState = 'active';
        }

        function spawnWaveEnemies(config) {
            console.log(t('waveStart', gameState.wave, config.wolves, config.bears));

            // Clear existing (just in case)
            // Clear existing (just in case)
            wolves.forEach(w => scene.remove(w.mesh));
            wolves.length = 0;

            // Spawn Wolves
            const alphaChance = 0.05 + (gameState.wave * 0.02); // 5% + 2% per wave

            for (let i = 0; i < config.wolves; i++) {
                const pos = getSpawnPosition();
                const isAlpha = Math.random() < alphaChance;
                const w = createWolf(pos, config.multiplier, isAlpha);
                wolves.push(w);
            }

            // Spawn Bears
            for (let i = 0; i < config.bears; i++) {
                const pos = getSpawnPosition();
                const isDire = Math.random() < (alphaChance * 0.5);
                const b = createBear(pos, config.multiplier, isDire);
                wolves.push(b);
            }

            gameState.enemiesRemaining = wolves.length;

            // UI Update
            const ui = document.getElementById('waveInfoUI');
            const countText = document.getElementById('enemyCountText');
            if (ui && countText) {
                ui.style.display = 'flex';
                countText.textContent = gameState.enemiesRemaining;
            }
        }

        function getSpawnPosition() {
            // Calculate opposite side from player
            const pPosNorm = carGroup.position.clone().normalize();
            const spawnBase = pPosNorm.multiplyScalar(-1); // Reverse direction

            // Add some random spread
            const spread = 0.8;
            const spreadVec = new THREE.Vector3(
                (Math.random() - 0.5) * spread,
                (Math.random() - 0.5) * spread,
                (Math.random() - 0.5) * spread
            );
            const spawnDir = spawnBase.add(spreadVec).normalize();
            return spawnDir.multiplyScalar(planetRadius + 10); // Start in air
        }

        const rogueUpgrades = [
            { id: 1, title: t('popTitle'), icon: "👥", desc: t('popDesc'), effect: () => { gameState.stats.followerPopMult *= 1.1; chestInventory.maxFollowers = Math.ceil(5 * gameState.stats.followerPopMult); } },
            { id: 2, title: t('speedTitle'), icon: "🏃", desc: t('speedDesc'), effect: () => { gameState.stats.moveSpeedMult *= 1.1; } },
            { id: 3, title: t('attackTitle'), icon: "⚔️", desc: t('attackDesc'), effect: () => { gameState.stats.attackDmgMult *= 1.1; } },
            { id: 4, title: t('freqTitle'), icon: "⚡", desc: t('freqDesc'), effect: () => { gameState.stats.attackFreqMult *= 1.1; } },
            { id: 5, title: t('critTitle'), icon: "🎯", desc: t('critDesc'), effect: () => { gameState.stats.critRate += 0.05; } },
            { id: 6, title: t('defTitle'), icon: "🛡️", desc: t('defDesc'), effect: () => { gameState.stats.defenseMult *= 1.1; } },
            { id: 7, title: t('expTitle'), icon: "📚", desc: t('expDesc'), effect: () => { gameState.stats.expGainMult *= 1.1; } },
            { id: 8, title: t('hpTitle'), icon: "❤️", desc: t('hpDesc'), effect: () => { const gain = Math.ceil(chestInventory.maxHp * 0.1); chestInventory.maxHp += gain; chestInventory.hp += gain; } }
        ];

        function showRogueUpgrade() {
            gameState.paused = true;
            const ui = document.getElementById('rogueUpgradeUI');
            const container = document.getElementById('rogueCardOptions');
            container.innerHTML = '';

            // Randomly pick 3 unique upgrades
            const shuffled = [...rogueUpgrades].sort(() => 0.5 - Math.random());
            const selected = shuffled.slice(0, 3);

            selected.forEach(upg => {
                const card = document.createElement('div');
                card.className = 'rogue-card';
                card.innerHTML = `
                    <div class="title">${upg.title}</div>
                    <div class="desc">${upg.desc}</div>
                `;

                const handleSelect = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    upg.effect();
                    ui.style.display = 'none';
                    // Resume game could be here if we paused
                    gameState.paused = false;
                    clock.getDelta(); // Clear accumulated time to prevent jump
                };

                card.onclick = handleSelect;
                card.ontouchend = handleSelect;

                container.appendChild(card);
            });

            ui.style.display = 'flex';
        }


        // Task Configuration per Level
        // --- GAME CONFIGURATION ---
        // Modify this table to adjust game balance, costs, and rewards.
        const levelConfig = {
            1: {
                description: "Initial Hut",
                tasks: [
                    { type: 'twig', count: 3 },
                    { type: 'mushroom', count: 3 }
                ],
                reward: {
                    maxFollowers: 10,
                    description: "Upgrade House & Equip Guard"
                },
                unlocks: ['guard_gear']
            },
            2: {
                description: "Wooden House",
                tasks: [],
                reward: {
                    maxFollowers: 10,
                    description: "Max Level"
                },
                unlocks: []
            }
        };

        // Initialize UI
        initTaskUI();

        let lastChestDepositTime = 0;
        let lastFollowerStoreTime = 0; // Timer for storing followers
        const chestPos = new THREE.Vector3(0, planetRadius, 15.0); // Z+15

        // 3. Chest Mesh Factory
        let chestMesh = null; // Will be assigned

        function buildDormitory(level) {
            const dormGroup = new THREE.Group();

            if (level === 1) {
                // House Body (Cylinder)
                const cottageBodyGeo = new THREE.CylinderGeometry(2.0, 2.0, 1.6, 32);
                const cottageBodyMat = new THREE.MeshBasicMaterial({ color: 0x957A65 });
                const cottageBodyMesh = new THREE.Mesh(cottageBodyGeo, cottageBodyMat);
                cottageBodyMesh.position.y = 0.8;
                dormGroup.add(cottageBodyMesh);

                // Layered Conical Roof (3 Layers)
                const roofLayers = 3;
                const roofBaseRadius = 2.2;
                const roofHeightPerLayer = 0.5;
                const roofColors = [0xCFB075, 0xEAC987, 0xF9E4B0];

                for (let i = 0; i < roofLayers; i++) {
                    const r = roofBaseRadius * (1.0 - i * 0.25);
                    const h = 2.2 + i * (roofHeightPerLayer - 0.1);
                    const layerGeo = new THREE.ConeGeometry(r, roofHeightPerLayer * 2.5, 32);
                    const layerMat = new THREE.MeshBasicMaterial({ color: roofColors[i] || 0xCEB180 });
                    const layerMesh = new THREE.Mesh(layerGeo, layerMat);
                    layerMesh.position.y = h;
                    dormGroup.add(layerMesh);
                }
            } else if (level === 2) {
                // LEVEL 2: Brown Stone House (Transitional)
                // Base
                const baseGeo = new THREE.CylinderGeometry(2.2, 2.2, 2.0, 32);
                const baseMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 }); // Saddle Brown
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 1.0;
                dormGroup.add(base);

                // Mid Ring
                const ringGeo = new THREE.TorusGeometry(2.3, 0.2, 8, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xA0522D }); // Sienna
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.y = 2.0;
                ring.rotation.x = Math.PI / 2;
                dormGroup.add(ring);

                // Second Floor
                const floor2Geo = new THREE.CylinderGeometry(1.8, 1.8, 1.5, 32);
                const floor2Mat = new THREE.MeshBasicMaterial({ color: 0xD2691E }); // Chocolate
                const floor2 = new THREE.Mesh(floor2Geo, floor2Mat);
                floor2.position.y = 2.75;
                dormGroup.add(floor2);

                // Roof
                const roofGeo2 = new THREE.ConeGeometry(2.2, 1.5, 32);
                const roofMat2 = new THREE.MeshBasicMaterial({ color: 0x5D4037 }); // Dark Brown
                const roof2 = new THREE.Mesh(roofGeo2, roofMat2);
                roof2.position.y = 4.25;
                dormGroup.add(roof2);

            } else {
                // LEVEL 3+: Grey-Blue Stone House (Original Lvl 2 Design)
                // 1. Base Walls (Grey-Blue Stone)
                const baseGeo = new THREE.CylinderGeometry(2.2, 2.2, 2.0, 32);
                const stoneMat = new THREE.MeshBasicMaterial({ color: 0x778899 }); // Grey-Blue
                const baseMesh = new THREE.Mesh(baseGeo, stoneMat);
                baseMesh.position.y = 1.0;
                dormGroup.add(baseMesh);

                // 2. First Floor Roof
                const roof1Geo = new THREE.CylinderGeometry(2.6, 2.6, 0.2, 32);
                const roofMat = new THREE.MeshBasicMaterial({ color: 0x2F4F4F }); // Dark Slate Grey
                const roof1 = new THREE.Mesh(roof1Geo, roofMat);
                roof1.position.y = 2.1;
                dormGroup.add(roof1);

                // 3. Second Layer (Room)
                const layer2Geo = new THREE.CylinderGeometry(2.0, 2.0, 1.6, 32); // Slightly wider/taller than before
                const layer2 = new THREE.Mesh(layer2Geo, stoneMat);
                layer2.position.y = 3.0;
                dormGroup.add(layer2);

                // 4. Top Roof (Cone/Domed)
                const roof2Geo = new THREE.ConeGeometry(2.5, 1.5, 32);
                const roof2 = new THREE.Mesh(roof2Geo, roofMat);
                roof2.position.y = 4.5;
                dormGroup.add(roof2);
            }

            // Door Frame (Generic for now, adjust Z based on radius)
            const doorRadius = level === 1 ? 2.0 : 2.2;
            const doorFrameGeo = new THREE.CylinderGeometry(1.0, 1.0, 1.2, 32, 1, false, 0, Math.PI);
            const doorFrameMat = new THREE.MeshBasicMaterial({ color: 0x2F4F4F });
            const doorFrame = new THREE.Mesh(doorFrameGeo, doorFrameMat);
            // Position: Ground(Y=0), Protruding(Z)
            doorFrame.position.set(0, 0, doorRadius - 0.2);
            doorFrame.rotation.set(0, Math.PI / 2, Math.PI / 2);
            dormGroup.add(doorFrame);

            // Door (Inner Block)
            const doorGeo = new THREE.CylinderGeometry(0.7, 0.7, 1.25, 32, 1, false, 0, Math.PI);
            const doorMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 0, doorRadius - 0.15);
            door.rotation.set(0, Math.PI / 2, Math.PI / 2);
            dormGroup.add(door);

            return dormGroup;
        }

        // chestMesh = buildDormitory(chestInventory.level);
        // scene.add(chestMesh);
        chestMesh = null; // Essentially removed

        // 4. Precise Terrain Height Logic (Copied from Terrain Pipeline)
        function getSurfaceHeight(x, y, z) {
            const dir = new THREE.Vector3(x, y, z).normalize();

            // 1. Structure Noise
            let n = noise(dir.x * 1.0, dir.y * 1.0, dir.z * 1.0);
            n += 0.25 * noise(dir.x * 3.0, dir.y * 3.0, dir.z * 3.0);

            // 2. Power Curve
            const power = 3.0;
            const sign = n < 0 ? -1 : 1;
            let shapedN = sign * Math.pow(Math.abs(n), power);
            let h = shapedN * 30.0;

            // 3. Road Zone
            const roadBandWidth = 3.0;
            const roadTransition = 3.0;
            const distFromEquator = planetRadius * Math.abs(dir.y);

            if (distFromEquator < (roadBandWidth + roadTransition)) {
                const roadHeight = 0.5;
                let t = 0.0;
                if (distFromEquator < roadBandWidth) t = 1.0;

                else {
                    let edgeDist = (distFromEquator - roadBandWidth) / roadTransition;
                    t = 1.0 - (edgeDist * edgeDist * (3.0 - 2.0 * edgeDist));
                }

                h = h * (1.0 - t) + roadHeight * t;
            }

            // 4. Deep Terrain Flattening
            let finalRadius = planetRadius + h;

            if (finalRadius < planetRadius * 0.8) {
                let rNoise = noise(dir.x * 1.5, dir.y * 1.5, dir.z * 1.5);
                let normNoise = 0.5 * (rNoise + 1.0);
                let factor = 0.825 + normNoise * 0.05;
                finalRadius = planetRadius * factor;
                h = finalRadius - planetRadius;
            }

            return planetRadius + h;
        }

        // Init Chest Pos (Disabled)
        /*
        const groundH = getSurfaceHeight(chestPos.x, chestPos.y, chestPos.z);
        chestPos.normalize().multiplyScalar(groundH);
        chestMesh.position.copy(chestPos);

        // Orient to stand upright on the sphere (Perpendicular to Earth's center)
        const radialUp = chestPos.clone().normalize();

        // Define "North" as the NEW door-facing direction (Rotated 180)
        const southTangent = new THREE.Vector3(0, 1, 0).projectOnPlane(radialUp).normalize();

        // Handle pole case where projectOnPlane might fail
        if (southTangent.lengthSq() < 0.01) {
            southTangent.copy(new THREE.Vector3(0, 0, 1)).projectOnPlane(radialUp).normalize();
        }

        // Create orthonormal basis: Y = Up, Z = South (Door), X = Right
        const eastRight = new THREE.Vector3().crossVectors(radialUp, southTangent).normalize();
        const orientMatrix = new THREE.Matrix4().makeBasis(eastRight, radialUp, southTangent);

        chestMesh.quaternion.setFromRotationMatrix(orientMatrix);
        chestMesh.updateMatrixWorld();
        */

        function generateIcon(geo, color, camPos = null) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;

            // Create mini scene
            const iconScene = new THREE.Scene();
            // iconScene.background = new THREE.Color(0xffffff); // Transparent preferable?
            const iconCam = new THREE.PerspectiveCamera(50, 1, 0.1, 10);
            iconCam.position.copy(camPos || new THREE.Vector3(0, 0, 1.6));
            iconCam.lookAt(0, 0, 0);

            const iconLight = new THREE.DirectionalLight(0xffffff, 1.2);
            iconLight.position.set(1, 1, 1);
            iconScene.add(iconLight);
            iconScene.add(new THREE.AmbientLight(0x404040));

            // Mesh
            // Use VertexColors if geometry has them, else use color
            let mat;

            if (geo.attributes.aColor) {
                // Clone geo to safely set color attribute? 
                // Actually for icons we can just use the provided color fallback or force vertex colors
                // But standard MeshBasicMaterial might look flat. Let's use Lambert for icon depth.
                const iconGeo = geo.clone();
                iconGeo.setAttribute('color', iconGeo.attributes.aColor);
                // Center geometry
                iconGeo.computeBoundingBox();
                const center = iconGeo.boundingBox.getCenter(new THREE.Vector3());
                iconGeo.translate(-center.x, -center.y, -center.z);

                mat = new THREE.MeshLambertMaterial({
                    vertexColors: true
                });
                const m = new THREE.Mesh(iconGeo, mat);
                iconScene.add(m);
            }

            else {
                // Fallback geometry center
                const iconGeo = geo.clone();
                iconGeo.computeBoundingBox();
                const center = iconGeo.boundingBox.getCenter(new THREE.Vector3());
                iconGeo.translate(-center.x, -center.y, -center.z);

                mat = new THREE.MeshLambertMaterial({
                    color: color
                });
                const m = new THREE.Mesh(iconGeo, mat);
                iconScene.add(m);
            }

            // Render
            renderer.render(iconScene, iconCam);
            return renderer.domElement.toDataURL();
        }

        // Generate Icons (Delayed slightly to ensure renderer is ready? No, renderer exists)
        // Store geometries to use. 
        // Note: stoneGeo, twigGeo have aColor? Stone does. Twig does. Mushroom has parts.
        // For mushroom, we need to combine parts or just pick the cap?
        // Let's approximate.

        // Wait, Mushroom is complex (cap + stipe). We don't have a single merged geometry variable easily accessible 
        // except the InstancedMesh's geometry? No, we used 'mushGeo' which was an array of parts? 
        // Let's see: const mushrooms = scatterObjects(mushGeo, ...)
        // 'mushGeo' passed to scatterObjects is expected to be a single geometry (BufferGeometry).

        setTimeout(() => {
            // Safe delay to ensure context is clean
            const currentClearColor = renderer.getClearColor(new THREE.Color());
            const currentClearAlpha = renderer.getClearAlpha();
            const currentSize = new THREE.Vector2();
            renderer.getSize(currentSize);

            // Temp resize for icon
            renderer.setSize(64, 64);
            renderer.setClearColor(0x000000, 0); // Transparent background

            itemIcons['stone'] = generateIcon(stoneGeo, 0x888888);
            itemIcons['twig'] = generateIcon(twigGeo, 0x5C4033);

            // For mushroom, stick to a simple proxy if complex, or try mushGeo if it is a geometry
            // If mushGeo is array of parts, we need to construct a group.
            // Looking at scatterObjects usage: `scatterObjects(mushGeo, ...)`
            // This implies `mushGeo` IS a Geometry (BufferGeometry).
            itemIcons['mushroom'] = generateIcon(mushGeo, 0xff0000, new THREE.Vector3(0, 1.5, 0.6));

            // Restore
            renderer.setSize(currentSize.x, currentSize.y);
            renderer.setClearColor(currentClearColor, currentClearAlpha);
        }

            , 100);


        const flyingItems = [];

        const dormLabel = document.getElementById('dormLabel');
        const labelRaycaster = new THREE.Raycaster();

        let lastDormLabelUpdate = 0;
        let isLabelOccluded = false; // Cache occlusion state
        let lastStoredCount = -1; // Cache count to avoid DOM updates

        function updateDormLabel() {
            if (!dormLabel || !chestMesh) return;

            const now = performance.now();

            // 1. Content Update (Only on change)
            const stored = chestInventory['followers'] || 0;
            if (stored !== lastStoredCount) {
                dormLabel.innerHTML = `
                    <div class="icon">
                        <div class="follower-icon">
                            <div class="head"></div>
                            <div class="body"></div>
                        </div>
                    </div>
                    <div class="text">${stored}</div>
                `;
                lastStoredCount = stored;
            }

            // 2. Position Calculation (Every Frame - for Smoothness)
            const worldPos = chestMesh.position.clone().add(new THREE.Vector3(0, 4.5, 0));

            // 3. Occlusion Check (Throttled to 10fps to save performance)
            if (now - lastDormLabelUpdate > 100) {
                lastDormLabelUpdate = now;

                // Ray from Camera to Label
                const direction = worldPos.clone().sub(camera.position);
                const distance = direction.length();
                direction.normalize();

                labelRaycaster.set(camera.position, direction);

                const occluders = [];
                if (planet) occluders.push(planet);
                if (typeof trees !== 'undefined' && trees) occluders.push(trees);

                const intersects = labelRaycaster.intersectObjects(occluders, false);

                let blocked = false;
                if (intersects.length > 0) {
                    if (intersects[0].distance < distance - 0.5) {
                        blocked = true;
                    }
                }
                isLabelOccluded = blocked;
            }

            // 4. Project and Apply
            worldPos.project(camera);

            const x = (worldPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = -(worldPos.y * 0.5 - 0.5) * window.innerHeight;

            dormLabel.style.left = x + 'px';
            dormLabel.style.top = y + 'px';

            // Visibility
            if (isLabelOccluded || Math.abs(worldPos.z) > 1.0) {
                dormLabel.style.display = 'none';
            } else {
                dormLabel.style.display = 'flex';
                dormLabel.style.opacity = '1';
            }
        }

        function updateFlyingItems(dt) {
            for (let i = flyingItems.length - 1; i >= 0; i--) {
                const item = flyingItems[i];
                const speed = 15.0;

                const dir = new THREE.Vector3().subVectors(item.target, item.mesh.position);
                const distSq = dir.lengthSq();

                // Move closer
                if (distSq > 0.5) {
                    dir.data = null; // safe
                    dir.normalize();
                    item.mesh.position.add(dir.multiplyScalar(speed * dt));
                    // Scale down effect
                    item.mesh.scale.multiplyScalar(0.92);
                }

                else {

                    // Arrived
                    if (chestInventory.hasOwnProperty(item.type)) {
                        chestInventory[item.type]++;
                    }

                    // Dispose
                    scene.remove(item.mesh);
                    if (item.mesh.geometry) item.mesh.geometry.dispose();
                    flyingItems.splice(i, 1);
                }
            }
        }



        function updateEnemyIndicators() {
            const arrow1 = document.getElementById('enemyArrow1');
            const arrow2 = document.getElementById('enemyArrow2');

            // Hide both arrows by default
            if (arrow1) arrow1.style.display = 'none';
            if (arrow2) arrow2.style.display = 'none';

            // Filter alive enemies
            const aliveEnemies = wolves.filter(w => w && w.hp > 0 && w.mesh);

            // No enemies, no indicators
            if (aliveEnemies.length === 0) return;

            const playerPos = carGroup.position;
            if (!playerPos) return;

            // Check if any enemy is within 15m
            const hasNearbyEnemy = aliveEnemies.some(enemy => {
                const dist = enemy.mesh.position.distanceTo(playerPos);
                return dist <= 15;
            });

            // If there's an enemy within 15m, don't show indicator
            if (hasNearbyEnemy) return;

            // Find the nearest enemy (must be >15m away at this point)
            let nearestEnemy = null;
            let nearestDist = Infinity;

            aliveEnemies.forEach(enemy => {
                const dist = enemy.mesh.position.distanceTo(playerPos);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                }
            });

            // No nearest enemy found
            if (!nearestEnemy) return;

            // Use arrow1 to show the nearest enemy
            const el = arrow1;
            if (!el) return;

            // Project enemy position to screen
            const pos = nearestEnemy.mesh.position.clone();
            pos.project(camera);

            // Show arrow (always, since enemy is >15m away)
            el.style.display = 'block';

            let nx = pos.x;
            let ny = pos.y;

            // If behind camera, invert
            if (pos.z > 1) {
                nx = -nx;
                ny = -ny;
            }

            // Clamp to screen edge
            const absX = Math.abs(nx);
            const absY = Math.abs(ny);
            const edgeMargin = 0.9;

            if (absX > absY) {
                nx = nx > 0 ? edgeMargin : -edgeMargin;
                ny = ny * (edgeMargin / absX);
            } else {
                ny = ny > 0 ? edgeMargin : -edgeMargin;
                nx = nx * (edgeMargin / absY);
            }

            // Convert to screen pixels
            const cssX = (nx * 0.5 + 0.5) * window.innerWidth;
            const cssY = -(ny * 0.5 - 0.5) * window.innerHeight;

            el.style.left = cssX + 'px';
            el.style.top = cssY + 'px';

            // Rotation to point towards enemy
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const dirX = cssX - centerX;
            const dirY = cssY - centerY;
            const rad = Math.atan2(dirY, dirX) + Math.PI / 2;

            el.style.transform = `translate(-50%, -50%) rotate(${rad}rad)`;
        }

        function upgradeDormitoryState() {
            const currentConfig = levelConfig[chestInventory.level];

            // Consume Resources
            if (currentConfig && currentConfig.tasks) {
                currentConfig.tasks.forEach(t => {
                    chestInventory[t.type] = Math.max(0, (chestInventory[t.type] || 0) - t.count);
                });
            }

            // Level Up
            chestInventory.level++;

            // Update Max Followers based on new level or manual setting
            if (currentConfig && currentConfig.reward && currentConfig.reward.maxFollowers) {
                chestInventory.maxFollowers = currentConfig.reward.maxFollowers;
            }

            // Update Visuals
            scene.remove(chestMesh);

            // Rebuild
            chestMesh = buildDormitory(chestInventory.level);
            chestMesh.position.copy(chestPos);

            // Re-orient (Standard Logic)
            const radialUp = chestPos.clone().normalize();
            const southTangent = new THREE.Vector3(0, 1, 0).projectOnPlane(radialUp).normalize();
            if (southTangent.lengthSq() < 0.01) southTangent.copy(new THREE.Vector3(0, 0, 1)).projectOnPlane(radialUp).normalize();
            const eastRight = new THREE.Vector3().crossVectors(radialUp, southTangent).normalize();
            const orientMatrix = new THREE.Matrix4().makeBasis(eastRight, radialUp, southTangent);
            chestMesh.quaternion.setFromRotationMatrix(orientMatrix);
            chestMesh.updateMatrixWorld();

            scene.add(chestMesh);

            // Update UI
            initTaskUI();
        }

        function updateChestLogic(playerPos) {
            const config = levelConfig[chestInventory.level];
            if (!config) return;

            // --- 1. Update UI (Task List) & Check Upgrade ---
            let allMet = true;

            if (config.tasks && config.tasks.length > 0) {
                config.tasks.forEach(task => {
                    const type = task.type;
                    const count = chestInventory[type] || 0;

                    if (count < task.count) allMet = false;

                    // Update Text
                    const span = document.getElementById(`count-${type}`);
                    if (span) {
                        span.textContent = `${count}/${task.count}`;
                    }

                    // Icon update
                    const img = document.getElementById(`icon-${type}`);
                    if (img && itemIcons[type]) {
                        const currentSrc = img.getAttribute('src');
                        if (!currentSrc || currentSrc.startsWith('data:image/gif')) {
                            img.src = itemIcons[type];
                        }
                    }
                });
            }

            // Trigger Global Upgrade
            if (allMet && config.tasks && config.tasks.length > 0 && levelConfig[chestInventory.level + 1]) {
                upgradeDormitoryState();
                return;
            }

            // --- 2. Interaction Logic (Distance Based) ---
            const distChest = playerPos.distanceTo(chestMesh.position);
            const interactRange = 3.0;

            // Deposit Item
            if (heldItem && config.tasks) {
                const task = config.tasks.find(t => t.type === heldItem.type);
                if (task) {
                    const current = chestInventory[heldItem.type] || 0;
                    if (current < task.count && distChest < interactRange) {
                        const now = clock.getElapsedTime();
                        if (now - lastChestDepositTime > 1.0) {
                            if (heldItem.mesh) {
                                scene.attach(heldItem.mesh);
                                flyingItems.push({
                                    mesh: heldItem.mesh,
                                    target: chestMesh.position.clone().add(new THREE.Vector3(0, 0.5, 0)),
                                    type: heldItem.type
                                });
                            }
                            heldItem = null;
                            lastChestDepositTime = now;
                        }
                    }
                }
            }

            // Release Followers
            if (distChest < interactRange && chestInventory.followers > 0) {
                const now = clock.getElapsedTime();
                if (!window.lastFollowerReleaseTime) window.lastFollowerReleaseTime = 0;

                if (now - window.lastFollowerReleaseTime > 0.5) {
                    chestInventory.followers--;
                    respawnFollowerAtChest();
                    window.lastFollowerReleaseTime = now;
                }
            }

            // --- 3. Equip Followers (Continuous Check) ---
            if (chestInventory.level >= 2) {
                followers.forEach(f => {
                    if (!f.isDead) {
                        equipSword(f);
                        equipShield(f);
                    }
                });
            }
        }

        // --- Workshop System ---


        // --- Equipment Visuals ---
        function equipSword(entity) {
            if (entity.hasSword) return;
            entity.hasSword = true;

            const group = new THREE.Group();

            // Blade
            const bladeGeo = new THREE.BoxGeometry(0.1, 0.8, 0.05);
            const bladeMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 }); // Wood
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.4;
            group.add(blade);

            // Crossguard
            const guardGeo = new THREE.BoxGeometry(0.3, 0.05, 0.05);
            const guard = new THREE.Mesh(guardGeo, bladeMat);
            guard.position.y = 0.1;
            group.add(guard);

            // Handle
            const handleGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3);
            const handle = new THREE.Mesh(handleGeo, bladeMat);
            handle.position.y = -0.05;
            group.add(handle);

            // Attach to Right Hand side
            // For followers: Attached to mesh. 
            // Position: Right side, sticking out
            group.position.set(0.35, 0.6, 0.2);
            group.rotation.x = Math.PI / 4; // Pointing forward/up

            //entity.mesh.add(group); 
            // Better attachment point logic? Follower mesh structure:
            // mesh -> body, head, legs.
            // Just attach to main mesh group.
            entity.mesh.add(group);
        }

        function equipShield(entity) {
            if (entity.hasShield) return;
            entity.hasShield = true;

            const group = new THREE.Group();

            // Shield Body (Rectangular Wood)
            const shieldGeo = new THREE.BoxGeometry(0.5, 0.6, 0.05);
            const shieldMat = new THREE.MeshBasicMaterial({ color: 0x5C4033 }); // Darker Wood
            const shield = new THREE.Mesh(shieldGeo, shieldMat);
            group.add(shield);

            // Rim/Detail
            const paintMat = new THREE.MeshBasicMaterial({ color: 0xA0522D });
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.1, 0.06), paintMat);
            stripe.position.y = 0.1;
            stripe.position.z = 0.01;
            group.add(stripe);

            // Attach to Left Hand side
            group.position.set(-0.35, 0.6, 0.2);
            group.rotation.y = -Math.PI / 6; // Angled out

            entity.mesh.add(group);
        }

        // --- Equipment Visuals ---


        // --- Arrow System ---
        function createArrow(start, target) {
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            mesh.position.copy(start);
            mesh.lookAt(target);
            mesh.rotateX(Math.PI / 2);
            scene.add(mesh);
            return mesh;
        }

        function updateArrows(dt) {
            const speed = 20.0;
            for (let i = arrows.length - 1; i >= 0; i--) {
                const a = arrows[i];
                a.life += dt;

                const dir = new THREE.Vector3().subVectors(a.target, a.pos).normalize();
                const dist = a.mesh.position.distanceTo(a.target);

                if (dist < 0.5 || a.life > 1.0) {
                    // Hit
                    scene.remove(a.mesh);
                    arrows.splice(i, 1);

                    // Damage Area Check
                    wolves.forEach(w => {
                        if (w.hp > 0 && w.mesh.position.distanceTo(a.target) < 2.0) {
                            w.hp -= 50;
                            if (w.mesh.children[0] && w.mesh.children[0].children) {
                                w.mesh.children[0].children.forEach(m => {
                                    // Flash Effect (Optional)
                                    if (m.material) {
                                        const oldC = m.material.color.getHex();
                                        m.material.color.setHex(0xff0000);
                                        setTimeout(() => { if (m.material) m.material.color.setHex(oldC); }, 100);
                                    }
                                });
                            }
                        }
                    });

                } else {
                    a.mesh.position.add(dir.multiplyScalar(speed * dt));
                }
            }
        }




        // --- 5. Followers System ---
        const followers = [];
        // Geometries (Shared) - Scaled 0.6
        const fHeadGeo = new THREE.SphereGeometry(0.3, 16, 16);
        // Chunkier Body (was 0.2)
        const fBodyGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.4, 8);
        // Chunkier Legs (was 0.07)
        const fLegGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.4, 8);
        fLegGeo.translate(0, -0.2, 0); // Pivot top

        function createFollower(pos) {
            const group = new THREE.Group();
            group.position.copy(pos);

            // Color: White
            const mat = new THREE.MeshBasicMaterial({
                color: 0xffffff
            });

            // Scale factor 0.6 relative to player parts
            // Player: Head 1.7, Body 1.0, Leg 0.7.
            // Follower: Head 1.0, Body 0.6, Leg 0.4 (approx)
            const s = 0.6;

            const head = new THREE.Mesh(fHeadGeo, mat);
            head.position.y = 1.7 * s;
            group.add(head);

            const body = new THREE.Mesh(fBodyGeo, mat);
            body.position.y = 1.0 * s;
            group.add(body);

            const leftLeg = new THREE.Mesh(fLegGeo, mat);
            leftLeg.position.set(-0.2 * s, 0.7 * s, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(fLegGeo, mat);
            rightLeg.position.set(0.2 * s, 0.7 * s, 0);
            group.add(rightLeg);

            scene.add(group);

            const f = {
                mesh: group,
                leftLeg,
                rightLeg,
                velocity: new THREE.Vector3(),
                isFollowing: true, // Auto Follow Immediately
                waterTime: 0,
                mat: mat,
                hp: 100, // Follower Health
                maxHp: 100,
                isJumping: false,
                jumpTime: 0,
                yOffset: 0,
                vSpeed: 0,
                lastPickupTime: 0
            };

            // Equip default gear
            // Role Assignment (Depth)
            f.role = Math.random() > 0.6 ? 'archer' : 'soldier';
            if (f.role === 'archer') {
                f.hasBow = true;
                // Archer Visual: Bow
                const bowGeo = new THREE.TorusGeometry(0.3, 0.05, 8, 12, Math.PI);
                const bow = new THREE.Mesh(bowGeo, new THREE.MeshBasicMaterial({ color: 0x8B4513 }));
                bow.position.set(0.3, 0.6, 0.2); // On back/side
                bow.rotation.z = -Math.PI / 2;
                f.mesh.add(bow);

                // Light Armor (Greenish)
                if (f.mesh.children[1] && f.mesh.children[1].material) {
                    f.mesh.children[1].material = f.mesh.children[1].material.clone();
                    f.mesh.children[1].material.color.setHex(0x99cc99);
                }
            } else {
                // Soldier: Sword & Shield
                equipSword(f);
                equipShield(f);
            }

            return f;


            ;
        }


        function respawnFollowerAtChest() {
            if (!chestMesh) return;

            // Spawn outside the wall: Local Z+ direction (Z=2.4 is slightly away from wall radius 2.0)
            const localDoorPos = new THREE.Vector3(0, 0, 2.4);
            const spawnPos = localDoorPos.applyMatrix4(chestMesh.matrixWorld);

            // Snap to Ground
            const h = getSurfaceHeight(spawnPos.x, spawnPos.y, spawnPos.z);
            spawnPos.normalize().multiplyScalar(h);

            const newF = createFollower(spawnPos);
            followers.push(newF);

            // Equip if needed
            if (chestInventory.level >= 2) {
                equipSword(newF);
                equipShield(newF);
            }
        }

        function createFlyingItem(type, startPos, targetPos, taskTarget) {
            let geo = stoneGeo;
            if (type === 'twig') geo = twigGeo;
            else if (type === 'mushroom') geo = mushGeo;

            const visGeo = getVisualGeometry(geo);
            const visMat = new THREE.MeshBasicMaterial({
                vertexColors: true, side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(visGeo, visMat);
            mesh.position.copy(startPos);
            mesh.scale.setScalar(1.0);
            scene.add(mesh);

            flyingItems.push({
                mesh: mesh,
                target: targetPos,
                type: type,
                taskTarget: taskTarget
            });
        }

        function updateFollowers(dt) {
            const playerPos = carGroup.position;

            // 1. Separation Force (Avoid Overlap)
            // Simple O(N^2) check is fine for 50 entities
            const separationRadius = 0.75;

            followers.forEach(f => {
                const distToPlayer = f.mesh.position.distanceTo(playerPos);
                const up = f.mesh.position.clone().normalize();

                // Activation
                if (distToPlayer < 10.0 && !f.isFollowing) {
                    f.isFollowing = true;
                    // Trigger Recruitment Jump
                    f.vSpeed = 10.0;
                    f.yOffset = 0.1;
                }

                // Physics Forces
                const moveForce = new THREE.Vector3();

                // Player Collision
                if (distToPlayer < 1.4) {
                    const pushDir = new THREE.Vector3().subVectors(playerPos, f.mesh.position).normalize();
                    // carPhysics.pos.add(pushDir.multiplyScalar(0.001)); // User Request: Player easily pushes them (No resistance)

                    // Smooth but strong push on follower
                    const force = (1.4 - distToPlayer) * 20.0;
                    moveForce.add(pushDir.clone().negate().multiplyScalar(force));
                }

                // Wake Up Check (Wolves)
                if (!f.isFollowing) {
                    const wakeDist = f.hasSword ? 15.0 : 5.0;
                    for (let w of wolves) {
                        if (w.hp > 0 && f.mesh.position.distanceTo(w.mesh.position) < wakeDist) {
                            f.isFollowing = true;
                            f.vSpeed = 10.0;
                            f.yOffset = 0.1;
                            break;
                        }
                    }
                }

                // State Logic
                // State Logic
                // if (f.isJumping) {
                //    // Legacy Block Removed
                // } else 
                if (f.isFollowing) {
                    // Normal Following Logic

                    let target = playerPos;
                    let stopDist = 3.0;
                    let seekWeight = 1.0;

                    // --- Combat Logic (Persistent) ---
                    const aggroRange = f.hasSword ? 15.0 : 5.0;
                    const chaseLimit = 40.0;
                    const leashDistance = 12.0; // Reduced leash to force return sooner logic

                    // 0. Leash Check (Overrides Combat)
                    if (distToPlayer > leashDistance) {
                        f.combatTarget = null; // Disengage
                    }

                    // 1. Validate Current Target
                    if (f.combatTarget) {
                        if (f.combatTarget.hp <= 0 || f.mesh.position.distanceTo(f.combatTarget.mesh.position) > chaseLimit) {
                            f.combatTarget = null;
                        }
                    }

                    // 2. Scan for New Target (Only if safe distance from player)
                    if (!f.combatTarget && distToPlayer < leashDistance) {
                        let bestW = null;
                        let minD = aggroRange;

                        wolves.forEach(w => {
                            if (w.hp > 0) {
                                const d = f.mesh.position.distanceTo(w.mesh.position);
                                if (d < minD) {
                                    minD = d;
                                    bestW = w;
                                }
                            }
                        });

                        if (bestW) f.combatTarget = bestW;
                    }

                    // Adapter
                    let combatTarget = f.combatTarget;
                    let minWolfDist = combatTarget ? f.mesh.position.distanceTo(combatTarget.mesh.position) : Infinity;

                    // Restore Visuals (Remove Debug Red/White)
                    if (f.mesh.children[0] && f.mesh.children[0].material) {
                        // Reset to default material logic if needed, or just leave it. 
                        // Currently we just want to remove the debug override.
                        // We can set it back to white for safety or implement proper tinting later.
                        f.mesh.children[0].material.color.setHex(0xffffff);
                    }

                    const baseCooldown = 3.0;
                    const onCooldown = (clock.getElapsedTime() - (f.lastAttackTime || 0)) < (baseCooldown / gameState.stats.attackFreqMult);

                    // Priority 0: Combat (Only if ready or mid-attack AND within Leash)
                    // Explicitly BREAK combat if too far from player
                    if (distToPlayer > leashDistance) {
                        combatTarget = null;
                        f.combatTarget = null;
                    }

                    if (combatTarget && (!onCooldown || f.isAttacking)) {
                        target = combatTarget.mesh.position;
                        stopDist = 0.5;
                        seekWeight = 10.0;

                        // Attack Logic (Ground Thrust)
                        // ARCHER LOGIC
                        if (f.role === 'archer') {
                            stopDist = 10.0;
                            seekWeight = 1.0;
                            // Kite Loop
                            if (minWolfDist < 8.0) {
                                // Too close! Run away!
                                seekWeight = -5.0; // Flee
                                stopDist = 15.0;
                            } else if (minWolfDist > 14.0) {
                                seekWeight = 2.0;
                            }

                            // Archers attack via the auto-attack loop (updateWolves/arrows), 
                            // but we can add a specific animation trigger here if we want.
                            // For now, kiting is the main behavior change.
                        }

                        // SOLDIER LOGIC (Melee)
                        else if (minWolfDist < 1.5) { // Updated Distance to 1.5m
                            const now = clock.getElapsedTime();
                            if (now - (f.lastAttackTime || 0) > (baseCooldown / gameState.stats.attackFreqMult)) { // Cooldown adjusted by freq mult
                                f.lastAttackTime = now;
                                f.isAttacking = true;
                                audioMaster.playAttackMelee();
                                f.attackTimer = 0;
                                f.attackTargetW = combatTarget;
                                f.hasHit = false; // Initialize hit flag
                                f.attackStartPos = f.mesh.position.clone(); // Record starting point

                                // No jump - stays on ground
                                f.vSpeed = 0;
                                f.yOffset = 0;
                            }
                        }

                        // Handle Attack Animation (Thrust)
                        if (f.isAttacking) {
                            f.attackTimer += dt;

                            const thrustDuration = 0.2; // Quick impact
                            const recoveryDuration = 0.2;
                            const totalDuration = thrustDuration + recoveryDuration;

                            if (f.attackTimer < thrustDuration) {
                                // 1. THRUST PHASE
                                const progress = f.attackTimer / thrustDuration;
                                f.mesh.rotation.x = -0.5; // Tilt forward

                                // Rapidly dash towards wolf
                                const toWolf = new THREE.Vector3().subVectors(f.attackTargetW.mesh.position, f.mesh.position);
                                toWolf.projectOnPlane(up).normalize();
                                f.mesh.position.add(toWolf.multiplyScalar(30.0 * dt)); // Dash speed 30

                                // SNAP TO SURFACE to prevent clipping into the spherical planet
                                const h = getSurfaceHeight(f.mesh.position.x, f.mesh.position.y, f.mesh.position.z);
                                f.mesh.position.normalize().multiplyScalar(h);

                                // User Request: Fix orientation during dash to face target
                                const _dummy = new THREE.Object3D();
                                _dummy.position.copy(f.mesh.position);
                                _dummy.up.copy(up);
                                _dummy.lookAt(f.attackTargetW.mesh.position);
                                f.mesh.quaternion.slerp(_dummy.quaternion, 15.0 * dt);
                            } else if (f.attackTimer < totalDuration) {
                                // 2. RECOVERY PHASE
                                if (!f.hasHit) {
                                    f.hasHit = true; // Mark as hit occurred
                                    // Trigger Hit exactly at the end of thrust
                                    if (f.attackTargetW && f.attackTargetW.hp > 0) {
                                        // Damage Calculation
                                        let damage = 10.0 * gameState.stats.attackDmgMult;
                                        const isCrit = Math.random() < gameState.stats.critRate;
                                        if (isCrit) {
                                            damage *= 1.5;
                                            console.log("%c " + t('critHit'), "color: orange; font-weight: bold;");
                                        }

                                        f.attackTargetW.hp -= damage;
                                        showDamageNumber(f.attackTargetW.mesh.position, damage, 'enemy', isCrit);
                                        f.attackTargetW.flashTimer = 0.3;
                                        spawnJumpDust(f.attackTargetW.mesh.position);

                                        // Damage Log
                                        const nowMS = new Date().toISOString();
                                        console.log(t('hitLog', nowMS, "Wolf", damage.toFixed(2), f.attackTargetW.hp.toFixed(2)));

                                        if (f.attackTargetW.hp <= 0) {
                                            spawnExplosion(f.attackTargetW.mesh.position);
                                            spawnExpItem(f.attackTargetW.mesh.position);
                                            f.combatTarget = null;
                                        }
                                    }

                                    f.mesh.rotation.x = 0; // Reset tilt
                                }
                                // Slight pause after impact
                            } else {
                                f.isAttacking = false;
                            }
                        }
                    }

                    // Priority 1: Mimic Hiding (If Player is in a Bush AND Standing Still)
                    else if (isPositionHidden(playerPos) && carPhysics.velocity.length() < 0.5) {
                        let bestBush = null;
                        let minDSq = Infinity;

                        // Search for nearest bush
                        if (bushes && bushes.geometry) {
                            const bOff = bushes.geometry.attributes.offset;
                            const bSc = bushes.geometry.attributes.scale;
                            const count = bOff.count;

                            for (let i = 0; i < count; i++) {
                                // Skip deleted/invalid bushes
                                if (bSc.getX(i) < 0.1) continue;

                                const dx = bOff.getX(i) - f.mesh.position.x;
                                const dy = bOff.getY(i) - f.mesh.position.y;
                                const dz = bOff.getZ(i) - f.mesh.position.z;
                                const dSq = dx * dx + dy * dy + dz * dz;

                                if (dSq < minDSq) {
                                    minDSq = dSq;

                                    // Store coordinates to avoid object creation in loop
                                    bestBush = {
                                        x: bOff.getX(i), y: bOff.getY(i), z: bOff.getZ(i)
                                    }

                                        ;
                                }
                            }
                        }

                        if (bestBush) {
                            target = new THREE.Vector3(bestBush.x, bestBush.y, bestBush.z);
                            stopDist = 0.5; // Hide deep inside
                            seekWeight = 3.0; // High urgency
                        }
                    }

                    // Priority 2: Seek Chest if holding item
                    else if (f.heldItem) {
                        const config = levelConfig[chestInventory.level];
                        // Only if we need this item
                        if (config && config.tasks) {
                            const t = config.tasks.find(task => task.type === f.heldItem.type);
                            if (t) {
                                const current = chestInventory[t.type] || 0;
                                if (current < t.count) {
                                    target = chestMesh.position;
                                    stopDist = 2.0;
                                    seekWeight = 1.5;
                                }
                            }
                        }
                    }

                    // Execute Seek
                    const distToTarget = f.mesh.position.distanceTo(target);

                    if (distToTarget > stopDist) {
                        let dir = new THREE.Vector3().subVectors(target, f.mesh.position).normalize();
                        dir.projectOnPlane(up).normalize();
                        const speedMult = gameState ? gameState.stats.moveSpeedMult : 1.0;
                        moveForce.add(dir.multiplyScalar(seekWeight * speedMult));
                    }


                    // B. Separation (Swarm)
                    let sepForce = new THREE.Vector3();
                    let neighborCount = 0;

                    followers.forEach(neighbor => {
                        if (f === neighbor) return;
                        const d = f.mesh.position.distanceTo(neighbor.mesh.position);

                        if (d < separationRadius) {
                            const push = new THREE.Vector3().subVectors(f.mesh.position, neighbor.mesh.position).normalize();
                            // Weight by distance (closer = stronger)
                            push.divideScalar(d + 0.1);
                            sepForce.add(push);
                            neighborCount++;
                        }
                    });

                    if (neighborCount > 0) {
                        // Strong separation weight to guarantee space
                        moveForce.add(sepForce.normalize().multiplyScalar(2.5));
                    }

                    // Apply to Velocity
                    // Apply to Velocity
                    // Apply to Velocity
                    let maxSpeed = 13.65;
                    if (f.combatTarget) maxSpeed *= 1.5; // Sprint when chasing

                    // If we have any desire to move
                    if (moveForce.lengthSq() > 0.01) {
                        moveForce.normalize().multiplyScalar(maxSpeed);
                        // Smooth visual acceleration
                        f.velocity.lerp(moveForce, 2.0 * dt);
                    }

                    else {
                        // Stop
                        f.velocity.lerp(new THREE.Vector3(0, 0, 0), 2.0 * dt);
                    }

                    // Move
                    if (f.velocity.lengthSq() > 0.01) {
                        f.mesh.position.add(f.velocity.clone().multiplyScalar(dt));
                    }

                    // Chest Collision (Followers)
                    if (chestMesh) {
                        const fDist = f.mesh.position.distanceTo(chestMesh.position);

                        if (fDist < 2.4) {
                            // Updated to match Player Collision Radius (Body 2.0 + Buffer)
                            const pushDir = new THREE.Vector3().subVectors(f.mesh.position, chestMesh.position).normalize();
                            f.mesh.position.copy(chestMesh.position).add(pushDir.multiplyScalar(2.4));
                        }
                    }

                    // ALWAYS Snap & Orient (Fix Lying Down)
                    let h = getSurfaceHeight(f.mesh.position.x, f.mesh.position.y, f.mesh.position.z);

                    // --- Physics Jump Logic ---
                    if (f.yOffset === undefined) f.yOffset = 0;
                    if (f.vSpeed === undefined) f.vSpeed = 0;

                    // 1. Check Jump Signal (Global) - BEFORE Gravity
                    if (window.playerDidJumpGlobal && f.isFollowing && f.yOffset <= 0.5) {
                        f.vSpeed = 20.0; // Increased Jump Force
                        f.yOffset = 0.1; // Lift off
                        spawnJumpDust(f.mesh.position);
                    }

                    // 2. Apply Gravity
                    const gravity = -50.0;
                    f.vSpeed += gravity * dt;
                    f.yOffset += f.vSpeed * dt;

                    // 3. Ground Collision
                    if (f.yOffset <= 0) {
                        f.yOffset = 0;
                        f.vSpeed = 0;
                    }

                    // Add physics offset to surface height
                    h += f.yOffset;
                    f.mesh.position.normalize().multiplyScalar(h);

                    // Determine Forward
                    let forward;

                    if (f.velocity.lengthSq() > 0.05) {
                        forward = f.velocity.clone().normalize();
                    }

                    else {
                        // Fallback to current rotation's forward (Z)
                        forward = new THREE.Vector3(0, 0, 1).applyQuaternion(f.mesh.quaternion);
                    }

                    // Ensure Orthogonal
                    forward.projectOnPlane(up);

                    // Robust Fallback (Fix Pole/Zero Singularity)
                    if (forward.lengthSq() < 0.0001) {
                        forward.set(1, 0, 0).projectOnPlane(up);
                        if (forward.lengthSq() < 0.0001) forward.set(0, 0, 1).projectOnPlane(up);
                    }

                    forward.normalize();

                    // Rotation using LookAt (Robust)
                    const _dummy = new THREE.Object3D();
                    _dummy.position.copy(f.mesh.position);
                    _dummy.up.copy(up);
                    _dummy.lookAt(f.mesh.position.clone().add(forward));

                    f.mesh.quaternion.slerp(_dummy.quaternion, 5.0 * dt);

                    // Animation
                    // Animation
                    const speed = f.velocity.length();

                    if (speed > 0.5) {
                        // Minimum cadence: ensure legs swing at least once per 0.5s
                        const animSpeed = Math.max(speed, 8.0);
                        f.walkTime = (f.walkTime || 0) + dt * animSpeed * 1.5;
                        f.leftLeg.rotation.x = Math.sin(f.walkTime) * 1.5;
                        f.rightLeg.rotation.x = -Math.sin(f.walkTime) * 1.5;
                    }

                    else {
                        // Idle state
                        f.leftLeg.rotation.x = 0;
                        f.rightLeg.rotation.x = 0;
                    }

                    // --- Follower Water Logic ---
                    if (!f.isDead) {

                        // Only living followers check water
                        if (isPositionInWater(f.mesh.position, 1.0)) {
                            f.waterTime += dt;
                        }

                        else {
                            // Gradual Oxygen Recovery (Holding Breath Logic)
                            f.waterTime = Math.max(0, f.waterTime - dt * 10.0);
                        }

                        if (f.waterTime > 0.0) {
                            // Immediate Darkening: 0s -> 10s
                            let t = f.waterTime / 10.0;
                            if (t > 1.0) t = 1.0;
                            const c = 1.0 - t;
                            f.mat.color.setRGB(c, c, c);

                            if (f.waterTime > 10.0) {
                                f.isDead = true;
                                spawnExplosion(f.mesh.position);
                                dropItemFromDeadFollower(f); // Ensure item drops on water death too
                            }
                        }

                        else {

                            // Smooth Recovery
                            if (f.mat.color.r < 1.0) {
                                let c = f.mat.color.r + dt * 0.5; // Recover over ~2 seconds
                                if (c > 1.0) c = 1.0;
                                f.mat.color.setRGB(c, c, c);
                            }
                        }
                    }

                    // --- Interaction: Pickup & Drop ---
                    // REMOVED for pure Rogue mode
                }
            });
        }

        // --- 6. Wolf System ---
        const wolves = [];
        const arrows = []; // Projectiles

        // --- BEAR CREATION ---
        function createBear(pos, mult = 1.0, isDire = false) {
            const group = new THREE.Group();
            group.position.copy(pos);
            const baseHP = 1500; // Tanky
            group.hp = isDire ? baseHP * mult * 2.0 : baseHP * mult;
            group.isBear = true;
            group.isDire = isDire;

            // Bear Style (Brown)
            // Dire: Black/Dark Grey
            const color = isDire ? 0x221100 : 0x8B4513;
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const s = isDire ? 1.3 : 1.0;
            const bearMesh = new THREE.Group();
            bearMesh.scale.set(s, s, s);
            bearMesh.position.y = 0;
            group.add(bearMesh);

            // 1. Body (Bulkier)
            const bodyGeo = new THREE.BoxGeometry(1.4, 1.4, 2.2);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.set(0, 1.5, 0);
            bearMesh.add(body);

            // 2. Head
            const headGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 2.3, 1.3);
            const headMesh = new THREE.Mesh(headGeo, mat);
            headGroup.add(headMesh);
            bearMesh.add(headGroup);

            // 3. Snout ( wider/shorter)
            const snoutGeo = new THREE.BoxGeometry(0.6, 0.5, 0.4);
            const snout = new THREE.Mesh(snoutGeo, mat);
            snout.position.set(0, -0.3, 0.7);
            headGroup.add(snout);

            // 4. Ears (Small round)
            const earGeo = new THREE.BoxGeometry(0.3, 0.3, 0.1);
            const leftEar = new THREE.Mesh(earGeo, mat);
            leftEar.position.set(-0.5, 0.7, 0);
            headGroup.add(leftEar);
            const rightEar = new THREE.Mesh(earGeo, mat);
            rightEar.position.set(0.5, 0.7, 0);
            headGroup.add(rightEar);

            // Legs (Thick)
            const legGeo = new THREE.BoxGeometry(0.5, 1.0, 0.5);
            function createLeg(x, z) {
                const pivot = new THREE.Group();
                pivot.position.set(x, 1.0, z);
                const mesh = new THREE.Mesh(legGeo, mat);
                mesh.position.y = -0.5;
                pivot.add(mesh);
                bearMesh.add(pivot);
                return pivot;
            }
            const fl = createLeg(-0.5, 0.9);
            const fr = createLeg(0.5, 0.9);
            const bl = createLeg(-0.5, -0.9);
            const br = createLeg(0.5, -0.9);

            // Eyes (Visible for Red Eye Effect)
            const eyeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.1);
            const leftEye = new THREE.Mesh(eyeGeo, blackMat);
            leftEye.position.set(-0.35, 0.2, 0.55); // Pos on head
            const rightEye = new THREE.Mesh(eyeGeo, blackMat);
            rightEye.position.set(0.35, 0.2, 0.55);
            headGroup.add(leftEye);
            headGroup.add(rightEye);

            scene.add(group);

            const speed = 4.5 + Math.random() * 1.5;

            return {
                mesh: group,
                head: headGroup,
                snout: snout,
                // Eyes (Add dummies to prevent crash in updateWolves)
                leftEye: leftEye,
                rightEye: rightEye,
                model: bearMesh,
                fl, fr, bl, br,
                velocity: new THREE.Vector3(),
                speed: speed, // Slower than wolf
                hp: 300,
                maxHp: 300,
                flashTimer: 0,
                originalColor: mat.color.clone(),
                wanderTimer: 0,
                wanderDir: new THREE.Vector3(),
                walkTime: 0,
                combatState: 'wander',
                stateTimer: 0,
                attackDir: new THREE.Vector3(),
                hasHitTarget: false,
                orbitDir: Math.random() < 0.5 ? 1 : -1,
                eyesMat: blackMat,
                isBear: true, // Flag for logic differentiation
                jumpAttackCooldown: 0,
                isJumping: false,
                jumpVelocity: 0,
                jumpStartY: 0
            };
        }

        function createWolf(pos, mult = 1.0, isAlpha = false) {
            const group = new THREE.Group();
            group.position.copy(pos);
            const baseHP = 200;
            group.hp = isAlpha ? baseHP * mult * 2.5 : baseHP * mult;
            group.isAlpha = isAlpha;

            // Voxel Style Wolf (Grey-ish)
            // Alpha: Dark Red/Black
            const color = isAlpha ? 0x8B0000 : 0x6e7e85;
            const mat = new THREE.MeshBasicMaterial({ color: color });

            const blackMat = new THREE.MeshBasicMaterial({
                color: 0x000000
            });

            // Scale: Normal 0.67, Alpha 1.0
            const s = isAlpha ? 1.0 : 0.67;
            const wolfMesh = new THREE.Group();
            wolfMesh.scale.set(s, s, s);
            // Pivot adjustment: center of legs (y=0.5 approx) to ground (0)
            wolfMesh.position.y = 0;
            group.add(wolfMesh);

            // 1. Body
            const bodyGeo = new THREE.BoxGeometry(1.0, 1.0, 2.0);
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.set(0, 1.5, 0);
            wolfMesh.add(body);

            // 2. Head
            const headGeo = new THREE.BoxGeometry(1.0, 1.0, 1.0);
            const headGroup = new THREE.Group(); // Create a Group for the head to allow rotation
            headGroup.position.set(0, 2.2, 1.2); // Up and FWD

            const headMesh = new THREE.Mesh(headGeo, mat);
            headGroup.add(headMesh);
            wolfMesh.add(headGroup);

            // 3. Snout - Attach to HeadGroup
            const snoutGeo = new THREE.BoxGeometry(0.5, 0.4, 0.5);
            const snout = new THREE.Mesh(snoutGeo, mat);
            snout.position.set(0, -0.2, 0.75); // Relative to HeadGroup
            headGroup.add(snout);

            // 4. Ears - Attach to HeadGroup
            const earGeo = new THREE.BoxGeometry(0.3, 0.4, 0.2);
            const leftEar = new THREE.Mesh(earGeo, mat);
            leftEar.position.set(-0.3, 0.8, 0); // Relative to HeadGroup
            headGroup.add(leftEar);
            const rightEar = new THREE.Mesh(earGeo, mat);
            rightEar.position.set(0.3, 0.8, 0); // Relative to HeadGroup
            headGroup.add(rightEar);

            // 6. Eyes - Attach to HeadGroup
            const eyeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.05);
            const leftEye = new THREE.Mesh(eyeGeo, blackMat);
            // Move to FRONT face (z ~ 0.5) instead of SIDE (x ~ 0.5)
            leftEye.position.set(-0.25, 0.1, 0.51);
            headGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, blackMat);
            rightEye.position.set(0.25, 0.1, 0.51);
            headGroup.add(rightEye);

            // 5. Tail
            const tailGeo = new THREE.BoxGeometry(0.3, 0.3, 0.8);
            const tail = new THREE.Mesh(tailGeo, mat);
            tail.position.set(0, 1.8, -1.4);
            wolfMesh.add(tail);



            // 7. Legs
            const legGeo = new THREE.BoxGeometry(0.35, 1.0, 0.35);

            function createLeg(x, z) {
                const pivot = new THREE.Group();
                pivot.position.set(x, 1.0, z);
                const mesh = new THREE.Mesh(legGeo, mat);
                mesh.position.y = -0.5;
                pivot.add(mesh);
                wolfMesh.add(pivot);
                return pivot;
            }

            const fl = createLeg(-0.35, 0.8);
            const fr = createLeg(0.35, 0.8);
            const bl = createLeg(-0.35, -0.8);
            const br = createLeg(0.35, -0.8);

            scene.add(group);

            const speed = (7.0 + Math.random() * 3.0) * (isAlpha ? 1.3 : 1.0); // Faster Alpha

            return {
                mesh: group,
                head: headGroup, // Expose Head for animation
                snout: snout,    // Expose Snout for animation
                leftEye: leftEye,
                rightEye: rightEye,
                eyesMat: blackMat, // Expose Eyes Material for color change
                model: wolfMesh, // Expose Model for jumping
                fl, fr, bl, br,
                velocity: new THREE.Vector3(),
                speed: speed,
                hp: group.hp,
                maxHp: group.hp,
                isAlpha: isAlpha,
                flashTimer: 0, // Visual feedback timer
                originalColor: mat.color.clone(),
                wanderTimer: 0,
                wanderDir: new THREE.Vector3(),
                walkTime: 0,
                combatState: 'wander',
                stateTimer: 0,
                attackDir: new THREE.Vector3(),
                hasHitTarget: false,
                orbitDir: Math.random() < 0.5 ? 1 : -1
            }

                ;
        }

        function spawnWolves(count) {
            let spawned = 0;
            let attempts = 0;
            const waterHeight = planetRadius + seaLevelRef;

            while (spawned < count && attempts < count * 20) {
                attempts++;
                const v = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();

                // Avoid spawning too close to top (spawn point)
                if (v.distanceTo(new THREE.Vector3(0, 1, 0)) < 0.2) continue;

                const h = getSurfaceHeight(v.x, v.y, v.z);

                if (h > waterHeight + 1.0) {
                    const pos = v.multiplyScalar(h);
                    wolves.push(createWolf(pos));
                    spawned++;
                }
            }
        }

        spawnWolves(3);

        let damageCount = 0;
        let isDead = false;
        let lastHitTime = 0;

        // Check if a position is inside any bush (hidden)
        function isPositionHidden(pos) {
            if (!bushes || !bushes.geometry) return false;
            const offsets = bushes.geometry.attributes.offset;
            const scales = bushes.geometry.attributes.scale;
            const count = offsets.count;
            const r2 = 2.0 * 2.0; // Bush radius squared

            for (let i = 0; i < count; i++) {
                if (scales.getX(i) < 0.1) continue;
                const dx = pos.x - offsets.getX(i);
                const dy = pos.y - offsets.getY(i);
                const dz = pos.z - offsets.getZ(i);
                if (dx * dx + dy * dy + dz * dz < r2) return true;
            }

            return false;
        }

        // Helper to drop item from dead follower
        function dropItemFromDeadFollower(f) {
            const item = f.heldItem;
            if (!item) return;
            const mesh = item.sourceMesh;

            if (mesh && mesh.geometry) {
                const offsets = mesh.geometry.attributes.offset;
                const scales = mesh.geometry.attributes.scale;
                // Add Y offset + Random Scatter to ensure visibility
                const scatter = new THREE.Vector3((Math.random() - 0.5) * 2.0,
                    (Math.random() - 0.5) * 2.0,
                    (Math.random() - 0.5) * 2.0);
                // Proposed Position
                const dropPos = f.mesh.position.clone().add(scatter).normalize();

                // Snap to Surface + Offset
                const h = getSurfaceHeight(dropPos.x, dropPos.y, dropPos.z);
                dropPos.multiplyScalar(h + 0.8); // 0.8 units above ground

                offsets.setXYZ(item.sourceIndex, dropPos.x, dropPos.y, dropPos.z);
                offsets.needsUpdate = true;
                scales.setX(item.sourceIndex, item.originalScale);
                scales.needsUpdate = true;
            }
        }

        const waterLevel = planetRadius - 0.5;

        // Global Helper: Check if position is in water
        function isPositionInWater(pos, heightOffset = 0) {
            const h = getSurfaceHeight(pos.x, pos.y, pos.z);
            return (h + heightOffset) < waterLevel;
        }

        // --- Particle Explosion System ---
        const explosions = [];
        const particleGeo = new THREE.SphereGeometry(0.15, 6, 6);

        const particleMat = new THREE.MeshBasicMaterial({
            color: 0xffffff
        });

        const smokeMat = new THREE.MeshBasicMaterial({
            color: 0xffffff, transparent: true, opacity: 0.2
        });

        function spawnExplosion(pos) {
            for (let i = 0; i < 8; i++) {
                const mesh = new THREE.Mesh(particleGeo, particleMat);
                mesh.position.copy(pos);
                // Random offset
                mesh.position.x += (Math.random() - 0.5) * 0.5;
                mesh.position.y += (Math.random() - 0.5) * 0.5;
                mesh.position.z += (Math.random() - 0.5) * 0.5;

                const velocity = new THREE.Vector3(Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5).normalize().multiplyScalar(5.0 + Math.random() * 5.0);

                scene.add(mesh);

                explosions.push({
                    mesh, velocity, life: 1.0
                });
            }
        }

        function spawnJumpDust(pos) {
            for (let i = 0; i < 6; i++) {
                const mesh = new THREE.Mesh(particleGeo, smokeMat);
                mesh.position.copy(pos);

                // Spread out at feet (Tighter)
                const offset = new THREE.Vector3((Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5);
                mesh.position.add(offset);

                // Velocity: Very Slow
                const velocity = offset.clone().normalize().multiplyScalar(0.2 + Math.random() * 0.3);

                scene.add(mesh);

                explosions.push({
                    mesh, velocity, life: 0.6, scaleMult: 4.0
                });
            }
        }

        function createGroundSlamEffect(pos) {
            // Create expanding ring effect
            const ringGeo = new THREE.RingGeometry(0.1, 0.3, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);

            // Position and orient ring on surface
            ring.position.copy(pos);
            const up = pos.clone().normalize();
            ring.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), up);

            scene.add(ring);

            // Add to explosions array for animation
            explosions.push({
                mesh: ring,
                velocity: new THREE.Vector3(),
                life: 0.2,
                scaleMult: 1.0,
                isRing: true,
                startScale: 1.0,
                maxScale: 20.0
            });
        }

        function updateExplosions(dt) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const p = explosions[i];
                p.life -= dt;

                if (p.isRing) {
                    // Expanding ring animation
                    const progress = 1 - (p.life / 0.2);
                    const scale = p.startScale + (p.maxScale - p.startScale) * progress;
                    p.mesh.scale.setScalar(scale);
                    p.mesh.material.opacity = 0.8 * (1 - progress);
                } else {
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                    p.mesh.scale.setScalar(p.life * (p.scaleMult || 1.0)); // Shrink
                }

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    if (p.mesh.geometry) p.mesh.geometry.dispose();
                    if (p.mesh.material) p.mesh.material.dispose();
                    explosions.splice(i, 1);
                }
            }
        }

        // --- XP Item System ---
        const expItems = [];

        function spawnExpItem(pos) {
            const group = new THREE.Group();

            // White Base (Hexagonal Prism - 6 segments)
            // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)
            const outerGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 6);
            const outerMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const outer = new THREE.Mesh(outerGeo, outerMat);
            group.add(outer);

            // Blue Core (Hexagonal Prism - 6 segments)
            const innerGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.2, 6);
            const innerMat = new THREE.MeshBasicMaterial({ color: 0x00aaff });
            const inner = new THREE.Mesh(innerGeo, innerMat);
            // Height adjustment: sit on top of base and poke out
            inner.position.y = 0.05;
            group.add(inner);

            // Logic to snap and orient correctly to the planet surface
            const worldPos = pos.clone();
            const up = worldPos.clone().normalize();
            const h = getSurfaceHeight(worldPos.x, worldPos.y, worldPos.z);

            // Set Position: Center of model sits at 0.4 units above ground (User Request: Float higher)
            group.position.copy(up.clone().multiplyScalar(h + 0.4));

            // Set Orientation: Align the "top" of the cylinder (Y-axis) with the surface normal (Facing sky)
            // This ensures it does NOT inherit any rotation from dead entities
            group.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), up);

            scene.add(group);
            expItems.push({
                mesh: group,
                birthTime: clock.getElapsedTime(),
                basePos: group.position.clone()
            });
        }

        function updateExpItems(dt) {
            const now = clock.getElapsedTime();
            const playerPos = carGroup.position;

            for (let i = expItems.length - 1; i >= 0; i--) {
                const item = expItems[i];

                // Hover animation (Float higher)
                const hover = Math.sin(now * 3 + i) * 0.15;
                const up = item.basePos.clone().normalize();
                item.mesh.position.copy(item.basePos).add(up.multiplyScalar(hover));

                // Horizontal rotation (rotate around the surface normal Y)
                item.mesh.rotateY(dt * 2);

                // Pickup logic
                const dist = item.mesh.position.distanceTo(playerPos);
                if (dist < 2.0) {
                    addExperience(5);
                    scene.remove(item.mesh);
                    expItems.splice(i, 1);
                    continue;
                }

                // Autocollect if very old? (Optional)
                if (now - item.birthTime > 30) {
                    scene.remove(item.mesh);
                    expItems.splice(i, 1);
                }
            }
        }

        function showDamageNumber(pos, amount, type, isCrit) {
            audioMaster.playHit();
            const vector = pos.clone();
            // Offset upward slightly from character position
            const up = pos.clone().normalize();
            vector.add(up.multiplyScalar(2.0));

            vector.project(camera);
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;

            const div = document.createElement('div');
            div.className = `damage-text ${isCrit ? 'damage-crit' : (type === 'player' ? 'damage-player' : 'damage-enemy')}`;

            // Scaled size based on damage
            const baseSize = isCrit ? 26 : 18;
            const fontSize = Math.min(baseSize + amount * 0.05, 48);
            div.style.fontSize = `${fontSize}px`;

            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            div.textContent = Math.ceil(amount);

            // Random slight X offset for multiple hits
            div.style.marginLeft = `${(Math.random() - 0.5) * 40}px`;

            document.body.appendChild(div);
            setTimeout(() => div.remove(), 800);
        }

        function showFloatingXP(amount) {
            const div = document.createElement('div');
            div.className = 'xp-text';
            div.textContent = `+${amount} XP`;
            div.style.left = '50%';
            div.style.top = '60%';
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        function addExperience(amount) {
            amount = Math.ceil(amount * (gameState.stats.expGainMult || 1.0));
            gameState.exp += amount;
            showFloatingXP(amount);
            audioMaster.playPickup();

            // Level up check
            while (gameState.exp >= gameState.expToNextLevel) {
                gameState.exp -= gameState.expToNextLevel;
                gameState.roleLevel++;
                gameState.expToNextLevel = Math.ceil(gameState.expToNextLevel * 1.2);

                // Trigger Upgrade
                showRogueUpgrade();
                audioMaster.playLevelUp();
                console.log(`Leveled Up to ${gameState.roleLevel}! Next: ${gameState.expToNextLevel} XP`);

                // Add level up effect
                spawnExplosion(carGroup.position);

                // Big Level Up message
                const msg = document.getElementById('levelUpMsg');
                if (msg) {
                    msg.style.display = 'block';
                    setTimeout(() => { msg.style.display = 'none'; }, 2000);
                }
            }

            // Update XP Bar UI
            const expFill = document.getElementById('playerExpFill');
            if (expFill) {
                const pct = (gameState.exp / gameState.expToNextLevel) * 100;
                expFill.style.width = `${pct}%`;
            }

            const levelTag = document.querySelector('#playerExpUI .level-tag');
            if (levelTag) {
                levelTag.textContent = `LEVEL ${gameState.roleLevel}`;
            }
        }

        function updateWolves(dt) {
            if (isDead) return;
            if (gameState.gameOver) return;

            const playerPos = carGroup.position;

            // Start First Wave if inactive (or Loaded Game)
            if (gameState.waveState === 'waiting') {
                startNextWave();
                return;
            }

            const now = clock.getElapsedTime();

            // Check Wave End
            // If active and enemies killed
            if (gameState.waveState === 'active' && wolves.length === 0) {
                console.log("Wave Cleared!");
                startNextWave();
                return;
            }

            for (let i = wolves.length - 1; i >= 0; i--) {
                const enemy = wolves[i];
                if (enemy.hp <= 0) {
                    scene.remove(enemy.mesh);
                    wolves.splice(i, 1);
                    gameState.enemiesRemaining--;
                    audioMaster.playDeath();

                    // Drop XP Items - 2 items for wolves, 4 for bears (Doubled)
                    // Scatter randomly within 2m
                    const dropCount = enemy.isBear ? 4 : 2;
                    for (let d = 0; d < dropCount; d++) {
                        const rOffset = new THREE.Vector3(
                            (Math.random() - 0.5) * 4.0,
                            (Math.random() - 0.5) * 4.0,
                            (Math.random() - 0.5) * 4.0
                        );
                        spawnExpItem(enemy.mesh.position.clone().add(rOffset));
                    }


                    // Update UI
                    const countText = document.getElementById('enemyCountText');
                    if (countText) countText.textContent = gameState.enemiesRemaining;
                }
            }

            // No active spawning loop here anymore - all spawned at startNextWave

            // Update UI
            // Update UI (Old Dorm UI Removed)

            // Check Combat State for Audio
            let anyAggro = false;
            wolves.forEach(w => {
                if (w.combatState !== 'wander' && w.combatState !== 'waiting') {
                    anyAggro = true;
                }
            });
            audioMaster.setBattleMode(anyAggro);

            wolves.forEach(w => {
                const up = w.mesh.position.clone().normalize();

                // --- Flash Logic ---
                if (w.flashTimer > 0) {
                    w.flashTimer -= dt;
                    // Flash: 0.3 to 0.2 is white (0.1s), 0.2 to 0 is red (0.2s)
                    const flashColor = w.flashTimer > 0.2 ? 0xffffff : 0xff0000;

                    // Update all parts that use the main material
                    w.mesh.traverse(child => {
                        if (child.isMesh && child.material && child.material.color) {
                            // Don't flash black eyes
                            if (child.material !== w.eyesMat) {
                                child.material.color.setHex(flashColor);
                            }
                        }
                    });
                } else if (w.flashTimer <= 0) {
                    // Restore original grey color
                    w.mesh.traverse(child => {
                        if (child.isMesh && child.material && child.material.color) {
                            if (child.material !== w.eyesMat) {
                                child.material.color.copy(w.originalColor);
                            }
                        }
                    });
                }

                const moveForce = new THREE.Vector3();
                let currentSpeed = 0;

                // --- 1. TARGET SELECTION ---
                const isBiting = w.combatState === 'bite_attack';

                if (!isBiting) {
                    let bestTarget = null;
                    let closestDist = 17.5; // Max aggro range (25.0 * 0.7)

                    // 1a. Check Player (HIGHEST PRIORITY)
                    // Bears ignore water, wolves don't attack players in water
                    const canTargetPlayerInWater = w.isBear === true;
                    const playerInWater = isPositionInWater(playerPos);

                    if (!isPositionHidden(playerPos) && (canTargetPlayerInWater || !playerInWater)) {
                        const d = w.mesh.position.distanceTo(playerPos);

                        if (d < 12.25) {
                            // Player Aggro Range
                            closestDist = d; // Still track distance
                            bestTarget = {
                                type: 'player', pos: playerPos, mesh: carGroup
                            };
                            // Priority Lock: If found, we prefer player.
                            // Only switch to follower if player is significantly farther? 
                            // User Request: "If multiple targets, prioritize player" -> So we stick with player.
                        }
                    }

                    // 1b. Check Followers (Only if Player not found OR overrides based on logic?)
                    // User Request: "Prioritize should follow player" implies if Player is valid target, choose Player.
                    // So we only check followers if bestTarget is still null (i.e. Player not valid).
                    if (!bestTarget) {
                        followers.forEach(f => {
                            if (!f.isDead && !isPositionHidden(f.mesh.position) && !isPositionInWater(f.mesh.position)) {
                                const d = w.mesh.position.distanceTo(f.mesh.position);
                                if (d < closestDist) {
                                    closestDist = d;
                                    bestTarget = {
                                        type: 'follower', pos: f.mesh.position, mesh: f.mesh, entity: f
                                    };
                                }
                            }
                        });
                    }
                    else {
                        // Optional: If Player IS target, do we switch if follower is REALLY close? 
                        // "Prioritize player" usually means even if follower is closer, go for player.
                        // But let's say if follower is literally biting the wolf (d < 2.0) maybe self defense?
                        // For now, strict User Request: Follow Player Priority. We skip Follower check if Player is target.
                    }

                    // 1c. Check Dormitory (Lowest Priority)
                    if (!bestTarget && gameState.waveActive && chestMesh) {
                        const d = w.mesh.position.distanceTo(chestMesh.position);
                        if (d < 50.0 && d < closestDist) {
                            bestTarget = {
                                type: 'dorm', pos: chestMesh.position, mesh: chestMesh
                            };
                        }
                    }

                    w.target = bestTarget;

                    // Sync State
                    if (!w.target) {
                        if (w.combatState !== 'wander') {
                            w.combatState = 'wander';
                            w.eyesMat.color.setHex(0x000000); // Black
                        }
                    }

                    else {
                        w.eyesMat.color.setHex(0xff0000); // Red

                        if (w.combatState === 'wander') {
                            w.combatState = 'circle_fast';
                            w.stateTimer = 0;
                            w.orbitDir = Math.random() < 0.5 ? 1 : -1;
                        }
                    }
                }

                // --- BEAR JUMP ATTACK LOGIC ---
                if (w.isBear && w.target) {
                    // Update cooldown
                    if (w.jumpAttackCooldown > 0) {
                        w.jumpAttackCooldown -= dt;
                    }

                    // Check if should initiate jump attack
                    const distToTarget = w.mesh.position.distanceTo(w.target.pos);
                    if (!w.isJumping && w.jumpAttackCooldown <= 0 && distToTarget < 6 && distToTarget > 2) {
                        // Start jump
                        console.log(t('bearJump', distToTarget.toFixed(2)));
                        w.isJumping = true;
                        audioMaster.playJump();
                        w.jumpVelocity = 15; // Initial upward velocity
                        w.jumpStartY = w.mesh.position.length();
                        w.jumpAttackCooldown = 5.0; // 5 second cooldown

                        // Spread legs during jump
                        w.fl.rotation.x = -1.5;
                        w.fr.rotation.x = -1.5;
                        w.bl.rotation.x = 1.5;
                        w.br.rotation.x = 1.5;
                    }

                    // Handle jump physics
                    if (w.isJumping) {
                        const gravity = -30;
                        w.jumpVelocity += gravity * dt;

                        // Update position
                        const currentRadius = w.mesh.position.length();
                        const newRadius = currentRadius + w.jumpVelocity * dt;
                        w.mesh.position.normalize().multiplyScalar(newRadius);

                        // Check if landed
                        const surfaceHeight = getSurfaceHeight(w.mesh.position.x, w.mesh.position.y, w.mesh.position.z);
                        if (newRadius <= surfaceHeight) {
                            // Landed!
                            console.log(t('bearLand'));
                            audioMaster.playAttackMelee(); // Slam sound
                            w.isJumping = false;
                            w.jumpVelocity = 0;
                            w.mesh.position.normalize().multiplyScalar(surfaceHeight);

                            // Reset legs
                            w.fl.rotation.x = 0;
                            w.fr.rotation.x = 0;
                            w.bl.rotation.x = 0;
                            w.br.rotation.x = 0;

                            // Ground slam damage - INCREASED RADIUS
                            const slamRadius = 6.0; // Increased from 4.0 to 6.0
                            const slamDamage = 10;

                            // Check player
                            const playerDist = w.mesh.position.distanceTo(carGroup.position);
                            console.log(`Player distance from slam: ${playerDist.toFixed(2)}m (radius: ${slamRadius}m)`);

                            // Check if player is dodging by jumping
                            const pPos = carGroup.position;
                            const groundH = getSurfaceHeight(pPos.x, pPos.y, pPos.z);
                            const pHeight = pPos.length();
                            const playerHeightAboveGround = pHeight - groundH;
                            const isDodging = playerHeightAboveGround > 0.8; // Corrected threshold

                            if (playerDist <= slamRadius) {
                                if (isDodging) {
                                    console.log(t('playerDodge', playerHeightAboveGround.toFixed(2)));
                                } else {
                                    chestInventory.hp -= slamDamage;
                                    showDamageNumber(carGroup.position, slamDamage, 'player', false);
                                    console.log(t('bearHitPlayer', chestInventory.hp.toFixed(1), chestInventory.maxHp));

                                    // Update player health UI
                                    const healthFill = document.getElementById('playerHealthFill');
                                    if (healthFill) {
                                        const healthPercent = (chestInventory.hp / chestInventory.maxHp) * 100;
                                        healthFill.style.width = healthPercent + '%';
                                    }

                                    if (chestInventory.hp <= 0) {
                                        if (typeof handleDeath === 'function') handleDeath();
                                        else if (typeof gameOver === 'function') gameOver();
                                        else console.error("Death handler not found");
                                    }
                                }
                            }

                            // Check followers
                            let followersHit = 0;
                            followers.forEach(f => {
                                if (!f.isDead) {
                                    const fDist = w.mesh.position.distanceTo(f.mesh.position);
                                    const fIsDodging = (f.yOffset || 0) > 0.8;

                                    if (fDist <= slamRadius) {
                                        if (fIsDodging) {
                                            // Follower dodged!
                                        } else {
                                            followersHit++;
                                            f.hp -= slamDamage;
                                            if (f.hp <= 0) {
                                                f.isDead = true;
                                                f.hp = 0;
                                            }
                                        }
                                    }
                                }
                            });
                            if (followersHit > 0) {
                                console.log(t('bearHitFollowers', followersHit));
                            }

                            // Create expanding circle effect
                            createGroundSlamEffect(w.mesh.position);
                            shakeCamera(0.5); // JUICE: Shake on slam
                        }
                    }
                }

                // HIT STOP CHECK
                if (window.hitStopTimer > 0) return;

                // --- 2. BEHAVIOR STATE MACHINE ---
                // Skip normal movement when bear is jumping
                if (!(w.isBear && w.isJumping)) {
                    if (w.combatState === 'wander') {
                        currentSpeed = 2.8; // Reduced 20% from 3.5
                        w.wanderTimer -= dt;

                        if (w.wanderTimer <= 0) {
                            w.wanderTimer = 2.0 + Math.random() * 3.0;
                            const r = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                            r.projectOnPlane(up).normalize();
                            w.wanderDir = r;
                        }

                        // Simple Avoidance: Predict if walking into water
                        const futurePos = w.mesh.position.clone().add(w.wanderDir.clone().multiplyScalar(2.0));

                        if (isPositionInWater(futurePos, 0.0)) {
                            // Turn around / Randomize
                            w.wanderDir.negate().add(new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).multiplyScalar(0.5)).normalize();
                            w.wanderDir.projectOnPlane(up).normalize();
                        }

                        moveForce.add(w.wanderDir);
                    }

                    else {
                        // COMBAT
                        let targetPos = w.target ? w.target.pos : w.mesh.position;
                        let distToTarget = w.target ? w.mesh.position.distanceTo(targetPos) : 0;
                        let dirToTarget = w.target ? new THREE.Vector3().subVectors(targetPos, w.mesh.position).normalize() : new THREE.Vector3(1, 0, 0);

                        w.stateTimer += dt;

                        const tangent = new THREE.Vector3().crossVectors(dirToTarget, up).normalize().multiplyScalar(w.orbitDir);

                        if (w.combatState === 'circle_fast') {
                            currentSpeed = 5.6; // Reduced 20% from 7.0

                            if (w.stateTimer > 1.8) { // Increased wait (slower updates)
                                // FAST AGGRESSION (was 3.5)
                                w.combatState = 'circle_slow';
                                w.stateTimer = 0;
                            }

                            const radiusError = distToTarget - 8.0;
                            moveForce.copy(tangent).multiplyScalar(1.0);
                            moveForce.add(dirToTarget.multiplyScalar(radiusError * 0.2));

                        }

                        else if (w.combatState === 'circle_slow') {
                            currentSpeed = 2.0; // Reduced 20% from 2.5

                            if (w.stateTimer > 1.0) { // Increased wait before attacking (0.7 -> 1.0)
                                // Telegraph before dash
                                w.combatState = 'telegraph';
                                w.stateTimer = 0;
                            }

                            const radiusError = distToTarget - 7.0;
                            moveForce.copy(tangent).multiplyScalar(1.0);
                            moveForce.add(dirToTarget.multiplyScalar(radiusError * 0.5));

                        }

                        else if (w.combatState === 'telegraph') {
                            currentSpeed = 0; // Stop
                            moveForce.set(0, 0, 0);
                            w.velocity.set(0, 0, 0); // Immediate stop

                            // Force body to face target during telegraph
                            if (w.target) {
                                const targetPos = w.target.pos.clone();
                                const toTarget = new THREE.Vector3().subVectors(targetPos, w.mesh.position).normalize().projectOnPlane(up).normalize();
                                const _dummy = new THREE.Object3D();
                                _dummy.position.copy(w.mesh.position);
                                _dummy.up.copy(up);
                                _dummy.lookAt(w.mesh.position.clone().add(toTarget));
                                w.mesh.quaternion.slerp(_dummy.quaternion, 10.0 * dt);
                            }

                            // Mouth (Snout) Animation: Open/Close 2 times
                            // stateTimer is 1.0s total.
                            // Open at 0.1-0.3, 0.5-0.7
                            const mouthOpen = (w.stateTimer > 0.1 && w.stateTimer < 0.3) || (w.stateTimer > 0.5 && w.stateTimer < 0.7);
                            if (mouthOpen) {
                                w.snout.rotation.x = 0.5; // "Open"
                                w.head.rotation.x = -0.2; // Tilt head up
                            } else {
                                w.snout.rotation.x = 0;
                                w.head.rotation.x = 0;
                            }

                            // Eyes: Enlarge and Flash
                            const eyeScale = 1.0 + Math.sin(w.stateTimer * 20.0) * 0.5;
                            w.leftEye.scale.set(eyeScale, eyeScale, 1.0);
                            w.rightEye.scale.set(eyeScale, eyeScale, 1.0);

                            // Color Flash (Red/White)
                            const flashRed = Math.sin(w.stateTimer * 30.0) > 0;
                            w.eyesMat.color.setHex(flashRed ? 0xff0000 : 0xffffff);

                            if (w.stateTimer > 1.0) {
                                w.combatState = 'dash';
                                w.stateTimer = 0;
                                // Reset eyes scale and mat
                                w.leftEye.scale.set(1, 1, 1);
                                w.rightEye.scale.set(1, 1, 1);
                                w.eyesMat.color.setHex(0xff0000);
                            }
                        }

                        else if (w.combatState === 'dash') {
                            currentSpeed = 8.0; // Reduced 20% from 10.0

                            if (w.target && distToTarget < 3.5) {
                                w.combatState = 'bite_attack';
                                w.stateTimer = 0;
                                w.attackDir.copy(dirToTarget); // Lock direction
                                w.hitCount = 0;
                            }

                            else if (w.stateTimer > 1.5) {
                                w.combatState = 'circle_fast';
                                w.stateTimer = 0;
                                w.orbitDir *= -1;
                            }

                            moveForce.copy(dirToTarget);

                        }

                        else if (w.combatState === 'bite_attack') {
                            currentSpeed = 4.8; // Reduced 20% from 6.0
                            if (!w.hitTargets) w.hitTargets = [];

                            // Check Dodge (Player Dash)
                            if (carPhysics.isDashing) {
                                // Player is Invincible
                            } else {
                                // Normal Logic...
                            }
                            // Note: ideally set when entering state, but lazy init works
                            if (!w.hitTargets) w.hitTargets = [];

                            // Jump Anim
                            const jumpDuration = 0.5;
                            let jumpY = 0;

                            if (w.stateTimer < jumpDuration) {
                                const t = w.stateTimer / jumpDuration;
                                jumpY = 4.0 * 1.0 * t * (1.0 - t);
                            }

                            if (w.model) w.model.position.y = jumpY;

                            // Shake Head (Bite)
                            if (w.stateTimer > 0.1 && w.stateTimer < 0.4) {
                                w.head.rotation.y = Math.sin(w.stateTimer * 40.0) * 0.6;
                            }

                            else {
                                w.head.rotation.y = 0;
                            }

                            // End
                            if (w.stateTimer > jumpDuration) {
                                w.combatState = 'circle_fast';
                                w.stateTimer = 0;
                                w.orbitDir *= -1;
                                if (w.model) w.model.position.y = 0;
                                w.hitTargets = []; // Clear for next time
                            }
                        }
                        // SPEED MODIFIER FOR BEARS (Slower/Tankier)
                        if (w.isBear) {
                            currentSpeed *= 0.6;
                        }
                    }


                    // --- 3. COLLISIONS & INTERACTION ---

                    // Wolf Separation
                    wolves.forEach(neighbor => {
                        if (w === neighbor) return;
                        const d = w.mesh.position.distanceTo(neighbor.mesh.position);

                        if (d < 1.25) {
                            const push = new THREE.Vector3().subVectors(w.mesh.position, neighbor.mesh.position).normalize();
                            moveForce.add(push.multiplyScalar(3.0 / (d + 0.1)));
                        }
                    });



                    // Follower Collision
                    followers.forEach(f => {
                        const d = w.mesh.position.distanceTo(f.mesh.position);

                        // Bear Collision Radius is bigger
                        const colDist = w.isBear ? 1.8 : 1.2;

                        if (d < colDist) {
                            // Collision Radius
                            const pushDir = new THREE.Vector3().subVectors(f.mesh.position, w.mesh.position).normalize();
                            // Smooth Push (Velocity Impulse)
                            const pushStrength = (1.2 - d) * 15.0; // Stronger when closer usually, but strict impulse is fine
                            f.velocity.add(pushDir.multiplyScalar(pushStrength * dt * 10.0));

                            // Wolf barely feels it
                            moveForce.add(pushDir.clone().negate().multiplyScalar(1.0));
                        }

                        if (!w.isBear && w.combatState === 'bite_attack' && w.stateTimer > 0.1 && w.stateTimer < 0.4) {
                            // Followers are INVINCIBLE during their own attack dash
                            if ((w.hitCount === undefined || w.hitCount < 5) && d < 1.5 && !f.isDead && !f.isAttacking) {
                                // Check if already hit THIS follower this swing
                                if (!w.hitTargets.includes(f)) {
                                    if (!isPositionHidden(f.mesh.position) && !isPositionInWater(f.mesh.position)) {
                                        w.hitTargets.push(f); // Mark hit
                                        if (f.hasHat) {
                                            f.hasHat = false;
                                            if (f.hatMesh) { f.mesh.remove(f.hatMesh); f.hatMesh = null; }
                                            w.hitCount = (w.hitCount || 0) + 1;
                                            // Visual feedback? Hat pop sound?
                                        } else {
                                            // New HP Logic for Followers
                                            let dmg = 34.0; // Base wolf damage to followers (approx 3 hits to kill 100hp)
                                            // Apply Defense
                                            dmg *= (1.0 / gameState.stats.defenseMult);

                                            f.hp -= dmg;
                                            showDamageNumber(f.mesh.position, dmg, 'player', false);

                                            // Visual Feedback
                                            if (f.mesh.children[0] && f.mesh.children[0].material) {
                                                f.mesh.children[0].material.color.setHex(0xff0000);
                                                setTimeout(() => { if (f.mesh.children[0]) f.mesh.children[0].material.color.setHex(0xffffff); }, 200);
                                            }

                                            w.hitCount = (w.hitCount || 0) + 1;

                                            if (f.hp <= 0) {
                                                f.isDead = true;
                                                audioMaster.playDeath();
                                                spawnExplosion(f.mesh.position);
                                                dropItemFromDeadFollower(f);

                                                // Damage Log
                                                const nowMS = new Date().toISOString();
                                                console.log(`[${nowMS}] Wolf Eat Follower: FATAL`);
                                            } else {
                                                spawnJumpDust(f.mesh.position); // mild hit effect
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });

                    // Player Collision
                    const dPlayer = w.mesh.position.distanceTo(playerPos);

                    if (dPlayer < 1.0) {
                        const pushDir = new THREE.Vector3().subVectors(playerPos, w.mesh.position).normalize();
                        carPhysics.pos.add(pushDir.multiplyScalar(0.05));

                        if (w.combatState !== 'bite_attack') {
                            moveForce.add(pushDir.clone().negate().multiplyScalar(10.0));
                        }
                    }

                    // Player Damage Logic
                    // Player Damage Logic
                    if (!w.isBear && w.combatState === 'bite_attack' && w.stateTimer > 0.1 && w.stateTimer < 0.4) {
                        if ((w.hitCount === undefined || w.hitCount < 5) && dPlayer < 1.25 && (!carPhysics.isDashing)) {
                            // Check player hit
                            if (!w.hitTargets.includes(carPhysics)) {
                                if (!isPositionHidden(playerPos) && !isPositionInWater(playerPos)) {
                                    w.hitTargets.push(carPhysics);

                                    // Safe if hidden or in water
                                    if (now - lastHitTime > 1.0) {
                                        lastHitTime = now;
                                        w.hitCount = (w.hitCount || 0) + 1;
                                        if (carPhysics.hasHat) {
                                            carPhysics.hasHat = false;
                                            if (carPhysics.hatMesh) { carGroup.remove(carPhysics.hatMesh); carPhysics.hatMesh = null; }
                                        } else {
                                            // Player Damage (Non-Fatal)
                                            let dmg = 20;
                                            // Apply Defense
                                            dmg *= (1.0 / gameState.stats.defenseMult);

                                            chestInventory.hp -= dmg;
                                            showDamageNumber(carGroup.position, dmg, 'player', false);

                                            if (chestInventory.hp <= 0) {
                                                audioMaster.playDeath();
                                                handleDeath();
                                            }

                                            // Damage Log
                                            const nowMS = new Date().toISOString();
                                            console.log(`[${nowMS}] Wolf Bite Player: Damage=${dmg.toFixed(1)}, HP=${chestInventory.hp.toFixed(1)}`);
                                        }
                                    }
                                }
                            }
                        }

                        // Dormitory Damage Logic Removed
                    }

                    // --- GLOBAL HEAD LOOK LOGIC ---
                    // Only if NOT biting/shaking
                    const isShaking = (w.combatState === 'bite_attack' && w.stateTimer > 0.1 && w.stateTimer < 0.4);

                    if (!isShaking) {
                        let targetHeadY = 0;

                        if (w.target) {
                            const targetPos = w.target.pos.clone();
                            const lookDir = new THREE.Vector3().subVectors(targetPos, w.mesh.position).normalize();
                            const localLook = lookDir.applyQuaternion(w.mesh.quaternion.clone().invert());
                            const angle = Math.atan2(localLook.x, localLook.z);
                            // +/- 60 degrees
                            const limit = 1.05;
                            let clampedAngle = angle;
                            if (clampedAngle > limit) clampedAngle = limit;
                            if (clampedAngle < -limit) clampedAngle = -limit;

                            const seed = w.mesh.id * 0.1;
                            const time = clock.getElapsedTime();
                            const interest = (Math.sin(time * 0.8 + seed) + 1.0) / 2.0;

                            // Look if interested AND target is generally in front
                            if (interest > 0.4 && Math.abs(angle) < 2.5) {
                                targetHeadY = clampedAngle;
                            }
                        }

                        // Smooth Transition
                        const diff = targetHeadY - w.head.rotation.y;
                        w.head.rotation.y += diff * dt * 5.0;
                    }

                    // General Water Avoidance (Reflex)
                    // --- Water Logic (Escape & Avoidance) ---
                    const surfaceH = getSurfaceHeight(w.mesh.position.x, w.mesh.position.y, w.mesh.position.z);

                    if (surfaceH < waterLevel) {
                        // EMERGENCY: IN WATER -> ESCAPE
                        w.combatState = 'wander'; // Stop fighting, start swimming
                        w.target = null;

                        // Find "Uphill" direction (Gradient Ascent)
                        let bestDir = new THREE.Vector3();
                        let maxH = -10000;
                        const sampleDist = 2.0;

                        const dirs = [new THREE.Vector3(0, 0, 1),
                        new THREE.Vector3(0, 0, -1),
                        new THREE.Vector3(1, 0, 0),
                        new THREE.Vector3(-1, 0, 0)];

                        dirs.forEach(d => {
                            const worldDir = d.clone().applyQuaternion(w.mesh.quaternion).normalize();
                            const probe = w.mesh.position.clone().add(worldDir.multiplyScalar(sampleDist));
                            const h = getSurfaceHeight(probe.x, probe.y, probe.z);

                            if (h > maxH) {
                                maxH = h;
                                bestDir = worldDir;
                            }
                        });

                        // Apply strong force towards highest ground
                        moveForce.add(bestDir.multiplyScalar(20.0));

                    }

                    else if (surfaceH < waterLevel + 0.5) {
                        // ON LAND, NEAR WATER -> AVOIDANCE (Reflex)
                        const lookAhead = w.mesh.position.clone().add(w.velocity.clone().normalize().multiplyScalar(1.0));
                        const nextH = getSurfaceHeight(lookAhead.x, lookAhead.y, lookAhead.z);

                        if (nextH < waterLevel) {
                            // Reverse hard
                            const back = w.velocity.clone().negate().normalize().multiplyScalar(15.0);
                            moveForce.add(back);
                        }
                    }

                    // Apply Physics
                    if (moveForce.lengthSq() > 0.01) {
                        moveForce.projectOnPlane(up).normalize().multiplyScalar(currentSpeed);
                        const lerpFactor = w.combatState === 'bite_attack' ? 2.0 * dt : 3.0 * dt;
                        w.velocity.lerp(moveForce, lerpFactor);
                    }

                    else {
                        w.velocity.lerp(new THREE.Vector3(0, 0, 0), 3.0 * dt);
                    }

                    w.mesh.position.add(w.velocity.clone().multiplyScalar(dt));

                    // Ground Snap & Orient
                    const h = getSurfaceHeight(w.mesh.position.x, w.mesh.position.y, w.mesh.position.z);
                    w.mesh.position.normalize().multiplyScalar(h);

                    // Chest Collision Removed

                    if (w.combatState !== 'bite_attack') {
                        let forward = w.velocity.clone().normalize();
                        forward.projectOnPlane(up);
                        if (forward.lengthSq() < 0.001) forward = new THREE.Vector3(0, 0, 1).applyQuaternion(w.mesh.quaternion).projectOnPlane(up);
                        forward.normalize();
                        const _dummy = new THREE.Object3D();
                        _dummy.position.copy(w.mesh.position);
                        _dummy.up.copy(up);
                        _dummy.lookAt(w.mesh.position.clone().add(forward));
                        w.mesh.quaternion.slerp(_dummy.quaternion, 8.0 * dt);

                        // Anim Legs
                        const speed = w.velocity.length();

                        if (speed > 0.5) {
                            w.walkTime += dt * speed * 2.0;
                            const s = Math.sin(w.walkTime);
                            w.fl.rotation.x = s; w.br.rotation.x = s;
                            w.fr.rotation.x = -s; w.bl.rotation.x = -s;
                        }

                        else {
                            w.fl.rotation.x = 0; w.br.rotation.x = 0; w.fr.rotation.x = 0; w.bl.rotation.x = 0;
                        }
                    }

                    else {
                        w.fl.rotation.x = 0; w.br.rotation.x = 0; w.fr.rotation.x = 0; w.bl.rotation.x = 0;
                    }
                } // End of !(w.isBear && w.isJumping) check
            });

            // Cleanup Dead Wolves
            for (let i = wolves.length - 1; i >= 0; i--) {
                if (wolves[i].hp <= 0) {
                    scene.remove(wolves[i].mesh);
                    wolves.splice(i, 1);
                }
            }

            // Update Arrows
            updateArrows(dt);

            // Auto-Attack Logic
            [carPhysics, ...followers].forEach(entity => {
                if (entity.hasBow) {
                    entity.bowTimer = (entity.bowTimer || 0) + dt;
                    if (entity.bowTimer > 1.0) {
                        let nearWolf = null;
                        let minWD = 15.0;
                        wolves.forEach(wolf => {
                            if (wolf.hp <= 0) return;
                            const d = (entity === carPhysics ? carGroup.position : entity.mesh.position).distanceTo(wolf.mesh.position);
                            if (d < minWD) {
                                minWD = d;
                                nearWolf = wolf;
                            }
                        });

                        if (nearWolf) {
                            entity.bowTimer = 0;
                            audioMaster.playAttackBow();
                            const start = (entity === carPhysics ? carGroup.position : entity.mesh.position).clone().add(new THREE.Vector3(0, 1, 0));
                            const target = nearWolf.mesh.position.clone().add(new THREE.Vector3(0, 0.5, 0));
                            arrows.push({
                                mesh: createArrow(start, target),
                                pos: start,
                                target: target,
                                life: 0
                            });
                        }
                    }
                }
            });
        }

        function createArrow(start, target) {
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            mesh.position.copy(start);
            mesh.lookAt(target);
            mesh.rotateX(Math.PI / 2);
            scene.add(mesh);
            return mesh;
        }

        function updateArrows(dt) {
            const speed = 20.0;
            for (let i = arrows.length - 1; i >= 0; i--) {
                const a = arrows[i];
                a.life += dt;

                const dir = new THREE.Vector3().subVectors(a.target, a.pos).normalize();
                const dist = a.mesh.position.distanceTo(a.target);

                if (dist < 0.5 || a.life > 1.0) {
                    // Hit
                    scene.remove(a.mesh);
                    arrows.splice(i, 1);

                    // Damage Area Check
                    wolves.forEach(w => {
                        if (w.hp > 0 && w.mesh.position.distanceTo(a.target) < 2.0) {
                            const dmg = 500;
                            w.hp -= dmg;
                            showDamageNumber(w.mesh.position, dmg, 'enemy', false);

                            // Damage Log
                            const nowMS = new Date().toISOString();
                            console.log(`[${nowMS}] Archer Arrow Hit Wolf: Damage=${dmg}, TargetHP=${w.hp}`);
                            if (w.mesh.children[0] && w.mesh.children[0].children) {
                                w.mesh.children[0].children.forEach(m => {
                                    if (m.material) {
                                        const oldC = m.material.color.getHex();
                                        m.material.color.setHex(0xff0000);
                                        setTimeout(() => { if (m.material) m.material.color.setHex(oldC); }, 100);
                                    }
                                });
                            }
                        }
                    });

                } else {
                    a.mesh.position.add(dir.multiplyScalar(speed * dt));
                }
            }
        }

        function updateWolvesLegacy(dt) {
            if (isDead) return;

            const playerPos = carGroup.position;
            const now = clock.getElapsedTime();

            wolves.forEach(w => {
                const distToPlayer = w.mesh.position.distanceTo(playerPos);
                const moveForce = new THREE.Vector3();
                const up = w.mesh.position.clone().normalize();
                let currentSpeed = w.speed;

                // --- Combat State Machine ---
                if (distToPlayer < 17.5) {
                    // Enter Combat
                    w.eyesMat.color.setHex(0xff0000); // Red Eyes

                    if (w.combatState === 'wander') {
                        w.combatState = 'circle_fast';
                        w.stateTimer = 0;
                        w.orbitDir = Math.random() < 0.5 ? 1 : -1; // Pick direction
                    }

                    w.stateTimer += dt;
                    const vecToPlayer = new THREE.Vector3().subVectors(playerPos, w.mesh.position);
                    const dirToPlayer = vecToPlayer.clone().normalize();
                    // Tangent for orbiting (Cross Up)
                    const tangent = new THREE.Vector3().crossVectors(dirToPlayer, up).normalize().multiplyScalar(w.orbitDir);

                    if (w.combatState === 'circle_fast') {
                        // Fast Orbit
                        // Duration: 3.5s
                        currentSpeed = 9.0;

                        if (w.stateTimer > 3.5) {
                            w.combatState = 'circle_slow';
                            w.stateTimer = 0;
                        }

                        // Orbit movement (Spiral in slightly to ~8.0 distance)
                        const desiredRadius = 8.0;
                        const radiusError = distToPlayer - desiredRadius;

                        // Mix Tangent + Radial
                        // If far, pull in. If close, push out.
                        moveForce.copy(tangent).multiplyScalar(1.0);
                        moveForce.add(dirToPlayer.multiplyScalar(radiusError * 0.2));

                    }

                    else if (w.combatState === 'circle_slow') {
                        // Slow Stalk
                        // Duration: 4.0s
                        currentSpeed = 3.0; // Very slow, creeping (unchanged)

                        if (w.stateTimer > 4.0) {
                            w.combatState = 'dash';
                            w.stateTimer = 0;
                        }

                        // Maintain distance tightly
                        const desiredRadius = 7.0;
                        const radiusError = distToPlayer - desiredRadius;
                        moveForce.copy(tangent).multiplyScalar(1.0);
                        moveForce.add(dirToPlayer.multiplyScalar(radiusError * 0.5));

                    }

                    else if (w.combatState === 'dash') {
                        // Attack!
                        currentSpeed = 12.0;

                        // Trigger Jump Attack if close
                        if (distToPlayer < 3.5) {
                            w.combatState = 'bite_attack';
                            w.stateTimer = 0;
                            // Lock Attack Direction!
                            w.attackDir.copy(dirToPlayer);
                            w.hasHitTarget = false; // Reset hit flag for this attack
                        }

                        else if (w.stateTimer > 2.0) {
                            // Missed -> Reset cycle
                            w.combatState = 'circle_fast';
                            w.stateTimer = 0;
                            w.orbitDir *= -1; // Switch direction
                        }

                        // Pure pursuit
                        moveForce.copy(dirToPlayer);

                    }

                    else if (w.combatState === 'bite_attack') {
                        // SPECIAL ATTACK: Jump, Shake, Bite
                        currentSpeed = 8.0; // Moderate DASH forward

                        // Force Move towards LOCKED direction (Dash)
                        moveForce.copy(w.attackDir);

                        // 1. Jump Animation (Parabolic Y offset)
                        // Duration 0.5s. Jump height 1.0.
                        // Parabola: 4 * h * t * (1-t)
                        const jumpDuration = 0.5;
                        let jumpY = 0;

                        if (w.stateTimer < jumpDuration) {
                            const t = w.stateTimer / jumpDuration;
                            jumpY = 4.0 * 1.0 * t * (1.0 - t);
                        }

                        if (w.model) w.model.position.y = jumpY;

                        // 2. Head Shake (The "Tear" action)
                        // Active window: 0.1 to 0.4
                        if (w.stateTimer > 0.1 && w.stateTimer < 0.4) {
                            w.head.rotation.y = Math.sin(w.stateTimer * 40.0) * 0.6; // Violent shake

                            // 3. DAMAGE CHECK (Only active here)
                            if (!w.hasHitTarget && distToPlayer < 1.25) {
                                if (now - lastHitTime > 1.0) {
                                    lastHitTime = now;
                                    damageCount++;
                                    w.hasHitTarget = true; // Mark attack as consumed

                                    const g = Math.max(0, 1.0 - damageCount * 0.2);
                                    charMat.color.setRGB(1.0, g, g);

                                    if (damageCount >= 3) {
                                        handleDeath();
                                    }
                                }
                            }
                        }

                        else {
                            // Reset head
                            w.head.rotation.y = 0;
                        }

                        // End of attack
                        if (w.stateTimer > jumpDuration) {
                            w.combatState = 'circle_fast';
                            w.stateTimer = 0;
                            w.orbitDir *= -1;
                            if (w.model) w.model.position.y = 0;
                        }
                    }

                }

                else {
                    // Out of range -> Wander
                    w.combatState = 'wander';
                    w.eyesMat.color.setHex(0x000000); // Black Eyes
                    currentSpeed = 6.0;

                    w.wanderTimer -= dt;

                    if (w.wanderTimer <= 0) {
                        w.wanderTimer = 2.0 + Math.random() * 3.0;
                        const r = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                        r.projectOnPlane(up).normalize();
                        w.wanderDir = r;
                    }

                    moveForce.add(w.wanderDir);
                }

                // Separation (Wolves vs Wolves)
                wolves.forEach(neighbor => {
                    if (w === neighbor) return;
                    const d = w.mesh.position.distanceTo(neighbor.mesh.position);

                    if (d < 1.25) {
                        const push = new THREE.Vector3().subVectors(w.mesh.position, neighbor.mesh.position).normalize();
                        moveForce.add(push.multiplyScalar(3.0 / (d + 0.1)));
                    }
                });

                // Collision: Wolf vs Followers
                followers.forEach(f => {
                    const d = w.mesh.position.distanceTo(f.mesh.position);

                    if (d < 0.9) {
                        // Collision Radius
                        const pushDir = new THREE.Vector3().subVectors(f.mesh.position, w.mesh.position).normalize();
                        // Push follower away
                        f.mesh.position.add(pushDir.multiplyScalar(0.1)); // Directly nudge position
                        // Wolf also nudged back slightly
                        moveForce.add(pushDir.clone().negate().multiplyScalar(5.0));
                    }

                    // KILL CHECK: If wolf is biting and close
                    if (w.combatState === 'bite_attack' && w.stateTimer > 0.1 && w.stateTimer < 0.4) {
                        if (!w.hasHitTarget && d < 1.5) {
                            f.isDead = true;
                            w.hasHitTarget = true; // Mark attack as consumed

                            // Prop Drop Logic: Restore held item to ground
                            if (f.heldItem) {
                                const item = f.heldItem;
                                const mesh = item.sourceMesh;

                                if (mesh && mesh.geometry) {
                                    const offsets = mesh.geometry.attributes.offset;
                                    const scales = mesh.geometry.attributes.scale;
                                    // Drop at follower's current position
                                    offsets.setXYZ(item.sourceIndex, f.mesh.position.x, f.mesh.position.y, f.mesh.position.z);
                                    offsets.needsUpdate = true;
                                    // Restore scale
                                    scales.setX(item.sourceIndex, item.originalScale);
                                    scales.needsUpdate = true;
                                }
                            }
                        }
                    }
                });

                // Collision: Wolf vs Player (PHYSICS ONLY, NO DAMAGE)
                // Use larger radius for physics collision
                const dPlayer = w.mesh.position.distanceTo(playerPos);

                if (dPlayer < 1.0) {
                    const pushDir = new THREE.Vector3().subVectors(playerPos, w.mesh.position).normalize();
                    // Push Player 
                    carPhysics.pos.add(pushDir.multiplyScalar(0.05));

                    // Wolf bounce back (unless biting)
                    if (w.combatState !== 'bite_attack') {
                        moveForce.add(pushDir.clone().negate().multiplyScalar(10.0));
                    }
                }

                // Apply Physics
                // Allow movement even during bite_attack (Dash in air)
                if (moveForce.lengthSq() > 0.01) {
                    moveForce.projectOnPlane(up).normalize().multiplyScalar(currentSpeed);
                    // Less control in air (bite_attack), otherwise snappy
                    const lerpFactor = w.combatState === 'bite_attack' ? 2.0 * dt : 3.0 * dt;
                    w.velocity.lerp(moveForce, lerpFactor);
                }

                else {
                    w.velocity.lerp(new THREE.Vector3(0, 0, 0), 3.0 * dt);
                }

                w.mesh.position.add(w.velocity.clone().multiplyScalar(dt));

                // Ground Snap
                const h = getSurfaceHeight(w.mesh.position.x, w.mesh.position.y, w.mesh.position.z);
                w.mesh.position.normalize().multiplyScalar(h);

                // Orient
                // Don't change orientation during jump/bite to keep aiming at player
                if (w.combatState !== 'bite_attack') {
                    let forward = w.velocity.clone().normalize();
                    forward.projectOnPlane(up);
                    if (forward.lengthSq() < 0.001) forward = new THREE.Vector3(0, 0, 1).applyQuaternion(w.mesh.quaternion).projectOnPlane(up);
                    forward.normalize();

                    const _dummy = new THREE.Object3D();
                    _dummy.position.copy(w.mesh.position);
                    _dummy.up.copy(up);
                    _dummy.lookAt(w.mesh.position.clone().add(forward));
                    w.mesh.quaternion.slerp(_dummy.quaternion, 8.0 * dt);
                }

                // Animation
                const speed = w.velocity.length();

                if (speed > 0.5 && w.combatState !== 'bite_attack') {
                    // Walking speed modulation
                    w.walkTime += dt * speed * 2.0;

                    // Quadruped gait
                    const s = Math.sin(w.walkTime) * 1.0;
                    w.fl.rotation.x = s;
                    w.br.rotation.x = s;
                    w.fr.rotation.x = -s;
                    w.bl.rotation.x = -s;
                }

                else {
                    // Legs straight during bite/idle
                    w.fl.rotation.x = 0;
                    w.br.rotation.x = 0;
                    w.fr.rotation.x = 0;
                    w.bl.rotation.x = 0;
                }

            });
        }

        function handleDeath() {
            clearSave();
            isDead = true;
            // charMat.color.setRGB(1.0, 0, 0); // User Request: No red color
            // charMat.color.setHex(0xff0000); // (Legacy check)

            // Turn screen Black & White (Canvas only, so text stays Red)
            const canvas = document.querySelector('canvas');

            if (canvas) {
                canvas.style.filter = 'grayscale(100%)';
            }

            // Turn Sky (Body Background) Black & White
            document.body.style.background = 'linear-gradient(to top, #000000 0%, #333333 100%)'; // Grayscale of #191970

            // Drop item at death location immediately (snapped to ground)
            if (typeof heldItem !== 'undefined' && heldItem) {
                const dropPos = carPhysics.pos.clone();
                const groundH = getSurfaceHeight(dropPos.x, dropPos.y, dropPos.z);
                dropPos.normalize().multiplyScalar(groundH);
                dropItem(dropPos);
            }

            // Disable controls or auto-respawn timer
            // setTimeout(() => {
            //     respawnPlayer();
            // }, 4000); 

            // Show Game Over UI
            const overlay = document.getElementById('waveTransitionOverlay');
            const text = document.getElementById('waveText');
            if (overlay && text) {
                overlay.style.display = 'flex';
                overlay.style.backgroundColor = 'rgba(0,0,0,0.7)'; // Transparent dark
                overlay.style.opacity = '1';
                text.textContent = t('gameOver');
                text.style.color = '#ff0000'; // Classic Red Game Over
                text.style.fontSize = '4em';
            }

            // Wait 3 seconds before allowing restart
            setTimeout(() => {
                if (text) {
                    text.innerHTML = t('gameOver') + "<br><span style='font-size:0.4em; color:white; margin-top:20px; display:block;'>" + t('restartMsg') + "</span>";
                }

                const restartHandler = () => {
                    document.removeEventListener('click', restartHandler);
                    document.removeEventListener('keydown', restartHandler);
                    window.location.reload();
                };

                document.addEventListener('click', restartHandler);
                document.addEventListener('keydown', restartHandler);
            }, 3000);
        }

        function respawnPlayer() {
            isDead = false;

            // Hide Game Over UI
            const overlay = document.getElementById('waveTransitionOverlay');
            if (overlay) {
                overlay.style.opacity = '0';
                setTimeout(() => { overlay.style.display = 'none'; }, 1000);
            }

            // 1. Reset Position to Dormitory (Chest)
            // Find ground height at chest location
            const groundH = getSurfaceHeight(chestPos.x, chestPos.y, chestPos.z);
            const respawnPos = chestPos.clone().normalize().multiplyScalar(groundH + 0.5);

            carPhysics.pos.copy(respawnPos);
            carGroup.position.copy(respawnPos);

            // Reset rotation/up vector
            carPhysics.up.copy(respawnPos.clone().normalize());
            carPhysics.smoothedUp.copy(carPhysics.up);
            characterContainer.rotation.x = 0;
            characterContainer.rotation.z = 0;
            carPhysics.deathTime = 0;

            // 2. Reset Visuals
            const canvas = document.querySelector('canvas');
            if (canvas) {
                canvas.style.filter = '';
            }
            document.body.style.background = 'linear-gradient(to top, #000000 0%, #191970 100%)';

            const div = document.getElementById('death-message');
            if (div) div.remove();

            // 3. Reset Health/State
            damageCount = 0;
            charMat.color.setRGB(1, 1, 1);
            lastHitTime = 0;

            // 4. Reset Wolves hit counts so they don't immediately "finish" an old kill
            wolves.forEach(w => {
                w.hitCount = 0;
                w.combatState = 'wander';
                w.target = null;
            });


        }


        // --- Mobile Control Logic (Decoupled) ---
        const MobileController = {
            isMobile: false,
            active: false,
            moveVector: new THREE.Vector3(0, 0, 0),
            jumpTrigger: false,

            init: function () {
                // Detect Mobile (Phones/Tablets)
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints > 1 && /Macintosh/i.test(navigator.userAgent)); // iPad Pro often reports as Mac but has touch points

                if (!this.isMobile) return;

                console.log("Mobile device detected. Initializing controls...");

                // Inject CSS
                const style = document.createElement('style');

                style.innerHTML = ` .joystick-base {
                    position: absolute;
                    width: 120px;
                    height: 120px;
                    background: rgba(255, 255, 255, 0.15);
                    border: 2px solid rgba(255, 255, 255, 0.4);
                    border-radius: 50%;
                    display: none;
                    z-index: 9999;
                    pointer-events: none;
                    /* User touches screen, we track via window but this visual should not block */
                    touch-action: none;
                    backdrop-filter: blur(4px);
                    box-sizing: border-box;
                }

                .joystick-knob {
                    position: absolute;
                    width: 50px;
                    height: 50px;
                    background: rgba(255, 255, 255, 0.8);
                    border-radius: 50%;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                    pointer-events: none;
                }

                `;
                document.head.appendChild(style);

                // Create Elements
                this.base = document.createElement('div');
                this.base.className = 'joystick-base';
                this.knob = document.createElement('div');
                this.knob.className = 'joystick-knob';
                this.base.appendChild(this.knob);
                document.body.appendChild(this.base);

                // Attach Events
                this.attachEvents();
            }

            ,

            attachEvents: function () {
                let startX = 0, startY = 0;
                const maxDist = 60; // Max radius (120px / 2)

                // Use 'touchstart' on window to catch tapping anywhere
                window.addEventListener('touchstart', (e) => {

                    // Prevent default if it's a multi-touch gesture to avoid zooming, 
                    // but we want to allow scrolling if not on joystick? 
                    // Actually, "Touch Drag Move" implies a game-like full screen control.
                    // We prevent default to stop scrolling/zooming/selection.
                    if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'A') {
                        e.preventDefault();
                    }

                    this.active = true;
                    this.jumpTrigger = false;

                    const t = e.changedTouches[0];
                    startX = t.clientX;
                    startY = t.clientY;

                    // Show Joystick at touch point
                    this.base.style.left = (startX - 60) + 'px';
                    this.base.style.top = (startY - 60) + 'px';
                    this.base.style.display = 'block';
                    this.knob.style.transform = `translate(-50%, -50%)`;

                    this.moveVector.set(0, 0, 0);
                }

                    , {
                        passive: false
                    });

                window.addEventListener('touchmove', (e) => {
                    if (!this.active) return;
                    e.preventDefault();

                    const t = e.changedTouches[0];
                    const dx = t.clientX - startX;
                    const dy = t.clientY - startY;

                    const dist = Math.sqrt(dx * dx + dy * dy);
                    let moveX = dx;
                    let moveY = dy;

                    // Clamp visual knob
                    if (dist > maxDist) {
                        const ratio = maxDist / dist;
                        moveX *= ratio;
                        moveY *= ratio;
                    }

                    this.knob.style.transform = `translate(-50%, -50%) translate(${moveX}px, ${moveY}px)`;

                    // Map to Logic Vector
                    // Visual Up (-dy) -> Logic Forward (+z)
                    // Visual Right (+dx) -> Logic Left (+x is left in our strange key mapping: A->+x)
                    // Wait, let's re-verify key mapping in animate:
                    // keys.a (Left) -> moveDir.x += 1.
                    // keys.d (Right) -> moveDir.x -= 1.
                    // keys.w (Forward) -> moveDir.z += 1.
                    // keys.s (Backward) -> moveDir.z -= 1.

                    // Joystick Up (dy < 0) -> Need Z > 0 -> z = -dy
                    // Joystick Right (dx > 0) -> Need X < 0 -> x = -dx

                    this.moveVector.set(-(dx / maxDist), 0, -(dy / maxDist));

                    // Clamp vector magnitude to 1.0 for consistency
                    if (this.moveVector.length() > 1) this.moveVector.normalize();

                }

                    , {
                        passive: false
                    });

                window.addEventListener('touchend', (e) => {
                    if (!this.active) return;
                    this.active = false;
                    this.base.style.display = 'none';
                    this.moveVector.set(0, 0, 0);

                    // Trigger Jump on release
                    this.jumpTrigger = true;
                });
            }

            ,

            consumeJump: function () {
                if (this.jumpTrigger) {
                    this.jumpTrigger = false;
                    return true;
                }

                return false;
            }
        }

            ;

        MobileController.init();


        const raycaster = new THREE.Raycaster();
        const cameraLookAtCurrent = new THREE.Vector3(0, 0, 0);
        const clock = new THREE.Clock();

        // --- Pickup System ---
        let heldItem = null;
        let lastDropTime = 0;
        let lastDroppedType = null;
        let lastDroppedIndex = -1;
        let lastPickupTime = 0;

        const pickupDist = 1.25;

        function getVisualGeometry(originalGeo) {
            const clone = originalGeo.clone();

            // Map 'aColor' (Vertex Colors) to 'color' attribute for MeshBasicMaterial
            if (clone.attributes.aColor) {
                clone.setAttribute('color', clone.attributes.aColor);
            }

            return clone;
        }

        // Drop currently held item (Stubbed)
        function dropItem(dropPos, isSwap = false) {
            // REMOVED for Pure Rogue Mode
        }

        function pickupItem(t, i, currentScale) {
            // REMOVED for Pure Rogue Mode
        }

        let lastStandTime = 0; // Track when we last stood still

        function tryPickup(pos) {
            // REMOVED for Pure Rogue Mode
        }

        const animate = () => {
            try {
                requestAnimationFrame(animate);
                const dt = Math.min(clock.getDelta(), 0.1);

                // SYNC INPUTS (Fix for closure scope issues)
                if (typeof window.keys !== 'undefined' && typeof keys !== 'undefined') {
                    if (window.keys.Shift !== undefined) keys.Shift = window.keys.Shift;
                    if (window.keys.e !== undefined) keys.e = window.keys.e;
                }

                // --- HIT STOP & JUICE ---
                if (window.hitStopTimer > 0) {
                    window.hitStopTimer -= dt;
                    // Freeze frame effect (don't update logic)
                    renderer.render(scene, camera);
                    return;
                }

                // Apply Shake
                if (window.shakeIntensity > 0) {
                    const shake = window.shakeIntensity * (Math.random() - 0.5) * 2.0;
                    const shakeVec = new THREE.Vector3(
                        (Math.random() - 0.5) * window.shakeIntensity,
                        (Math.random() - 0.5) * window.shakeIntensity,
                        (Math.random() - 0.5) * window.shakeIntensity
                    );
                    camera.position.add(shakeVec);
                    window.shakeIntensity -= dt * 3.0;
                    if (window.shakeIntensity < 0) window.shakeIntensity = 0;
                }

                // Reset Global Jump Signal each frame
                window.playerDidJumpGlobal = false;

                // Update Player Skills
                if (typeof updatePlayerSkills === 'function') updatePlayerSkills(dt);

                // Pause game logic when upgrade UI is shown
                if (gameState.paused) {
                    renderer.render(scene, camera);
                    return;
                }

                // Rest of animate loop...


                // Common Constants
                const waterRadius = planetRadius + seaLevelRef;

                updateExplosions(dt);

                try {
                    updateWolves(dt);
                }

                catch (e) {
                    console.error("Wolf Error", e);
                }

                // Update enemy arrow indicators
                updateEnemyIndicators();

                // updateFollowers(dt); // Moved to end

                // Resource Replenishment (60s)
                if (!window.resourceTimer) window.resourceTimer = 0;
                window.resourceTimer += dt;

                if (window.resourceTimer > 5.0) {
                    window.resourceTimer = 0;
                    replenishResources();
                }

                // Cleanup Dead Followers
                for (let i = followers.length - 1; i >= 0; i--) {
                    if (followers[i].isDead) {
                        scene.remove(followers[i].mesh);
                        followers.splice(i, 1);

                        // Respawn disabled as per user request
                        // respawnFollowerAtChest();
                    }
                }

                // --- DIRECT MOVEMENT LOGIC (Omnidirectional) ---
                if (isDead) {
                    // Death Animation
                    keys.w = keys.s = keys.a = keys.d = keys[" "] = false; // Disable Input logic

                    // Init death timer
                    if (!carPhysics.deathTime) carPhysics.deathTime = 0;
                    carPhysics.deathTime += dt;

                    // Fall directly
                    if (characterContainer.rotation.x > -Math.PI / 2) {
                        characterContainer.rotation.x -= dt * 5.0; // Faster fall
                    }

                    // Stop movement
                    carPhysics.velocity.set(0, 0, 0);
                }

                const targetSpeed = 10.0;
                const moveDir = new THREE.Vector3(0, 0, 0);

                // Declare isJumpActive HERE to fix ReferenceError
                let isJumpActive = false;

                // --- Player Water Logic ---
                if (!isDead) {
                    if (!carPhysics.waterTime) carPhysics.waterTime = 0;

                    // Use 1.0 offset (Chest/Waist) to match Follower sensitivity
                    if (isPositionInWater(carPhysics.pos, 1.0)) {
                        carPhysics.waterTime += dt;
                    }

                    else {
                        // Gradual Oxygen Recovery (Fast: 2s full recovery)
                        carPhysics.waterTime = Math.max(0, carPhysics.waterTime - dt * 10.0);
                    }

                    if (carPhysics.waterTime > 0.0) {
                        // Immediate Darkening: 0s -> 10s
                        let t = carPhysics.waterTime / 10.0;
                        if (t > 1.0) t = 1.0;
                        const c = 1.0 - t;
                        charMat.color.setRGB(c, c, c);

                        if (carPhysics.waterTime > 10.0) {
                            handleDeath();
                        }
                    }

                    else {

                        // Smooth Recovery
                        if (charMat.color.r < 1.0) {
                            let c = charMat.color.r + dt * 0.5;
                            if (c > 1.0) c = 1.0;
                            charMat.color.setRGB(c, c, c);
                        }
                    }
                }

                if (!isDead) {
                    if (keys.w) moveDir.z += 1;
                    if (keys.s) moveDir.z -= 1;
                    if (keys.a) moveDir.x += 1;
                    if (keys.d) moveDir.x -= 1;

                    // --- Mobile Input Integration ---
                    isJumpActive = keys[" "];

                    if (MobileController.isMobile) {
                        moveDir.add(MobileController.moveVector);

                        if (MobileController.consumeJump()) {
                            isJumpActive = true;
                        }
                    }
                }

                if (moveDir.lengthSq() > 0) moveDir.normalize();

                // Direct Velocity Control with Inertia
                const targetVel = moveDir.multiplyScalar(targetSpeed);

                if (!carPhysics.velocity) carPhysics.velocity = new THREE.Vector3();

                const lerpFactorVal = 5.0 * dt;
                carPhysics.velocity.lerp(targetVel, lerpFactorVal);

                const distinctVel = carPhysics.velocity.clone();
                distinctVel.multiplyScalar(dt); // Displacement

                // Character Animation Logic
                const speed = carPhysics.velocity.length();

                // 1. Face Direction
                if (moveDir.lengthSq() > 0.1) {
                    const targetAngle = Math.atan2(moveDir.x, moveDir.z);
                    const currentRotation = characterContainer.rotation.y;
                    let diff = targetAngle - currentRotation;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    characterContainer.rotation.y += diff * 15.0 * dt;
                }

                // 2. Walk Cycle (Legs)
                // 2. Walk Cycle (Legs)
                if (speed > 0.5) {
                    // Accumulate time based on speed (Fixes strobing and inverse speed illusion)
                    const animSpeed = Math.max(speed, 8.0);
                    playerWalkTime += dt * animSpeed * 1.5;
                    const amp = 0.8;
                    leftLeg.rotation.x = Math.sin(playerWalkTime) * amp;
                    rightLeg.rotation.x = -Math.sin(playerWalkTime) * amp;
                }

                else {
                    const t = dt * 10.0;
                    leftLeg.rotation.x = leftLeg.rotation.x * (1.0 - t);
                    rightLeg.rotation.x = rightLeg.rotation.x * (1.0 - t);
                }

                // Global Movement
                const globalMove = distinctVel.clone();
                globalMove.applyQuaternion(carGroup.quaternion);

                // Resistance / Drag when in water
                const distCenter = carPhysics.pos.length();

                if (distCenter < waterRadius) {
                    globalMove.multiplyScalar(0.6);
                }

                carPhysics.pos.add(globalMove);

                // DEBUG: Title
                document.title = `CarPos: $ {
                    carPhysics.pos.x.toFixed(1)
                }

                | JumpSignal: $ {
                    window.playerDidJumpGlobal
                }

                `;

                const skyPos = carPhysics.pos.clone().normalize().multiplyScalar(planetRadius + 50);
                const rayDir = new THREE.Vector3(0, 0, 0).sub(skyPos).normalize();

                raycaster.set(skyPos, rayDir);
                const intersects = raycaster.intersectObject(planet);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const landPos = hit.point.clone();

                    // Initialize physics Vertical Speed
                    if (carPhysics.vSpeed === undefined) carPhysics.vSpeed = 0;

                    // --- UPDATE FOLLOWERS & WOLVES ---


                    const currentHeight = carPhysics.pos.length();
                    const groundH = landPos.length();

                    // Physics Constants
                    const gravity = -50.0;
                    const waterGravity = -4.5;
                    const swimForce = 15.0;
                    const drag = 0.92;

                    let activeGravity = gravity;
                    let isUnderwater = false;

                    // Water Check
                    if (currentHeight < waterRadius) {
                        isUnderwater = true;
                        activeGravity = waterGravity;
                        carPhysics.vSpeed *= drag;

                        // Swim Up
                        if (isJumpActive) {
                            carPhysics.vSpeed += swimForce * dt;
                        }
                    }

                    // Apply Gravity
                    carPhysics.vSpeed += activeGravity * dt;

                    // Calculate New Height
                    let newH = currentHeight + carPhysics.vSpeed * dt;

                    // Ground Collision
                    if (newH < groundH) {
                        newH = groundH;

                        if (isJumpActive) {
                            carPhysics.vSpeed = 20.0;
                            // Set Global Jump Signal (PLANETSOC)
                            window.playerDidJumpGlobal = true;
                            audioMaster.playJump();
                            // DROP ITEM ON JUMP - DISABLED
                            // dropItem(carPhysics.pos);
                            // DUST FX
                            spawnJumpDust(carPhysics.pos);
                        }

                        else {
                            carPhysics.vSpeed = 0;
                        }
                    }



                    // Water Surface Collision (Ceiling)
                    const surfaceLimit = waterRadius - 1.2;

                    if (groundH < surfaceLimit && newH > surfaceLimit) {
                        newH = surfaceLimit;
                        if (carPhysics.vSpeed > 0) carPhysics.vSpeed = 0;
                    }

                    // Construct New Target Position
                    const finalPos = landPos.clone().normalize().multiplyScalar(newH);

                    // Chest Collision
                    if (chestMesh) {
                        const dist = finalPos.distanceTo(chestMesh.position);
                        const minDist = 2.4; // Matches new radius 2.0 + ~0.4 player size

                        if (dist < minDist) {
                            const dir = new THREE.Vector3().subVectors(finalPos, chestMesh.position).normalize();
                            finalPos.copy(chestMesh.position).add(dir.multiplyScalar(minDist));
                            // Re-snap height to newH to avoid floating/sinking due to displacement
                            // Actually better to keep radius consistent:
                            finalPos.normalize().multiplyScalar(newH);
                        }
                    }

                    // Update Physics Position
                    carPhysics.pos.copy(finalPos);

                    // --- Orientation Logic ---
                    const distToGround = newH - groundH;
                    const sphereNormal = finalPos.clone().normalize();
                    const floorNormal = hit.face ? hit.face.normal.clone().transformDirection(planet.matrixWorld) : sphereNormal;

                    let airFactor = Math.min(distToGround / 2.0, 1.0);
                    if (isUnderwater) airFactor = Math.max(airFactor, 0.5);

                    const blendedTargetUp = new THREE.Vector3().addVectors(floorNormal.multiplyScalar(1.0 - airFactor),
                        sphereNormal.multiplyScalar(airFactor)).normalize();

                    carPhysics.smoothedUp.lerp(blendedTargetUp, 5.0 * dt);
                    carPhysics.smoothedUp.normalize();
                    const targetUp = carPhysics.smoothedUp;

                    const currentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(carGroup.quaternion);
                    const qAlign = new THREE.Quaternion().setFromUnitVectors(currentUp, targetUp);
                    const targetQ = carGroup.quaternion.clone().premultiply(qAlign);
                    carGroup.quaternion.slerp(targetQ, 10.0 * dt);

                    // Position Sync
                    const lerpPosFactor = 0.2;
                    if (carGroup.position.distanceTo(finalPos) > 10) carGroup.position.copy(finalPos);
                    else carGroup.position.lerp(finalPos, lerpPosFactor);
                }

                // Update Uniforms
                // Update Uniforms
                grassMat.uniforms.carPos.value.copy(carGroup.position);
                grassMat.uniforms.time.value = clock.getElapsedTime();
                vegMaterial.uniforms.carPos.value.copy(carGroup.position);
                vegMaterial.uniforms.time.value = clock.getElapsedTime();

                // Moved here to receive Jump Signal
                try {
                    updateFollowers(dt);
                    updateWolves(dt);
                    updateExpItems(dt);
                }

                catch (e) {
                    console.error("Entity Update Error", e);
                }

                // Pickup Logic Removed

                // Held Item Anim Removed

                // --- Chest Logic ---
                // --- Follower Storage Logic ---
                if (!lastFollowerStoreTime) lastFollowerStoreTime = 0;
                const currentTime = clock.getElapsedTime();

                if (currentTime - lastFollowerStoreTime > 1.0) {
                    const max = chestInventory.maxFollowers || 5;
                    if ((chestInventory.followers || 0) + followers.length < max) {
                        chestInventory.followers++;
                    }

                    lastFollowerStoreTime = currentTime;
                }

                // updateFlyingItems(dt);
                // updateChestLogic(carPhysics.pos);
                // updateDormLabel();

                // UI Update Duplicates Removed

                // --- Arrow Navigation Logic (2D HUD) ---
                const distToChest = chestMesh ? carPhysics.pos.distanceTo(chestMesh.position) : 0;

                // Hide if close (User Request: "箱子距离玩家比较近的时候箭头消失") - Increased to 20.0
                if (chestMesh && !isDead && distToChest > 20.0) {
                    hudArrow.style.display = 'block';

                    const target = chestMesh.position.clone();
                    // 1. Project to Screen Space
                    const p = target.clone().project(camera);

                    // p.x, p.y are NDC [-1, 1]. p.z > 1 means behind camera.

                    let x = p.x;
                    let y = p.y;

                    // If behind camera, invert coordinates to point to the edge passed through
                    if (p.z > 1) {
                        x = -x;
                        y = -y;
                    }

                    // 2. Clamp to Screen Boundary
                    // We want the arrow to ALWAYS stick to the edge ("贴着屏幕边界")
                    const margin = 0.9; // 90% of screen half-size (Padding)

                    const absX = Math.abs(x);
                    const absY = Math.abs(y);

                    let scale = 1.0;

                    if (absX > 0.001 || absY > 0.001) {
                        // Find the smallest scale factor that pushes (x,y) to the nearest edge (margin)
                        // But actually we want the INTERSECTION with the box.
                        // So we want the scale 's' such that component >= margin.
                        // Actually: s = margin / max(absX, absY) ??
                        // No. If we are inside, we want to Project OUT to the edge.
                        // So we assume the vector (x,y) defines direction.
                        // We want to find point (sx, sy) on the boundary box.
                        // s = min(margin/absX, margin/absY).

                        scale = Math.min(margin / absX, margin / absY);
                    }

                    // Apply scale to PROJECT (or clamping if outside?)
                    // If we want it "stuck" to boundary, we project OUT (or IN) to the line.
                    // This logic puts it exactly on the margin box.

                    const finalX = x * scale;
                    const finalY = y * scale;

                    // 3. Convert to Pixel Coordinates
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    const cx = w / 2;
                    const cy = h / 2;

                    const px = (finalX + 1) * cx;
                    const py = (-finalY + 1) * cy;

                    hudArrow.style.left = px + 'px';
                    hudArrow.style.top = py + 'px';

                    // 4. Rotation
                    // Calculate angle from center to Arrow Position
                    // CSS coordinates: +X is Right, +Y is Down.
                    // dx = px - cx. dy = py - cy.
                    const dx = px - cx;
                    const dy = py - cy;
                    const rotRad = Math.atan2(dy, dx);
                    // CSS Rotate 0deg = Up?? No, standard transform rotation 0 is usually object's default.
                    // Our arrow (border-bottom) points UP by default.
                    // Mathematical 0 deg (East) = -90 deg rotation relative to Up?
                    // atan2(0,-1) = -90deg (Up).
                    // So if angle is -90, we want 0 rotation.
                    // Rotation = angle + 90.
                    const rotDeg = rotRad * (180 / Math.PI) + 90;

                    hudArrow.style.transform = `translate(-50%, -50%) rotate(${rotDeg}deg)`;

                }

                else {
                    hudArrow.style.display = 'none';
                }


                // Update Planet Uniforms
                if (planet.material.uniforms && planet.material.uniforms.time) {
                    planet.material.uniforms.time.value = clock.getElapsedTime();
                }

                // --- Camera Logic ---
                const playerDir = carGroup.position.clone().normalize();
                const pivotPoint = playerDir.clone().multiplyScalar(planetRadius);
                const stableUp = playerDir.clone();
                const carForward = new THREE.Vector3(0, 0, 1).applyQuaternion(carGroup.quaternion);
                const projForward = carForward.clone().sub(stableUp.clone().multiplyScalar(carForward.dot(stableUp))).normalize();
                const stableRight = new THREE.Vector3().crossVectors(stableUp, projForward).normalize();
                const stableForward = new THREE.Vector3().crossVectors(stableRight, stableUp).normalize();
                const stableMat = new THREE.Matrix4().makeBasis(stableRight, stableUp, stableForward);
                const stableQuat = new THREE.Quaternion().setFromRotationMatrix(stableMat);

                const localOffset = new THREE.Vector3(0, 27.5, -13.75);
                localOffset.applyQuaternion(stableQuat);

                const idealCameraPos = pivotPoint.clone().add(localOffset);

                const lookTargetOffset = new THREE.Vector3(0, 2, -2.0);
                lookTargetOffset.applyQuaternion(carGroup.quaternion);
                const idealLookAt = carGroup.position.clone().add(lookTargetOffset);

                const camPosLerp = 0.05;

                if (camera.position.length() < 10) {
                    camera.position.copy(idealCameraPos);
                    cameraLookAtCurrent.copy(idealLookAt);
                }

                else {
                    camera.position.lerp(idealCameraPos, camPosLerp);
                    cameraLookAtCurrent.lerp(idealLookAt, 0.05);
                }

                camera.up.copy(stableUp);
                camera.lookAt(cameraLookAtCurrent);

                // --- Camera Ground Collision ---
                const camDir = camera.position.clone().normalize();
                let cn = noise(camDir.x * 1.5, camDir.y * 1.5, camDir.z * 1.5);
                cn += 0.5 * noise(camDir.x * 5, camDir.y * 5, camDir.z * 5);
                const cheight = cn * 10.0;
                const groundRad = planetRadius + cheight;
                const minCamDist = groundRad + 2.0;

                if (camera.position.length() < minCamDist) {
                    camera.position.normalize().multiplyScalar(minCamDist);
                }

                // Underwater Fog
                const camDist = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));

                if (camDist < waterRadius) {
                    scene.fog.color.setHex(0x006677);
                    scene.fog.near = 1;
                    scene.fog.far = 30;
                }

                else {
                    scene.fog.color.setHex(0x000000);
                    scene.fog.near = 20;
                    scene.fog.far = 150;
                }

                // UI Update for Population
                const popHud = document.getElementById('pop-hud');
                if (popHud) {
                    const current = followers.length;
                    const max = chestInventory.maxFollowers || 5;

                    // Only rebuild if max changes, else just update filled class
                    if (popHud.children.length !== max) {
                        popHud.innerHTML = '';
                        for (let i = 0; i < max; i++) {
                            const item = document.createElement('div');
                            item.className = 'pop-item';
                            item.innerHTML = `
                                <div class="follower-icon">
                                    <div class="head" style="width: 8px; height: 8px;"></div>
                                    <div class="body" style="width: 12px; height: 6px;"></div>
                                </div>
                            `;
                            popHud.appendChild(item);
                        }
                    }

                    for (let i = 0; i < popHud.children.length; i++) {
                        if (i < current) {
                            popHud.children[i].classList.add('filled');
                        } else {
                            popHud.children[i].classList.remove('filled');
                        }
                    }
                }

                // UI Update for Player Health
                const pHealthFill = document.getElementById('playerHealthFill');
                if (pHealthFill) {
                    const pct = Math.max(0, (chestInventory.hp / chestInventory.maxHp) * 100);
                    pHealthFill.style.width = `${pct}%`;
                }

                // --- Follower Summon Logic ---
                if (!window.followerSummonTimer) window.followerSummonTimer = 0;
                window.followerSummonTimer += dt;
                if (window.followerSummonTimer > 2.0) {
                    window.followerSummonTimer = 0;
                    if (followers.length < chestInventory.maxFollowers) {
                        // Spawn near player
                        const offset = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize().multiplyScalar(5.0);
                        const spawnPos = carGroup.position.clone().add(offset);
                        const h = getSurfaceHeight(spawnPos.x, spawnPos.y, spawnPos.z);
                        spawnPos.normalize().multiplyScalar(h);
                        const f = createFollower(spawnPos);
                        followers.push(f);
                    }
                }

                if (stars) stars.rotation.y += 0.0003;

                renderer.render(scene, camera);

            }

            catch (err) {
                console.error("Animate Loop Error: ", err);
                const div = document.createElement('div');
                div.style.position = 'fixed';
                div.style.top = '10px';
                div.style.left = '10px';
                div.style.color = 'red';
                div.style.background = 'rgba(255,255,255,0.9)';
                div.style.padding = '10px';
                div.style.fontSize = '16px';
                div.innerText = "Runtime Error: " + err.message + "\n" + (err.stack ? err.stack.substr(0, 300) : "");
                div.style.zIndex = 999999;
                document.body.appendChild(div);

                // Break loop on error to avoid freeze
                return;
            }
        }


            ;

        // --- Post-Processing Setup (DISABLED) ---
        /*
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
 
        const bokehPass = new THREE.BokehPass(scene, camera, {
            focus: 35.0,      
            aperture: 0.0001, 
            maxblur: 0.01,    
            width: window.innerWidth,
            height: window.innerHeight
        });
        composer.addPass(bokehPass);
        */

        // --- NEW FEATURES: FUN & DEPTH ---

        window.shakeIntensity = 0;
        window.hitStopTimer = 0;

        function shakeCamera(amount) {
            window.shakeIntensity = amount;
        }

        function applyHitStop(duration) {
            window.hitStopTimer = duration;
        }

        // Skill State
        const playerSkills = {
            dashCooldown: 0,
            shockwaveCooldown: 0,
            isDashing: false,
            dashTime: 0
        };

        // Input Listener Wrapper
        if (typeof keys === 'undefined') window.keys = {};
        window.addEventListener('keydown', (e) => {
            if (window.keys) {
                if (e.key.toLowerCase() === 'shift') window.keys.Shift = true;
                if (e.key.toLowerCase() === 'e') window.keys.e = true;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (window.keys) {
                if (e.key.toLowerCase() === 'shift') window.keys.Shift = false;
                if (e.key.toLowerCase() === 'e') window.keys.e = false;
            }
        });

        function updatePlayerSkills(dt) {
            if (isDead) return;

            // Cooldowns
            if (playerSkills.dashCooldown > 0) playerSkills.dashCooldown -= dt;
            if (playerSkills.shockwaveCooldown > 0) playerSkills.shockwaveCooldown -= dt;

            // 1. DASH (Shift)
            if (keys.Shift && playerSkills.dashCooldown <= 0) {
                playerSkills.isDashing = true;
                playerSkills.dashTime = 0.3; // 0.3s duration
                playerSkills.dashCooldown = 1.0; // 1s cooldown

                // Impulse
                const dashDir = carPhysics.velocity.clone().normalize();
                if (dashDir.lengthSq() < 0.1) dashDir.set(0, 0, 1).applyQuaternion(carGroup.quaternion);

                carPhysics.velocity.add(dashDir.multiplyScalar(20.0)); // Burst speed

                spawnJumpDust(carGroup.position);
                audioMaster.playJump(); // Reuse sound
            }

            if (playerSkills.isDashing) {
                playerSkills.dashTime -= dt;
                carPhysics.isDashing = true; // Flag for invincibility

                // Visual Trail?
                if (playerSkills.dashTime <= 0) {
                    playerSkills.isDashing = false;
                    carPhysics.isDashing = false;
                }
            }

            // 2. SHOCKWAVE (E)
            if (keys.e && playerSkills.shockwaveCooldown <= 0) {
                playerSkills.shockwaveCooldown = 5.0; // 5s cooldown

                createGroundSlamEffect(carGroup.position);
                shakeCamera(0.8);
                applyHitStop(0.1);
                audioMaster.playAttackMelee(); // Reuse sound

                // Damage Logic
                const range = 8.0;
                let hitCount = 0;
                wolves.forEach(w => {
                    const d = w.mesh.position.distanceTo(carGroup.position);
                    if (d < range) {
                        const pushDir = new THREE.Vector3().subVectors(w.mesh.position, carGroup.position).normalize();
                        w.velocity.add(pushDir.multiplyScalar(30.0)); // Big Pushback
                        w.hp -= 50;
                        showDamageNumber(w.mesh.position, 50, 'enemy', true);
                        hitCount++;
                    }
                });

                if (hitCount > 0) console.log("Shockwave hit " + hitCount + " enemies!");
            }
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>