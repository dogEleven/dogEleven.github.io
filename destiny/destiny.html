<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Destiny | 科学命理实验室</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --bg: #030303;
            --card-bg: #0a0a0a;
            --accent: #00f2ff;
            --accent-glow: rgba(0, 242, 255, 0.4);
            --secondary: #ff00c1;
            --text: #e0e0e0;
            --subtext: #666;
        }
        @font-face {
            font-family: 'Geist';
            src: url('https://cdn.jsdelivr.net/gh/fontsource/geist@latest/fonts/variable/geist-sans.woff2') format('woff2');
        }
        body {
            background-color: var(--bg);
            background-image: 
                radial-gradient(circle at 2px 2px, rgba(0, 242, 255, 0.03) 1px, transparent 0),
                linear-gradient(rgba(0, 242, 255, 0.01) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 242, 255, 0.01) 1px, transparent 1px);
            background-size: 40px 40px, 100px 100px, 100px 100px;
            color: var(--text);
            font-family: 'Geist', 'Inter', -apple-system, system-ui, sans-serif;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #app {
            width: 100%;
            max-width: 520px;
            padding: 20px;
            text-align: center;
            z-index: 10;
        }
        body::after {
            content: "";
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: url('https://grainy-gradients.vercel.app/noise.svg');
            opacity: 0.05;
            pointer-events: none;
            z-index: 1000;
        }
        
        .container {
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(60px) saturate(200%);
            padding: 45px;
            border-radius: 40px;
            box-shadow: 
                0 0 100px rgba(0, 0, 0, 0.8), 
                0 0 40px rgba(0, 242, 255, 0.05),
                inset 0 0 20px rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .container:hover {
            border-color: rgba(0, 242, 255, 0.5);
            box-shadow: 
                0 0 120px rgba(0, 242, 255, 0.2),
                inset 0 0 30px rgba(0, 242, 255, 0.05);
            transform: translateY(-8px) scale(1.01);
        }
        .container::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0.3;
        }
        h1 {
            font-size: 36px;
            margin-bottom: 5px;
            letter-spacing: -2px;
            background: linear-gradient(135deg, #fff 0%, #888 50%, #fff 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 900;
            animation: shimmer 8s linear infinite;
        }
        @keyframes shimmer {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        @keyframes glitch {
            0% { transform: translate(0); text-shadow: -2px 0 var(--accent), 2px 0 var(--secondary); }
            2% { transform: translate(2px, 1px); }
            4% { transform: translate(-2px, -1px); }
            6% { transform: translate(0); }
            100% { transform: translate(0); }
        }
        h1:hover {
            animation: glitch 0.2s infinite linear;
        }
        p.subtitle {
            color: var(--subtext);
            font-size: 11px;
            margin-bottom: 35px;
            font-weight: 600;
            letter-spacing: 4px;
            text-transform: uppercase;
        }
        .input-group {
            margin-bottom: 30px;
            text-align: left;
        }
        label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 12px;
            color: var(--subtext);
            font-weight: 700;
            letter-spacing: 2px;
        }
        input {
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            padding: 18px 24px;
            border-radius: 20px;
            color: white;
            font-size: 16px;
            box-sizing: border-box;
            transition: all 0.4s;
            font-family: inherit;
        }
        input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.05);
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.1);
        }
        button {
            width: 100%;
            padding: 20px;
            background: #fff;
            color: #000;
            border: none;
            border-radius: 20px;
            font-size: 15px;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.4s;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:hover {
            transform: scale(1.02);
            background: var(--accent);
            box-shadow: 0 0 40px rgba(0, 242, 255, 0.4);
        }
        button:active { transform: scale(0.98); }
        button:disabled { opacity: 0.3; cursor: not-allowed; }

        .result {
            margin-top: 45px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.01));
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            animation: resultReveal 1.2s cubic-bezier(0.16, 1, 0.3, 1);
            position: relative;
            overflow: hidden;
        }
        .result::after {
            content: "";
            position: absolute;
            top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(0, 242, 255, 0.03) 0%, transparent 70%);
            pointer-events: none;
        }
        @keyframes resultReveal {
            0% { opacity: 0; transform: translateY(40px) scale(0.95); filter: blur(10px); }
            100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
        }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fortune-text {
            font-size: 16px;
            line-height: 1.8;
            color: #bbb;
            text-align: left;
            margin-bottom: 25px;
        }
        .theory-tag {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 10px;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Module Specific Visuals */
        .viz-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.03);
            position: relative;
        }

        /* Tectonic Theory Visual */
        .tectonic-map {
            height: 80px;
            background: rgba(139, 69, 19, 0.05);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .plate {
            position: absolute;
            height: 100%;
            width: 60%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.2));
            border: 0.5px solid rgba(255, 255, 255, 0.1);
        }
        .plate-left { left: -10%; transform: skewX(-20deg); animation: driftLeft 10s infinite alternate ease-in-out; }
        .plate-right { right: -10%; transform: skewX(-20deg); animation: driftRight 10s infinite alternate ease-in-out; }
        .fault-line {
            position: absolute;
            width: 2px;
            height: 150%;
            background: var(--accent);
            box-shadow: 0 0 15px var(--accent);
            opacity: 0.5;
            transform: rotate(20deg);
        }
        @keyframes driftLeft { from { left: -15%; } to { left: -5%; } }
        @keyframes driftRight { from { right: -15%; } to { right: -5%; } }
        
        /* Genetic Algorithm Visual */
        .gene-pool {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .gene-strand {
            height: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
            overflow: hidden;
            display: flex;
        }
        .gene-segment {
            height: 100%;
            flex: 1;
            transition: background 0.5s;
        }

        /* Relativity Visual */
        .event-horizon {
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .black-hole {
            width: 40px;
            height: 40px;
            background: #000;
            border-radius: 50%;
            box-shadow: 0 0 20px #fff, 0 0 40px var(--accent), 0 0 60px var(--accent-glow);
            position: relative;
            z-index: 2;
        }
        .accretion-disk {
            position: absolute;
            width: 120%;
            height: 20px;
            background: linear-gradient(90deg, transparent, var(--accent), #fff, var(--accent), transparent);
            opacity: 0.6;
            filter: blur(4px);
            animation: rotateDisk 2s infinite linear;
        }
        @keyframes rotateDisk {
            from { transform: rotateX(70deg) rotateZ(0deg); }
            to { transform: rotateX(70deg) rotateZ(360deg); }
        }

        /* Cellular Automata Visual */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            gap: 1px;
            background: rgba(255, 255, 255, 0.05);
            padding: 1px;
            border-radius: 4px;
        }
        .grid-cell {
            aspect-ratio: 1;
            background: #030303;
            border-radius: 1px;
        }
        .grid-cell.active {
            background: var(--accent);
            box-shadow: 0 0 5px var(--accent-glow);
        }

        /* Statistical Mechanics Visual */
        .boltzmann-box {
            height: 100px;
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .particle-cloud {
            width: 100%;
            height: 100%;
        }

        .scanning-line {
            position: absolute;
            left: 0; right: 0; height: 100px;
            background: linear-gradient(to bottom, transparent, var(--accent), transparent);
            opacity: 0.1;
            z-index: 100;
            pointer-events: none;
            animation: scan 4s infinite ease-in-out;
        }
        .scanning-line::after {
            content: "";
            position: absolute;
            bottom: 0; left: 0; right: 0; height: 1px;
            background: var(--accent);
            box-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent);
        }
        @keyframes scan {
            0% { top: -100px; opacity: 0; }
            20% { opacity: 0.2; }
            80% { opacity: 0.2; }
            100% { top: 100%; opacity: 0; }
        }

        .telemetry {
            position: fixed;
            font-family: monospace;
            font-size: 9px;
            color: var(--subtext);
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
        }
        .tl { top: 30px; left: 30px; }
        .tr { top: 30px; right: 30px; }
        .bl { bottom: 30px; left: 30px; }
        .br { bottom: 30px; right: 30px; }

        canvas#bgCanvas {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
        }

        .cursor-glow {
            position: fixed;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(0, 242, 255, 0.08) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        @keyframes diffuse {
            0% { transform: translate(0, 0) scale(1); opacity: 0.8; }
            100% { transform: translate(var(--dx), var(--dy)) scale(2); opacity: 0; }
        }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>
    
    <div class="cursor-glow" id="cursorGlow"></div>
    
    <div class="telemetry tl">PROB_MATRIX: {{ (Math.random()).toFixed(6) }}</div>
    <div class="telemetry tr">ENTROPY: {{ (Math.random() * 10).toFixed(2) }} J/K</div>
    <div class="telemetry bl">COORD: 31.23°N 121.47°E</div>
    <div class="telemetry br">SCANS: {{ scanCount }} | VER: 2.7.2</div>

    <div id="app">
        <div class="container">
            <div v-if="isObserving" class="scanning-line"></div>
            
            <div style="position: absolute; top: 20px; right: 30px; font-family: monospace; font-size: 8px; color: var(--subtext); text-align: right;">
                SYS_STATUS: {{ isObserving ? 'ACTIVE' : 'READY' }}<br>
                CPU_LOAD: {{ (Math.random()*10 + 2).toFixed(1) }}%
            </div>

            <h1>QUANTUM DESTINY</h1>
            <p class="subtitle">Predictive Reality Engine</p>
            
            <div v-if="isObserving" style="margin-bottom: 25px;">
                <div style="display: flex; justify-content: space-between; font-family: monospace; font-size: 8px; color: var(--subtext); margin-bottom: 5px;">
                    <span>REALITY_STABILITY</span>
                    <span>{{ stabilityValue }}%</span>
                </div>
                <div style="height: 2px; background: rgba(255,255,255,0.05); width: 100%; border-radius: 1px; overflow: hidden;">
                    <div :style="{ width: stabilityValue + '%', height: '100%', background: 'var(--accent)', transition: 'width 0.1s' }"></div>
                </div>
            </div>

            <div class="input-group">
                <label>Subject Signature</label>
                <input v-model="name" placeholder="Enter identifier..." :disabled="isObserving" spellcheck="false">
            </div>
            
            <button @click="observe" :disabled="!name || isObserving">
                {{ isObserving ? 'Processing Reality...' : 'Initiate Analysis' }}
            </button>

            <div v-if="isObserving" style="margin-top: 30px;">
                <div style="font-family: monospace; font-size: 10px; color: var(--accent); text-align: left; line-height: 2;">
                    <div v-for="log in terminalLogs" :key="log">>> {{ log }}</div>
                </div>
            </div>

            <div v-if="fortune && !isObserving" class="result">
                <div class="theory-tag">{{ theoryName }}</div>
                <div class="fortune-text">{{ fortune }}</div>
                
                <!-- Visual Modules -->
                <div v-if="theoryName.includes('Genetic')" class="viz-box">
                    <div class="gene-pool">
                        <div v-for="i in 5" :key="i" class="gene-strand">
                            <div v-for="j in 20" :key="j" class="gene-segment" 
                                 :style="{ background: Math.random() > 0.7 ? 'var(--accent)' : 'rgba(255,255,255,0.1)' }">
                            </div>
                        </div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 12px; display: flex; justify-content: space-between;">
                        <span>GEN_EVOLUTION: SUCCESS</span>
                        <span>FITNESS: 0.9984</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Chaos')" class="viz-box">
                    <svg width="100%" height="60" viewBox="0 0 200 60">
                        <path d="M 10 30 Q 50 10 100 30 T 190 30" fill="none" stroke="var(--accent)" stroke-width="0.5" opacity="0.5">
                            <animate attributeName="d" values="M 10 30 Q 50 10 100 30 T 190 30; M 10 30 Q 50 50 100 30 T 190 30; M 10 30 Q 50 10 100 30 T 190 30" dur="3s" repeatCount="indefinite" />
                        </path>
                        <circle cx="100" cy="30" r="2" fill="var(--accent)">
                            <animate attributeName="r" values="2;5;2" dur="2s" repeatCount="indefinite" />
                        </circle>
                    </svg>
                </div>

                <div v-if="theoryName.includes('Riemann')" class="viz-box">
                    <div style="height: 40px; display: flex; align-items: flex-end; gap: 2px;">
                        <div v-for="i in 40" :key="i" 
                             :style="{ height: (Math.abs(Math.sin(i * 0.2)) * 100) + '%', width: '4px', background: 'var(--accent)', opacity: Math.random() * 0.5 + 0.2 }">
                        </div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px;">ZETA_ZERO_CROSSING: DETECTION_LOCKED</div>
                </div>

                <div v-if="theoryName.includes('Relativity')" class="viz-box">
                    <div class="event-horizon">
                        <div class="black-hole"></div>
                        <div class="accretion-disk"></div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>GRAVITY_GRADIENT: 9.81g</span>
                        <span>Δt_DILATION: 0.00042s/yr</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Game Theory')" class="viz-box">
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <div v-for="i in 4" :key="i" 
                             class="strategy-cell"
                             :style="{ 
                                border: '1px solid rgba(0, 242, 255, 0.2)', 
                                padding: '10px', 
                                borderRadius: '8px',
                                background: (i === 1) ? 'rgba(0, 242, 255, 0.1)' : 'transparent',
                                position: 'relative'
                             }">
                            <div v-if="i === 1" style="position: absolute; top: -5px; right: -5px; width: 6px; height: 6px; background: var(--accent); border-radius: 50%; box-shadow: 0 0 10px var(--accent);"></div>
                            <div style="font-family: monospace; font-size: 9px; color: var(--accent); margin-bottom: 4px;">P{{i}}: {{ (Math.random() * 10).toFixed(0) }}</div>
                            <div style="height: 2px; background: rgba(255,255,255,0.05); width: 100%;">
                                <div :style="{ width: (Math.random() * 100) + '%', height: '100%', background: 'var(--accent)', opacity: 0.5 }"></div>
                            </div>
                        </div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 12px; text-align: center;">EQUILIBRIUM_FOUND: COOPERATIVE_DOMINANCE</div>
                </div>

                <div v-if="theoryName.includes('Cellular')" class="viz-box">
                    <div class="grid-container">
                        <div v-for="i in 100" :key="i" class="grid-cell" :class="{ active: Math.random() > 0.8 }"></div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>GEN_COUNT: 42</span>
                        <span>EMERGENCE: STABLE_OSCILLATOR</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('String Theory')" class="viz-box">
                    <div style="height: 60px; display: flex; align-items: center; justify-content: center; position: relative;">
                        <svg width="100%" height="100%" viewBox="0 0 200 60">
                            <path v-for="i in 6" :key="i"
                                  :d="'M 20 ' + (10 + i*7) + ' Q 100 ' + (Math.random()*40 + 10) + ' 180 ' + (10 + i*7)"
                                  fill="none" 
                                  stroke="var(--accent)" 
                                  stroke-width="0.3" 
                                  :opacity="0.2 + (i*0.1)">
                                <animate attributeName="d" 
                                         :values="'M 20 ' + (10 + i*7) + ' Q 100 ' + (Math.random()*40 + 10) + ' 180 ' + (10 + i*7) + '; M 20 ' + (10 + i*7) + ' Q 100 ' + (Math.random()*40 + 10) + ' 180 ' + (10 + i*7) + '; M 20 ' + (10 + i*7) + ' Q 100 ' + (Math.random()*40 + 10) + ' 180 ' + (10 + i*7)"
                                         dur="2s" repeatCount="indefinite" />
                            </path>
                        </svg>
                        <div style="position: absolute; font-family: monospace; font-size: 7px; color: var(--accent); top: 5px; right: 10px; opacity: 0.6;">DIMENSIONS: 11D</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 5px; text-align: center;">CALABI-YAU_MANIFOLD: RESONATING</div>
                </div>

                <div v-if="theoryName.includes('Thermodynamics')" class="viz-box">
                    <div style="height: 60px; position: relative; overflow: hidden; background: rgba(255, 60, 0, 0.05); border-radius: 12px;">
                        <div v-for="i in 30" :key="i" 
                             class="entropy-particle"
                             :style="{ 
                                position: 'absolute',
                                left: Math.random() * 100 + '%',
                                top: Math.random() * 100 + '%',
                                width: '2px',
                                height: '2px',
                                background: Math.random() > 0.5 ? 'var(--secondary)' : 'var(--accent)',
                                borderRadius: '50%',
                                '--dx': (Math.random() * 60 - 30) + 'px',
                                '--dy': (Math.random() * 60 - 30) + 'px',
                                animation: `diffuse ${Math.random() * 2 + 1}s infinite linear`
                             }">
                        </div>
                        <div style="position: absolute; top: 10px; right: 15px; font-family: monospace; font-size: 10px; color: var(--secondary); opacity: 0.8;">
                            ENTROPY_FLUX: ACTIVE
                        </div>
                        <div style="position: absolute; bottom: 10px; left: 15px; font-family: monospace; font-size: 14px; color: var(--secondary); font-weight: 900; text-shadow: 0 0 10px var(--secondary);">
                            S: {{ (Math.random() * 0.5 + 0.1).toFixed(4) }}
                        </div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>THERMAL_EQUILIBRIUM: REJECTED</span>
                        <span>ORDER_PARAMETER: 0.88</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Information Theory')" class="viz-box">
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        <div v-for="i in 4" :key="i" style="display: flex; gap: 4px;">
                            <div v-for="j in 20" :key="j" 
                                 :style="{ 
                                    flex: 1, 
                                    height: '8px', 
                                    background: Math.random() > 0.5 ? 'var(--accent)' : 'rgba(255,255,255,0.05)',
                                    borderRadius: '1px',
                                    opacity: Math.random() * 0.8 + 0.2
                                 }">
                            </div>
                        </div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>SHANNON_ENTROPY: 0.94 bits/sym</span>
                        <span>SIGNAL_TO_NOISE: 42dB</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Quantum Tunneling')" class="viz-box">
                    <div style="height: 60px; display: flex; align-items: center; justify-content: center; position: relative;">
                        <div style="position: absolute; left: 0; width: 40%; height: 100%; background: rgba(0, 242, 255, 0.05); border-right: 2px dashed var(--accent);"></div>
                        <div style="position: absolute; right: 0; width: 40%; height: 100%; background: rgba(0, 242, 255, 0.05); border-left: 2px dashed var(--accent);"></div>
                        <div class="particle-tunnel" :style="{ position: 'absolute', width: '8px', height: '8px', background: 'var(--accent)', borderRadius: '50%', boxShadow: '0 0 15px var(--accent)' }"></div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; text-align: center;">PROBABILITY_AMPLITUDE: TUNNELING_DETECTED</div>
                    <style>
                        .particle-tunnel {
                            animation: tunnel 1.5s infinite linear;
                        }
                        @keyframes tunnel {
                            0% { left: 10%; opacity: 1; transform: scale(1); }
                            45% { left: 40%; opacity: 0.2; transform: scale(0.5); }
                            55% { left: 60%; opacity: 0.2; transform: scale(0.5); }
                            100% { left: 90%; opacity: 1; transform: scale(1); }
                        }
                    </style>
                </div>

                <div v-if="theoryName.includes('Dark Matter')" class="viz-box">
                    <div style="height: 60px; position: relative; overflow: hidden; background: #000; border-radius: 12px;">
                        <div v-for="i in 50" :key="i" 
                             :style="{ 
                                position: 'absolute',
                                left: Math.random() * 100 + '%',
                                top: Math.random() * 100 + '%',
                                width: '1px',
                                height: '1px',
                                background: '#fff',
                                opacity: Math.random() * 0.5
                             }">
                        </div>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; background: radial-gradient(circle, transparent 20%, rgba(138, 43, 226, 0.15) 80%);"></div>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255, 255, 255, 0.1); font-family: monospace; font-size: 40px; font-weight: 900; letter-spacing: 10px; pointer-events: none;">Ω_Λ</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>EXPANSION_RATE: H0=70km/s/Mpc</span>
                        <span>DARK_MATTER_RATIO: 26.8%</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Fluid Dynamics')" class="viz-box">
                    <div style="height: 60px; position: relative; overflow: hidden; background: rgba(0, 242, 255, 0.05); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                        <svg width="100%" height="100%" viewBox="0 0 200 60" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="streamGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:var(--accent);stop-opacity:0" />
                                    <stop offset="50%" style="stop-color:var(--accent);stop-opacity:0.5" />
                                    <stop offset="100%" style="stop-color:var(--accent);stop-opacity:0" />
                                </linearGradient>
                            </defs>
                            <path v-for="i in 5" :key="i"
                                  :d="`M -20 ${10+i*8} Q 50 ${5+i*8 + (Math.random()-0.5)*20} 100 ${10+i*8} T 220 ${10+i*8}`"
                                  fill="none" stroke="url(#streamGrad)" stroke-width="1" opacity="0.6">
                                <animate attributeName="stroke-dasharray" values="0,1000;1000,0" dur="3s" repeatCount="indefinite" />
                                <animate attributeName="stroke-dashoffset" values="1000;0" dur="3s" repeatCount="indefinite" />
                            </path>
                            <circle v-for="i in 3" :key="'vortex'+i" :cx="40 + i*50" :cy="30 + (Math.random()-0.5)*20" r="4" fill="none" stroke="var(--accent)" stroke-width="0.5" opacity="0.3">
                                <animate attributeName="r" values="2;6;2" dur="2s" repeatCount="indefinite" />
                            </circle>
                        </svg>
                        <div style="position: absolute; top: 5px; right: 10px; font-family: monospace; font-size: 7px; color: var(--accent); opacity: 0.6;">REYNOLDS_NO: 2300</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>FLOW_STATE: LAMINAR_TRANSITION</span>
                        <span>VISCOSITY: 1.002 mPa·s</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Graph Theory')" class="viz-box">
                    <div style="height: 70px; position: relative; overflow: hidden; background: rgba(0, 242, 255, 0.02); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                        <svg width="100%" height="100%" viewBox="0 0 200 70">
                            <!-- Nodes -->
                            <circle v-for="i in 12" :key="'node'+i" 
                                    :cx="20 + Math.random()*160" :cy="10 + Math.random()*50" 
                                    r="1.5" fill="var(--accent)" opacity="0.6">
                                <animate attributeName="opacity" values="0.2;0.8;0.2" :dur="2+Math.random()*2+'s'" repeatCount="indefinite" />
                            </circle>
                            <!-- Center Hub -->
                            <circle cx="100" cy="35" r="4" fill="var(--accent)">
                                <animate attributeName="r" values="3;5;3" dur="1.5s" repeatCount="indefinite" />
                            </circle>
                            <!-- Connections to Hub -->
                            <line v-for="i in 8" :key="'line'+i"
                                  x1="100" y1="35" 
                                  :x2="20 + Math.random()*160" :y2="10 + Math.random()*50"
                                  stroke="var(--accent)" stroke-width="0.3" opacity="0.3">
                                <animate attributeName="opacity" values="0.1;0.4;0.1" :dur="1+Math.random()*2+'s'" repeatCount="indefinite" />
                            </line>
                        </svg>
                        <div style="position: absolute; top: 5px; right: 10px; font-family: monospace; font-size: 7px; color: var(--accent); opacity: 0.6;">TOPOLOGY: SCALE-FREE</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>CENTRALITY: 0.92</span>
                        <span>CLUSTERING_COEFF: 0.74</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Orbital Mechanics')" class="viz-box">
                    <div style="height: 80px; position: relative; overflow: hidden; background: rgba(255, 255, 255, 0.02); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                        <svg width="100%" height="100%" viewBox="0 0 200 80">
                            <!-- Ellipse Path -->
                            <ellipse cx="100" cy="40" rx="70" ry="25" fill="none" stroke="rgba(0, 242, 255, 0.2)" stroke-width="0.5" stroke-dasharray="2,2" />
                            <!-- Focal Point (Sun) -->
                            <circle cx="140" cy="40" r="4" fill="var(--accent)">
                                <animate attributeName="opacity" values="0.4;1;0.4" dur="2s" repeatCount="indefinite" />
                                <circle cx="140" cy="40" r="8" fill="var(--accent)" opacity="0.1">
                                    <animate attributeName="r" values="4;12;4" dur="2s" repeatCount="indefinite" />
                                </circle>
                            </circle>
                            <!-- Orbiting Planet -->
                            <circle r="3" fill="var(--accent)">
                                <animateMotion dur="4s" repeatCount="indefinite" path="M 30 40 A 70 25 0 1 1 170 40 A 70 25 0 1 1 30 40" keyPoints="0;1" keyTimes="0;1" calcMode="spline" keySplines="0.4 0 0.2 1" />
                            </circle>
                        </svg>
                        <div style="position: absolute; top: 5px; right: 10px; font-family: monospace; font-size: 7px; color: var(--accent); opacity: 0.6;">KEPLER_STATE: PERIHELION_APPROACH</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>ANGULAR_VELOCITY: ω_MAX</span>
                        <span>ECCENTRICITY: e=0.48</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Entanglement')" class="viz-box">
                    <div style="height: 60px; position: relative; overflow: hidden; background: rgba(0, 242, 255, 0.02); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                        <svg width="100%" height="100%" viewBox="0 0 200 60">
                            <line x1="40" y1="30" x2="160" y2="30" stroke="var(--accent)" stroke-width="0.5" stroke-dasharray="4,4" opacity="0.3">
                                <animate attributeName="stroke-dashoffset" from="0" to="8" dur="1s" repeatCount="indefinite" />
                            </line>
                            <circle cx="40" cy="30" r="4" fill="var(--accent)">
                                <animate attributeName="r" values="3;5;3" dur="1.5s" repeatCount="indefinite" />
                                <animate attributeName="opacity" values="0.6;1;0.6" dur="1.5s" repeatCount="indefinite" />
                            </circle>
                            <circle cx="160" cy="30" r="4" fill="var(--accent)">
                                <animate attributeName="r" values="3;5;3" dur="1.5s" repeatCount="indefinite" />
                                <animate attributeName="opacity" values="0.6;1;0.6" dur="1.5s" repeatCount="indefinite" />
                            </circle>
                            <path d="M 40 30 Q 100 10 160 30" fill="none" stroke="var(--accent)" stroke-width="0.2" opacity="0.5">
                                <animate attributeName="d" values="M 40 30 Q 100 10 160 30; M 40 30 Q 100 50 160 30; M 40 30 Q 100 10 160 30" dur="2s" repeatCount="indefinite" />
                            </path>
                        </svg>
                        <div style="position: absolute; top: 5px; right: 10px; font-family: monospace; font-size: 7px; color: var(--accent); opacity: 0.6;">STATE: ENTANGLED_BELL_PAIR</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>CORRELATION: 0.999</span>
                        <span>NON-LOCALITY: DETECTED</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Multiverse')" class="viz-box">
                    <div style="height: 70px; position: relative; overflow: hidden; background: rgba(0, 242, 255, 0.02); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                        <svg width="100%" height="100%" viewBox="0 0 200 70">
                            <!-- Root -->
                            <line x1="10" y1="35" x2="40" y2="35" stroke="var(--accent)" stroke-width="1" opacity="0.8" />
                            <!-- Branches -->
                            <g v-for="i in 3" :key="'branch'+i">
                                <path :d="`M 40 35 Q 60 ${15+i*15} 100 ${10+i*15}`" fill="none" stroke="var(--accent)" :stroke-width="0.5" :opacity="0.3 + i*0.2">
                                    <animate attributeName="stroke-dasharray" values="0,200;200,0" dur="2s" repeatCount="indefinite" />
                                </path>
                                <circle :cx="100" :cy="10+i*15" r="1.5" fill="var(--accent)" :opacity="0.4 + i*0.2">
                                    <animate attributeName="r" values="1;2;1" dur="1s" :begin="i*0.3+'s'" repeatCount="indefinite" />
                                </circle>
                                <!-- Sub-branches -->
                                <path v-for="j in 2" :key="'sub'+j" :d="`M 100 ${10+i*15} Q 130 ${10+i*15 + (j-1.5)*10} 180 ${10+i*15 + (j-1.5)*15}`" fill="none" stroke="var(--accent)" stroke-width="0.2" opacity="0.2" />
                            </g>
                        </svg>
                        <div style="position: absolute; top: 5px; right: 10px; font-family: monospace; font-size: 7px; color: var(--accent); opacity: 0.6;">DIVERGENCE: HIGH</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: space-between;">
                        <span>COHERENCE_LEVEL: 0.76</span>
                        <span>WORLD_LINE_ID: λ-772</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Simulation')" class="viz-box">
                    <div style="height: 60px; position: relative; overflow: hidden; background: #000; border-radius: 12px; font-family: monospace; font-size: 8px; color: #0f0; padding: 10px;">
                        <div v-for="i in 5" :key="i" class="glitch-line" :style="{ top: i*10 + 'px', animationDelay: i*0.2 + 's' }">
                            {{ Math.random().toString(2).substring(2, 30) }}
                        </div>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: 900; background: #000; padding: 2px 5px; border: 1px solid #0f0; box-shadow: 0 0 10px #0f0; text-transform: uppercase;">
                            FATAL_ERROR: DESTINY_UNDEFINED
                        </div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>SYS_UPTIME: 99.9999%</span>
                        <span>LOCAL_REALITY: VIRTUAL</span>
                    </div>
                    <style>
                        .glitch-line {
                            position: absolute;
                            white-space: nowrap;
                            opacity: 0.3;
                            animation: glitch-text 0.1s infinite;
                        }
                        @keyframes glitch-text {
                            0% { transform: translate(0); }
                            20% { transform: translate(-2px, 1px); }
                            40% { transform: translate(2px, -1px); }
                            60% { transform: translate(-1px, -2px); }
                            80% { transform: translate(1px, 2px); }
                            100% { transform: translate(0); }
                        }
                    </style>
                </div>

                <div v-if="theoryName.includes('Tectonic')" class="viz-box">
                    <div class="tectonic-map">
                        <div class="plate plate-left"></div>
                        <div class="plate plate-right"></div>
                        <div class="fault-line"></div>
                        <div style="position: absolute; bottom: 10px; right: 15px; font-family: monospace; font-size: 8px; color: var(--accent); text-transform: uppercase; letter-spacing: 1px;">Stress_Accumulation: 88%</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>SUBDUCTION_ZONE: ACTIVE</span>
                        <span>MAGNITUDE_POTENTIAL: 7.2 Mw</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Holographic')" class="viz-box">
                    <div style="height: 100px; position: relative; overflow: hidden; background: #000; border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                        <svg width="100%" height="100%" viewBox="0 0 200 100">
                            <!-- Horizon -->
                            <circle cx="100" cy="50" r="35" fill="none" stroke="var(--accent)" stroke-width="0.5" stroke-dasharray="4,2" opacity="0.6">
                                <animate attributeName="r" values="33;37;33" dur="4s" repeatCount="indefinite" />
                            </circle>
                            <!-- Projection Center -->
                            <circle cx="100" cy="50" r="2" fill="var(--accent)">
                                <animate attributeName="opacity" values="0.3;1;0.3" dur="2s" repeatCount="indefinite" />
                            </circle>
                            <!-- Information Rays -->
                            <g v-for="i in 12" :key="i">
                                <line x1="100" y1="50" :x2="100 + Math.cos(i*Math.PI/6)*45" :y2="50 + Math.sin(i*Math.PI/6)*45" stroke="var(--accent)" stroke-width="0.2" opacity="0.3">
                                    <animate attributeName="stroke-dasharray" values="0,100;100,0" dur="2s" repeatCount="indefinite" />
                                </line>
                                <rect :x="100 + Math.cos(i*Math.PI/6 + 0.3)*35 - 1" :y="50 + Math.sin(i*Math.PI/6 + 0.3)*35 - 1" width="2" height="2" fill="var(--accent)">
                                    <animate attributeName="opacity" values="0.1;1;0.1" :dur="1+Math.random()+'s'" repeatCount="indefinite" />
                                </rect>
                            </g>
                        </svg>
                        <div style="position: absolute; font-family: monospace; font-size: 8px; color: var(--accent); top: 10px; right: 15px; opacity: 0.8;">S = Akc³/4Gℏ</div>
                        <div style="position: absolute; font-family: monospace; font-size: 7px; color: var(--accent); bottom: 10px; left: 15px; opacity: 0.5;">BIT_DENSITY: 10^69/m²</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>ENTROPY_BOUND: BEKENSTEIN-HAWKING</span>
                        <span>PROJECTION_FIDELITY: 0.999997</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Fractal')" class="viz-box">
                    <div style="height: 100px; position: relative; overflow: hidden; background: #000; border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                        <canvas id="fractalCanvas" width="200" height="100" style="width: 100%; height: 100%;"></canvas>
                        <div style="position: absolute; top: 10px; right: 15px; font-family: monospace; font-size: 8px; color: var(--accent); opacity: 0.6;">D = log(N) / log(1/s)</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>SELF_SIMILARITY: RECURSIVE</span>
                        <span>HAUSDORFF_DIMENSION: 1.26</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Statistical Mechanics')" class="viz-box">
                    <div class="boltzmann-box">
                        <canvas id="boltzmannCanvas" width="200" height="100" style="width: 100%; height: 100%;"></canvas>
                        <div style="position: absolute; top: 10px; right: 15px; font-family: monospace; font-size: 8px; color: var(--accent); background: rgba(0,0,0,0.5); padding: 2px 5px;">Ω = W! / Π ni!</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>MICROSTATE_COUNT: 10^23</span>
                        <span>DISTRIBUTION: MAXWELL-BOLTZMANN</span>
                    </div>
                </div>

                <div v-if="theoryName.includes('Uncertainty')" class="viz-box">
                    <div style="height: 80px; position: relative; overflow: hidden; background: rgba(0, 242, 255, 0.02); border-radius: 12px; display: flex; align-items: center; justify-content: center;">
                        <canvas id="uncertaintyCanvas" width="200" height="80" style="width: 100%; height: 100%;"></canvas>
                        <div style="position: absolute; top: 5px; left: 10px; font-family: monospace; font-size: 7px; color: var(--accent); opacity: 0.6;">Δx · Δp ≥ ℏ/2</div>
                        <div style="position: absolute; bottom: 5px; right: 10px; font-family: monospace; font-size: 7px; color: var(--accent); opacity: 0.4;">OBSERVER_EFFECT: ACTIVE</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext); margin-top: 10px; display: flex; justify-content: space-between;">
                        <span>CONJUGATE_VARIABLES: LOCKED</span>
                        <span>WAVE_FUNCTION: COLLAPSING</span>
                    </div>
                </div>

                <div style="margin-top: 30px; font-size: 9px; color: var(--subtext); font-family: monospace; letter-spacing: 1px;">
                    TS: {{ scanTime }} | HASH: {{ Math.random().toString(36).substring(7).toUpperCase() }}
                </div>
            </div>

            <!-- History Section -->
            <div v-if="scanHistory.length > 0 && !isObserving" style="margin-top: 40px; border-top: 1px solid rgba(255,255,255,0.05); padding-top: 20px;">
                <div style="font-family: monospace; font-size: 8px; color: var(--subtext); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; text-align: left;">Recent Observations</div>
                <div v-for="entry in scanHistory" :key="entry.id" 
                     style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(255,255,255,0.02); border-radius: 10px; margin-bottom: 8px; border: 1px solid rgba(255,255,255,0.03);">
                    <div style="text-align: left;">
                        <div style="font-size: 10px; font-weight: 700; color: #888;">{{ entry.name }}</div>
                        <div style="font-size: 8px; color: #555;">{{ entry.theory.split(':')[0] }}</div>
                    </div>
                    <div style="font-family: monospace; font-size: 8px; color: var(--subtext);">{{ entry.time }}</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');
        let points = [];
        let animationId;

        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', initCanvas);
        initCanvas();

        const cursorGlow = document.getElementById('cursorGlow');
        let mouseX = 0, mouseY = 0;
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            cursorGlow.style.left = mouseX + 'px';
            cursorGlow.style.top = mouseY + 'px';
        });

        window.startVisuals = (mode) => {
            cancelAnimationFrame(animationId);
            points = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            if (mode === 'genetic') {
                for(let i=0; i<100; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        s: Math.random() * 2,
                        v: Math.random() * 0.5 + 0.1,
                        a: Math.random() * Math.PI * 2
                    });
                }
            } else if (mode === 'chaos') {
                // Lorenz attractor sim simplified for bg
                let x = 0.1, y = 0, z = 0;
                const a = 10, b = 28, c = 8/3, dt = 0.01;
                for(let i=0; i<1000; i++) {
                    let dx = a * (y - x) * dt;
                    let dy = (x * (b - z) - y) * dt;
                    let dz = (x * y - c * z) * dt;
                    x += dx; y += dy; z += dz;
                    points.push({x: x * 20 + centerX, y: y * 20 + centerY});
                }
            } else if (mode === 'relativity') {
                for(let i=0; i<200; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 300 + 50;
                    points.push({
                        x: centerX + Math.cos(angle) * dist,
                        y: centerY + Math.sin(angle) * dist,
                        originX: centerX,
                        originY: centerY,
                        angle: angle,
                        dist: dist,
                        v: (1 / dist) * 10
                    });
                }
            } else if (mode === 'gametheory') {
                const rows = 10, cols = 10;
                const spacingX = canvas.width / (cols + 1);
                const spacingY = canvas.height / (rows + 1);
                for(let r=1; r<=rows; r++) {
                    for(let c=1; c<=cols; c++) {
                        points.push({
                            x: c * spacingX,
                            y: r * spacingY,
                            baseX: c * spacingX,
                            baseY: r * spacingY,
                            active: Math.random() > 0.8,
                            pulse: Math.random() * Math.PI * 2
                        });
                    }
                }
            } else if (mode === 'thermo') {
                for(let i=0; i<300; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        s: Math.random() * 2 + 1,
                        life: Math.random()
                    });
                }
            } else if (mode === 'darkmatter') {
                for(let i=0; i<400; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        s: Math.random() * 0.8,
                        vx: (Math.random() - 0.5) * 0.1,
                        vy: (Math.random() - 0.5) * 0.1,
                        alpha: Math.random() * 0.3
                    });
                }
            } else if (mode === 'tunneling') {
                for(let i=0; i<50; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        targetX: Math.random() * canvas.width,
                        targetY: Math.random() * canvas.height,
                        progress: 0,
                        v: Math.random() * 0.02 + 0.005
                    });
                }
            } else if (mode === 'graph') {
                const nodeCount = 40;
                for(let i=0; i<nodeCount; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        isHub: i < 3,
                        size: i < 3 ? 4 : 1.5
                    });
                }
            } else if (mode === 'orbital') {
                for(let i=0; i<3; i++) {
                    points.push({
                        cx: centerX,
                        cy: centerY,
                        rx: 100 + i * 80,
                        ry: 40 + i * 30,
                        angle: Math.random() * Math.PI * 2,
                        v: 0.01 + (3-i) * 0.01
                    });
                }
            } else if (mode === 'entanglement') {
                for(let i=0; i<10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 100 + Math.random() * 100;
                    points.push({
                        x1: centerX + Math.cos(angle) * dist,
                        y1: centerY + Math.sin(angle) * dist,
                        x2: centerX - Math.cos(angle) * dist,
                        y2: centerY - Math.sin(angle) * dist,
                        angle: angle,
                        dist: dist,
                        v: 0.01
                    });
                }
            } else if (mode === 'multiverse') {
                for(let i=0; i<30; i++) {
                    const startY = (canvas.height / 30) * i;
                    points.push({
                        startX: 0,
                        x: 0,
                        y: startY,
                        vx: Math.random() * 2 + 1,
                        alpha: Math.random() * 0.3 + 0.1,
                        nextSplit: 50 + Math.random() * 100
                    });
                }
            } else if (mode === 'uncertainty') {
                for(let i=0; i<500; i++) {
                    points.push({
                        x: centerX + (Math.random() - 0.5) * 400,
                        y: centerY + (Math.random() - 0.5) * 400,
                        baseX: centerX,
                        baseY: centerY,
                        size: Math.random() * 2,
                        v: Math.random() * 0.05,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            } else if (mode === 'simulation') {
                for(let i=0; i<60; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        w: Math.random() * 40 + 10,
                        h: Math.random() * 3 + 1,
                        vx: (Math.random() - 0.5) * 10,
                        life: Math.random(),
                        color: Math.random() > 0.8 ? 'rgba(0, 242, 255, 0.4)' : 'rgba(0, 255, 0, 0.2)'
                    });
                }
            } else if (mode === 'tectonic') {
                for(let i=0; i<20; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 100 + 50,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        opacity: Math.random() * 0.1
                    });
                }
            } else if (mode === 'holographic') {
                for(let i=0; i<15; i++) {
                    points.push({
                        x: centerX,
                        y: centerY,
                        r: 50 + i * 25,
                        angle: Math.random() * Math.PI * 2,
                        v: 0.005 + (15-i) * 0.001,
                        opacity: 0.4 - i * 0.02
                    });
                }
            } else if (mode === 'fractal') {
                for(let i=0; i<100; i++) {
                    points.push({
                        x: centerX,
                        y: centerY,
                        angle: Math.random() * Math.PI * 2,
                        dist: Math.random() * 200,
                        v: 0.01 + Math.random() * 0.02,
                        size: Math.random() * 2
                    });
                }
            } else {
                for(let i=0; i<150; i++) {
                    points.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        s: Math.random() * 1,
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: (Math.random() - 0.5) * 0.2
                    });
                }
            }

            function animate() {
                ctx.fillStyle = 'rgba(3, 3, 3, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (mode === 'genetic') {
                    points.forEach(p => {
                        p.x += Math.cos(p.a) * p.v;
                        p.y += Math.sin(p.a) * p.v;
                        if(p.x < 0 || p.x > canvas.width) p.a = Math.PI - p.a;
                        if(p.y < 0 || p.y > canvas.height) p.a = -p.a;
                        ctx.fillStyle = 'rgba(0, 242, 255, 0.2)';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else if (mode === 'chaos') {
                    ctx.strokeStyle = 'rgba(0, 242, 255, 0.1)';
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for(let i=1; i<points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.stroke();
                } else if (mode === 'relativity') {
                    points.forEach(p => {
                        p.angle += p.v;
                        p.x = p.originX + Math.cos(p.angle) * p.dist;
                        p.y = p.originY + Math.sin(p.angle) * p.dist;
                        ctx.fillStyle = `rgba(0, 242, 255, ${Math.min(1, 20/p.dist)})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else if (mode === 'gametheory') {
                    points.forEach((p, i) => {
                        p.pulse += 0.05;
                        const scale = 1 + Math.sin(p.pulse) * 0.3;
                        ctx.fillStyle = p.active ? `rgba(0, 242, 255, ${0.1 + Math.sin(p.pulse)*0.05})` : 'rgba(255, 255, 255, 0.02)';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2 * scale, 0, Math.PI * 2);
                        ctx.fill();

                        // Connect to neighbors
                        if (p.active) {
                            points.forEach((other, oi) => {
                                if (oi > i && other.active) {
                                    const dist = Math.hypot(p.x - other.x, p.y - other.y);
                                    if (dist < 200) {
                                        ctx.strokeStyle = `rgba(0, 242, 255, ${0.05 * (1 - dist/200)})`;
                                        ctx.lineWidth = 0.5;
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(other.x, other.y);
                                        ctx.stroke();
                                    }
                                }
                            });
                        }
                    });
                } else if (mode === 'cellular') {
                    points.forEach(p => {
                        if (p.active) {
                            ctx.fillStyle = 'rgba(0, 242, 255, 0.05)';
                            ctx.fillRect(p.x, p.y, 18, 18);
                        }
                    });
                } else if (mode === 'thermo') {
                    points.forEach(p => {
                        p.x += p.vx; p.y += p.vy;
                        p.life -= 0.01;
                        if(p.life <= 0 || p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                            p.x = Math.random() * canvas.width;
                            p.y = Math.random() * canvas.height;
                            p.life = 1;
                        }
                        ctx.fillStyle = `rgba(255, 0, 193, ${p.life * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.s * (2 - p.life), 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else if (mode === 'darkmatter') {
                    points.forEach(p => {
                        p.x += p.vx; p.y += p.vy;
                        if(p.x < 0 || p.x > canvas.width) p.vx *= -1;
                        if(p.y < 0 || p.y > canvas.height) p.vy *= -1;
                        ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    // Subtle central glow
                    const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
                    grad.addColorStop(0, 'rgba(138, 43, 226, 0.05)');
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else if (mode === 'tunneling') {
                    points.forEach(p => {
                        p.progress += p.v;
                        if (p.progress >= 1) {
                            p.x = p.targetX; p.y = p.targetY;
                            p.targetX = Math.random() * canvas.width;
                            p.targetY = Math.random() * canvas.height;
                            p.progress = 0;
                        }
                        const curX = p.x + (p.targetX - p.x) * p.progress;
                        const curY = p.y + (p.targetY - p.y) * p.progress;
                        const alpha = Math.sin(p.progress * Math.PI);
                        ctx.fillStyle = `rgba(0, 242, 255, ${alpha * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(curX, curY, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else if (mode === 'graph') {
                    points.forEach((p, i) => {
                        p.x += p.vx; p.y += p.vy;
                        if(p.x < 0 || p.x > canvas.width) p.vx *= -1;
                        if(p.y < 0 || p.y > canvas.height) p.vy *= -1;

                        ctx.fillStyle = p.isHub ? 'rgba(0, 242, 255, 0.8)' : 'rgba(0, 242, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();

                        if (p.isHub) {
                            points.forEach((other, oi) => {
                                if (oi !== i) {
                                    const dist = Math.hypot(p.x - other.x, p.y - other.y);
                                    if (dist < 150) {
                                        ctx.strokeStyle = `rgba(0, 242, 255, ${0.1 * (1 - dist/150)})`;
                                        ctx.lineWidth = 0.5;
                                        ctx.beginPath();
                                        ctx.moveTo(p.x, p.y);
                                        ctx.lineTo(other.x, other.y);
                                        ctx.stroke();
                                    }
                                }
                            });
                        }
                    });
                } else if (mode === 'orbital') {
                    points.forEach((p, i) => {
                        p.angle += p.v;
                        const x = p.cx + Math.cos(p.angle) * p.rx;
                        const y = p.cy + Math.sin(p.angle) * p.ry;
                        
                        // Draw orbit
                        ctx.strokeStyle = `rgba(0, 242, 255, ${0.1 - i*0.02})`;
                        ctx.beginPath();
                        ctx.ellipse(p.cx, p.cy, p.rx, p.ry, 0, 0, Math.PI * 2);
                        ctx.stroke();

                        // Draw planet
                        ctx.fillStyle = `rgba(0, 242, 255, ${0.8 - i*0.2})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 4 - i, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Glow at perihelion (simplified as right side)
                        if (Math.cos(p.angle) > 0.8) {
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = 'var(--accent)';
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    });
                } else if (mode === 'entanglement') {
                    points.forEach(p => {
                        p.angle += p.v;
                        const x1 = centerX + Math.cos(p.angle) * p.dist;
                        const y1 = centerY + Math.sin(p.angle) * p.dist;
                        const x2 = centerX - Math.cos(p.angle) * p.dist;
                        const y2 = centerY - Math.sin(p.angle) * p.dist;

                        ctx.strokeStyle = 'rgba(0, 242, 255, 0.1)';
                        ctx.lineWidth = 0.5;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        ctx.fillStyle = 'rgba(0, 242, 255, 0.6)';
                        ctx.beginPath();
                        ctx.arc(x1, y1, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x2, y2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else if (mode === 'multiverse') {
                    points.forEach(p => {
                        p.x += p.vx;
                        ctx.strokeStyle = `rgba(0, 242, 255, ${p.alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(p.startX, p.y);
                        ctx.lineTo(p.x, p.y);
                        ctx.stroke();
                        
                        if (p.x > p.nextSplit) {
                            p.nextSplit += 100;
                            // Add a little vertical jitter
                            p.y += (Math.random() - 0.5) * 2;
                        }
                        
                        if(p.x > canvas.width) p.x = p.startX;
                    });
                } else if (mode === 'uncertainty') {
                    points.forEach(p => {
                        p.phase += 0.02;
                        const spread = 100 + Math.sin(p.phase) * 50;
                        const x = p.baseX + (p.x - p.baseX) * (spread / 200);
                        const y = p.baseY + (p.y - p.baseY) * (spread / 200);
                        ctx.fillStyle = `rgba(0, 242, 255, ${0.1 * (1 - Math.hypot(x-p.baseX, y-p.baseY)/300)})`;
                        ctx.beginPath();
                        ctx.arc(x, y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else if (mode === 'simulation') {
                    points.forEach(p => {
                        p.x += p.vx;
                        if(p.x > canvas.width) p.x = -p.w;
                        if(p.x < -p.w) p.x = canvas.width;
                        ctx.fillStyle = p.color;
                        ctx.fillRect(p.x, p.y, p.w, p.h);
                        if(Math.random() > 0.98) {
                            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                            ctx.fillRect(p.x, p.y - 10, p.w / 2, 20);
                        }
                    });
                } else if (mode === 'tectonic') {
                    points.forEach(p => {
                        p.x += p.vx; p.y += p.vy;
                        if(p.x < -p.size) p.x = canvas.width;
                        if(p.x > canvas.width) p.x = -p.size;
                        if(p.y < -p.size) p.y = canvas.height;
                        if(p.y > canvas.height) p.y = -p.size;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
                        ctx.beginPath();
                        ctx.rect(p.x, p.y, p.size, p.size);
                        ctx.fill();
                        
                        // Stress lines
                        if(Math.random() > 0.99) {
                            ctx.strokeStyle = 'var(--accent)';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(p.x, p.y);
                            ctx.lineTo(p.x + p.size, p.y + p.size);
                            ctx.stroke();
                        }
                    });
                } else if (mode === 'holographic') {
                    points.forEach((p, i) => {
                        p.angle += p.v;
                        ctx.strokeStyle = `rgba(0, 242, 255, ${p.opacity})`;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // "Information" bits on the ring
                        for(let j=0; j<6; j++) {
                            const bitAngle = p.angle + (j * Math.PI / 3);
                            const bx = p.x + Math.cos(bitAngle) * p.r;
                            const by = p.y + Math.sin(bitAngle) * p.r;
                            ctx.fillStyle = `rgba(0, 242, 255, ${p.opacity * 2})`;
                            ctx.fillRect(bx - 1, by - 1, 2, 2);
                            
                            // Projection lines to center
                            if (i === 0) {
                                ctx.strokeStyle = `rgba(0, 242, 255, ${p.opacity * 0.5})`;
                                ctx.beginPath();
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(bx, by);
                                ctx.stroke();
                            }
                        }
                    });
                } else if (mode === 'fractal') {
                    points.forEach(p => {
                        p.angle += p.v;
                        const x = p.x + Math.cos(p.angle) * p.dist;
                        const y = p.y + Math.sin(p.angle) * p.dist;
                        ctx.fillStyle = 'rgba(0, 242, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(x, y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Small recursion lines
                        if (Math.random() > 0.95) {
                            ctx.strokeStyle = 'rgba(0, 242, 255, 0.1)';
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + Math.cos(p.angle * 2) * 20, y + Math.sin(p.angle * 2) * 20);
                            ctx.stroke();
                        }
                    });
                } else if (mode === 'fluid') {
                    points.forEach(p => {
                        p.x += p.vx;
                        p.y += Math.sin(p.x * 0.02 + p.offset) * 2;
                        if(p.x > canvas.width + 20) p.x = -20;
                        ctx.fillStyle = 'rgba(0, 242, 255, 0.2)';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 1, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else {
                    points.forEach(p => {
                        // Mouse attraction
                        const dx = mouseX - p.x;
                        const dy = mouseY - p.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < 200) {
                            p.vx += dx * 0.0001;
                            p.vy += dy * 0.0001;
                        }

                        p.x += p.vx; p.y += p.vy;
                        if(p.x < 0 || p.x > canvas.width) p.vx *= -1;
                        if(p.y < 0 || p.y > canvas.height) p.vy *= -1;
                        ctx.fillStyle = `rgba(0, 242, 255, ${dist < 200 ? 0.4 : 0.15})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                animationId = requestAnimationFrame(animate);
            }
            animate();
        };
        window.startVisuals();

        const { createApp, ref } = Vue;
        createApp({
            setup() {
                const name = ref('');
                const fortune = ref('');
                const theoryName = ref('');
                const scanTime = ref('');
                const isObserving = ref(false);
                const terminalLogs = ref([]);
                const scanCount = ref(parseInt(localStorage.getItem('destiny_scans') || '0'));
                const scanHistory = ref(JSON.parse(localStorage.getItem('destiny_history') || '[]'));
                const stabilityValue = ref(100);

                const initBoltzmannCanvas = () => {
                    setTimeout(() => {
                        const bCanvas = document.getElementById('boltzmannCanvas');
                        if (!bCanvas) return;
                        const bCtx = bCanvas.getContext('2d');
                        let bParticles = [];
                        for(let i=0; i<40; i++) bParticles.push({
                            x: Math.random() * bCanvas.width,
                            y: Math.random() * bCanvas.height,
                            vx: (Math.random()-0.5)*4,
                            vy: (Math.random()-0.5)*4,
                            r: Math.random() * 2 + 1
                        });

                        const bAnimate = () => {
                            if (!document.getElementById('boltzmannCanvas')) return;
                            bCtx.fillStyle = 'rgba(10, 10, 10, 0.2)';
                            bCtx.fillRect(0, 0, bCanvas.width, bCanvas.height);
                            bParticles.forEach(p => {
                                p.x += p.vx; p.y += p.vy;
                                if(p.x < 0 || p.x > bCanvas.width) p.vx *= -1;
                                if(p.y < 0 || p.y > bCanvas.height) p.vy *= -1;
                                bCtx.fillStyle = 'var(--accent)';
                                bCtx.beginPath();
                                bCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                                bCtx.fill();
                            });
                            requestAnimationFrame(bAnimate);
                        };
                        bAnimate();
                    }, 100);
                };

                const initUncertaintyCanvas = () => {
                    setTimeout(() => {
                        const uCanvas = document.getElementById('uncertaintyCanvas');
                        if (!uCanvas) return;
                        const uCtx = uCanvas.getContext('2d');
                        let uPoints = [];
                        for(let i=0; i<200; i++) uPoints.push({
                            x: Math.random() * uCanvas.width,
                            y: Math.random() * uCanvas.height,
                            vx: (Math.random()-0.5)*2,
                            vy: (Math.random()-0.5)*2
                        });

                        const uAnimate = () => {
                            if (!document.getElementById('uncertaintyCanvas')) return;
                            uCtx.fillStyle = 'rgba(10, 10, 10, 0.2)';
                            uCtx.fillRect(0, 0, uCanvas.width, uCanvas.height);
                            uPoints.forEach(p => {
                                p.x += p.vx; p.y += p.vy;
                                if(p.x < 0 || p.x > uCanvas.width) p.vx *= -1;
                                if(p.y < 0 || p.y > uCanvas.height) p.vy *= -1;
                                uCtx.fillStyle = 'rgba(0, 242, 255, 0.4)';
                                uCtx.fillRect(p.x, p.y, 1, 1);
                            });
                            requestAnimationFrame(uAnimate);
                        };
                        uAnimate();
                    }, 100);
                };

                const initFractalCanvas = () => {
                    setTimeout(() => {
                        const fCanvas = document.getElementById('fractalCanvas');
                        if (!fCanvas) return;
                        const fCtx = fCanvas.getContext('2d');
                        let frame = 0;

                        const fAnimate = () => {
                            if (!document.getElementById('fractalCanvas')) return;
                            frame += 0.02;
                            const w = fCanvas.width;
                            const h = fCanvas.height;
                            fCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                            fCtx.fillRect(0, 0, w, h);

                            fCtx.strokeStyle = 'var(--accent)';
                            fCtx.lineWidth = 0.5;
                            fCtx.beginPath();
                            
                            const centerX = w / 2;
                            const centerY = h / 2;
                            const zoom = 40 + Math.sin(frame) * 10;

                            for (let i = 0; i < 360; i += 5) {
                                const angle = i * Math.PI / 180;
                                let x = Math.cos(angle) * zoom;
                                let y = Math.sin(angle) * zoom;
                                
                                for (let step = 0; step < 5; step++) {
                                    const nextX = x * x - y * y + Math.cos(frame * 0.5) * 0.5;
                                    const nextY = 2 * x * y + Math.sin(frame * 0.5) * 0.5;
                                    
                                    fCtx.moveTo(centerX + x, centerY + y);
                                    fCtx.lineTo(centerX + nextX, centerY + nextY);
                                    
                                    x = nextX;
                                    y = nextY;
                                }
                            }
                            fCtx.stroke();
                            requestAnimationFrame(fAnimate);
                        };
                        fAnimate();
                    }, 100);
                };

                const theories = [
                    {
                        name: "分形几何：自相似性 (Fractal Geometry: Self-Similarity)",
                        mode: 'fractal',
                        generate: (n) => "你的命运展现出无限的自相似性。正如曼德博集合在任何尺度下都隐藏着惊人的美，你对细节的坚持正在构建一个宏大的递归结构。每一个微小的决定都在镜像着你最终的辉煌。"
                    },
                    {
                        name: "统计力学：玻尔兹曼分布 (Statistical Mechanics: Boltzmann Distribution)",
                        mode: 'boltzmann',
                        generate: (n) => "对你当前社会微观状态的统计分析显示，你正处于能量分布的长尾末端。根据麦克斯韦-玻尔兹曼法则，这种『偏离平衡』的态势意味着你拥有极高的潜在动能，一次随机的粒子碰撞（意外相遇）将引发显著的能量跃迁。"
                    },
                    {
                        name: "图论与网络科学：无标度网络 (Graph Theory & Scale-Free Networks)",
                        mode: 'graph',
                        generate: (n) => "拓扑分析显示，你正处于社交引力场的中心节点（Hub）。根据无标度网络法则，『富者愈富』效应即将在你的资源连接中爆发。未来三天内的一次随机握手，可能通过五个中间人连接到你梦想的终点。"
                    },
                    {
                        name: "遗传算法：演化适性 (Genetic Algorithm & Evolutionary Fate)",
                        mode: 'genetic',
                        generate: (n) => {
                            const outcomes = [
                                "基因池演化显示，你当前的行为模式正在快速收敛于一个『全局最优解』。只要保持目前的变异率（创新性），你将在三个周期内迎来生命质变。",
                                "由于环境压力的增加，你的『适性函数』正在重塑。建议在未来两周内增加社交基因的表达强度，以在多维博弈中占据生存优势。",
                                "探测到一股强大的『定向选择』力量。你过去积累的非核心技能正在发生交叉重组，预示着一个全新的职业领域即将为你开启。"
                            ];
                            return outcomes[n.length % outcomes.length];
                        }
                    },
                    {
                        name: "黎曼猜想：素数分布 (Riemann Zeta Hypothesis)",
                        mode: 'riemann',
                        generate: (n) => "观测到你的命运分布正紧密围绕『临界线』展开。这意味着你的生活虽然充满波动，但其底层规律极其稳健，所有看似随机的事件都在为最终的秩序积蓄能量。"
                    },
                    {
                        name: "混沌理论：蝴蝶效应 (Chaos Theory: Butterfly Effect)",
                        mode: 'chaos',
                        generate: (n) => "对初始条件的敏感依赖表明，改变你处理琐事的方式将彻底重写你下个月的财务曲线。一次微小的蝴蝶振翅，正引导你走向宏大的奇异吸引子。"
                    },
                    {
                        name: "广义相对论：时间膨胀 (General Relativity & Time Dilation)",
                        mode: 'relativity',
                        generate: (n) => "时空曲率检测到你正处于一个高能质点附近，这导致了明显的时间膨胀效应。你感知到的『停滞』实际上是外界正在加速演化的错觉。在你的视界边缘，巨大的机遇正被引力锁定。"
                    },
                    {
                        name: "量子隧穿：势垒跃迁 (Quantum Tunneling)",
                        mode: 'tunneling',
                        generate: (n) => "波函数分析显示，你正面临一个传统逻辑上无法逾越的障碍。但由于量子隧穿效应，你已经获得了直接穿透势垒的概率。本月将有不合常理的突破。"
                    },
                    {
                        name: "博弈论：纳什均衡 (Game Theory & Nash Equilibrium)",
                        mode: 'gametheory',
                        generate: (n) => {
                            const outcomes = [
                                "社交场域的多维博弈显示，你正处于一个非对称信息的优势地位。采取『合作博弈』策略将使你的整体收益（人际关系与机会）达到帕累托最优。",
                                "博弈矩阵分析表明，你过去一段时间的『让步』正在形成一种长期的威慑均衡。对方正在重新评估你的底线，预计下周将达成对你更有利的协议。",
                                "在当前的社会博弈中，你正处于『零和博弈』的边缘。切换到『重复博弈』视角，以长期信誉换取短期资源，是当下的最优策略（Nash Equilibrium）。"
                            ];
                            return outcomes[n.length % outcomes.length];
                        }
                    },
                    {
                        name: "元胞自动机：生命涌现 (Cellular Automata & Emergent Complexity)",
                        mode: 'cellular',
                        generate: (n) => "你的生命轨迹正处于一个从简单规则向高度复杂性转化的临界点。就像元胞自动机中的『滑翔机』，一个微小的习惯正在你的生活矩阵中持续移动，并最终引发连锁反应，创造出预料之外的宏大结构。"
                    },
                    {
                        name: "热力学：负熵流与稳态 (Thermodynamics: Negative Entropy & Steady State)",
                        mode: 'thermo',
                        generate: (n) => "热力学第二定律显示，你的系统（生活）正处于一个暂时的高熵状态，导致信息流模糊。然而，探测到一股强大的『负熵流』（可能来自外部环境的注入或内在意志的觉醒）正在逆转这一趋势。通过耗散结构的建立，你正从混沌中演化出全新的有序稳态。"
                    },
                    {
                        name: "信息论：香农熵与信号重建 (Information Theory & Signal Reconstruction)",
                        mode: 'information',
                        generate: (n) => "在当前充满噪声的生活背景中，你的核心意图（Signal）正经历香农极限的考验。观测显示，一个高保真的采样周期即将到来，你之前被误解或丢失的努力将被完美重建，实现信息的最大化增益。"
                    },
                    {
                        name: "弦理论：高维共振 (String Theory & Multidimensional Resonance)",
                        mode: 'string',
                        generate: (n) => "你的命运并非单一的线，而是跨越11维空间的闭合弦。目前的低频波动只是在为一次跨维度的共振做准备。当你的基频与外部场匹配时，你将在多个生活维度（财富、情感、精神）同时观察到跃迁现象。"
                    },
                    {
                        name: "暗物质与暗能量：不可见的影响 (Dark Matter & Dark Energy)",
                        mode: 'darkmatter',
                        generate: (n) => "观测显示，你生活中 95% 的驱动力来自于不可见的『暗区』——那些你尚未察觉的潜意识冲动与外部宏观趋势。目前暗能量正占据主导，预示着你的生活圈层即将发生不可逆转的加速扩张。顺应这种膨胀，而非对抗它。"
                    },
                    {
                        name: "流体力学：层流与湍流 (Fluid Dynamics: Laminar & Turbulent Flow)",
                        mode: 'fluid',
                        generate: (n) => "生命流场的雷诺数显示，你正处于从平稳『层流』向充满变量的『湍流』过度的临界状态。这种波动并非混乱，而是高效率能量交换的体现。保持动力，你将在接下来的漩涡中获得跨越式的动能。"
                    },
                    {
                        name: "天体力学：开普勒轨道与引力助推 (Orbital Mechanics: Keplerian Orbit & Gravity Assist)",
                        mode: 'orbital',
                        generate: (n) => "生命轨道正如椭圆行星路径。分析显示你当前正处于『近日点』（Perihelion），动能达到峰值。这意味着在未来一个公转周期内，你的决断力将获得引力助推，实现远超平时的位移速度。抓住这次加速机会。"
                    },
                    {
                        name: "量子纠缠：非定域性联系 (Quantum Entanglement: Spooky Action at a Distance)",
                        mode: 'entanglement',
                        generate: (n) => "量子相干分析揭示，你正与一个遥远的时空质点处于『量子纠缠』状态。这意味着即便在物理空间上处于孤立，你的任何正面改变都会瞬间同步给那个与你命运交织的人或事。你们之间的『非定域性』联系正处于共振巅峰。"
                    },
                    {
                        name: "平行宇宙：多重现实分支 (Multiverse Theory: Branching Realities)",
                        mode: 'multiverse',
                        generate: (n) => "量子退相干分析显示，你的决策正在引发大规模的世界线分支。在 87% 的邻近宇宙中，你已经完成了当下的目标。这意味着你当前的现实具有极高的耦合度，只要保持观测的一致性，其他宇宙的成功经验将通过量子穿隧效应回馈至你的主世界线。"
                    },
                    {
                        name: "海森堡不确定性原理 (Heisenberg's Uncertainty Principle)",
                        mode: 'uncertainty',
                        generate: (n) => "对你命运的精准观测显示，你正处于『位置』与『动量』的极端权衡中。你越是试图看清最终的目的地，当下的行动路径就越是模糊；而当你专注于当下的每一步时，终点将以概率云的形式弥散。接受这种不确定性，它是你自由意志存在的量子证明。"
                    },
                    {
                        name: "模拟假设：计算不可约性 (Simulation Hypothesis & Computational Irreducibility)",
                        mode: 'simulation',
                        generate: (n) => "底层架构分析显示，你当前遭遇的『巧合』实际上是系统内存溢出导致的逻辑泄漏。这种『计算不可约性』意味着你的未来无法被预先简化，每一秒的体验都是宇宙源代码的实时渲染。由于检测到局部渲染错误，你将在下周获得一段不受因果律限制的『自由运行时间』。"
                    },
                    {
                        name: "板块构造论：能量蓄积与突变 (Plate Tectonics: Stress & Seismic Shift)",
                        mode: 'tectonic',
                        generate: (n) => "你的生活板块正处于长期的『静力蓄积』阶段。就像地壳板块的俯冲带，虽然表面平静，但底层的势能已经接近临界点（Critical Stress）。探测显示，一场改变人生地貌的『震级突变』将在本月发生，请做好迎接全新地形的准备。"
                    },
                    {
                        name: "全息原理：视界信息投影 (The Holographic Principle: Event Horizon Projection)",
                        mode: 'holographic',
                        generate: (n) => "根据全息原理，你的三维人生实际上是存储在二维视界上的信息投影。当前的挑战只是『像素点』的局部重排，并不改变你底层信息的守恒。即使在看似绝望的『黑洞』中心，你的核心价值依然通过霍金辐射向全宇宙广播。"
                    }
                ];

                const observe = () => {
                    isObserving.value = true;
                    terminalLogs.value = [];
                    const logs = [
                        "INITIALIZING NEURAL BRIDGE...",
                        "CALIBRATING PROBABILITY FIELD...",
                        "SEQUENCING TEMPORAL GENES...",
                        "MEASURING ENTROPY GRADIENT...",
                        "RESOLVING LORENZ ATTRACTOR...",
                        "MAPPING NON-EUCLIDEAN DESTINY...",
                        "SYNCHRONIZING ORBITAL RESONANCE...",
                        "FINALIZING REALITY COLLAPSE..."
                    ];
                    let logIdx = 0;
                    const logInterval = setInterval(() => {
                        if (logIdx < logs.length) {
                            terminalLogs.value.push(logs[logIdx++]);
                            stabilityValue.value = 100 - (logIdx * 10) + (Math.random() * 10);
                        } else clearInterval(logInterval);
                    }, 400);

                    setTimeout(() => {
                        const theory = theories[Math.floor(Math.random() * theories.length)];
                        theoryName.value = theory.name;
                        fortune.value = theory.generate(name.value);
                        scanTime.value = new Date().toLocaleTimeString();
                        scanCount.value++;
                        localStorage.setItem('destiny_scans', scanCount.value);
                        
                        // Save to history
                        const historyEntry = {
                            id: Date.now(),
                            name: name.value,
                            theory: theory.name,
                            time: scanTime.value
                        };
                        scanHistory.value.unshift(historyEntry);
                        if (scanHistory.value.length > 5) scanHistory.value.pop();
                        localStorage.setItem('destiny_history', JSON.stringify(scanHistory.value));

                        window.startVisuals(theory.mode);
                        if (theory.mode === 'uncertainty') initUncertaintyCanvas();
                        if (theory.mode === 'boltzmann') initBoltzmannCanvas();
                        if (theory.mode === 'fractal') initFractalCanvas();
                        isObserving.value = false;
                        stabilityValue.value = 100;
                    }, 2800);
                };

                return { name, fortune, theoryName, scanTime, isObserving, observe, terminalLogs, scanCount, scanHistory, stabilityValue };
            }
        }).mount('#app');
    </script>
</body>
</html>
